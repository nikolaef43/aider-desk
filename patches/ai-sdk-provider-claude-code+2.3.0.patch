diff --git a/node_modules/ai-sdk-provider-claude-code/dist/index.cjs b/node_modules/ai-sdk-provider-claude-code/dist/index.cjs
index efc703b..e992b28 100644
--- a/node_modules/ai-sdk-provider-claude-code/dist/index.cjs
+++ b/node_modules/ai-sdk-provider-claude-code/dist/index.cjs
@@ -159,13 +159,25 @@ function parseFilePart(part) {
   }
   return { warning: IMAGE_CONVERSION_WARNING };
 }
-function convertToClaudeCodeMessages(prompt) {
+function convertToClaudeCodeMessages(prompt, sessionId) {
   const messages = [];
   const warnings = [];
   let systemPrompt;
   const streamingSegments = [];
   const imageMap = /* @__PURE__ */ new Map();
   let hasImageParts = false;
+  const lastMessage = prompt.length > 0 ? prompt[prompt.length - 1] : void 0;
+  const extractTextContent = (content) => {
+    return typeof content === "string" ? content : content.filter((part) => part.type === "text").map((part) => part.text).join("\n");
+  };
+  if (lastMessage?.role === "user" && sessionId) {
+    const textContent = extractTextContent(lastMessage.content);
+    return {
+      messagesPrompt: textContent,
+      streamingContentParts: [{ type: "text", text: textContent }],
+      hasImageParts
+    };
+  }
   const addSegment = (formatted) => {
     streamingSegments.push({ formatted });
     return streamingSegments.length - 1;
@@ -190,7 +202,7 @@ function convertToClaudeCodeMessages(prompt) {
       case "user":
         if (typeof message.content === "string") {
           messages.push(message.content);
-          addSegment(`Human: ${message.content}`);
+          addSegment(prompt.length > 1 ? `Human: ${message.content}` : message.content);
         } else {
           const textParts = message.content.filter((part) => part.type === "text").map((part) => part.text).join("\n");
           const segmentIndex = addSegment(textParts ? `Human: ${textParts}` : "");
@@ -237,9 +249,9 @@ function convertToClaudeCodeMessages(prompt) {
         break;
       }
       case "tool":
-        for (const tool3 of message.content) {
-          const resultText = tool3.output.type === "text" ? tool3.output.value : JSON.stringify(tool3.output.value);
-          const formattedToolResult = `Tool Result (${tool3.toolName}): ${resultText}`;
+        for (const tool4 of message.content) {
+          const resultText = tool4.output.type === "text" ? tool4.output.value : JSON.stringify(tool4.output.value);
+          const formattedToolResult = `Tool Result (${tool4.toolName}): ${resultText}`;
           messages.push(formattedToolResult);
           addSegment(formattedToolResult);
         }
@@ -486,6 +498,15 @@ var claudeCodeSettingsSchema = import_zod.z.object({
       })
     )
   ).optional(),
+  aiSdkTools: import_zod.z.record(
+    import_zod.z.string(),
+    import_zod.z.object({
+      description: import_zod.z.string().optional(),
+      inputSchema: import_zod.z.any().optional(),
+      parameters: import_zod.z.any().optional(),
+      execute: import_zod.z.function().optional()
+    })
+  ).optional(),
   mcpServers: import_zod.z.record(
     import_zod.z.string(),
     import_zod.z.union([
@@ -580,9 +601,9 @@ function validateSettings(settings) {
       );
     }
     const validateToolNames = (tools, type) => {
-      tools.forEach((tool3) => {
-        if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\([^)]*\))?$/.test(tool3) && !tool3.startsWith("mcp__")) {
-          warnings.push(`Unusual ${type} tool name format: '${tool3}'`);
+      tools.forEach((tool4) => {
+        if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\([^)]*\))?$/.test(tool4) && !tool4.startsWith("mcp__")) {
+          warnings.push(`Unusual ${type} tool name format: '${tool4}'`);
         }
       });
     };
@@ -658,6 +679,7 @@ function createVerboseLogger(logger, verbose = false) {
 
 // src/claude-code-language-model.ts
 var import_claude_agent_sdk = require("@anthropic-ai/claude-agent-sdk");
+var import_zod2 = require("zod");
 var CLAUDE_CODE_TRUNCATION_WARNING = "Claude Code SDK output ended unexpectedly; returning truncated response from buffered text. Await upstream fix to avoid data loss.";
 var MIN_TRUNCATION_LENGTH = 512;
 function isClaudeCodeTruncationError(error, bufferedText) {
@@ -861,7 +883,10 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
     }
     return str;
   }
-  normalizeToolResult(result) {
+  normalizeToolResult(toolName, result) {
+    if (toolName.startsWith("mcp__ai-sdk__") && Array.isArray(result) && result.length === 1 && "text" in result[0]) {
+      return JSON.parse(result[0].text);
+    }
     if (typeof result === "string") {
       try {
         return JSON.parse(result);
@@ -919,7 +944,64 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
     }
     return warnings;
   }
+  /**
+   * Converts AI SDK ToolSet to a single MCP server named 'ai-sdk'.
+   * This matches the pattern used in aider-desk where multiple tools
+   * are combined into one local MCP server.
+   *
+   * @param toolSet - ToolSet with execute functions from settings.aiSdkTools
+   * @returns MCP server configuration with all tools, or undefined if no tools
+   */
+  convertToolSetToMcpServer(toolSet) {
+    if (!toolSet || Object.keys(toolSet).length === 0) {
+      return void 0;
+    }
+    const sdkTools = Object.entries(toolSet).map(([name, aiTool]) => {
+      const inputSchema = aiTool.inputSchema;
+      const inputShape = "def" in inputSchema && inputSchema.def !== null && typeof inputSchema.def === "object" && "shape" in inputSchema.def ? inputSchema.def.shape : "shape" in inputSchema ? inputSchema.shape : inputSchema;
+      const handler = async (args, extra) => {
+        this.logger.debug(
+          `[claude-code] AI SDK tool executed: ${name} ${JSON.stringify({ args, extra })}`
+        );
+        if (!aiTool.execute) {
+          return {
+            content: [{ type: "text", text: `Tool ${name} has no execute function` }]
+          };
+        }
+        try {
+          const result = await aiTool.execute(args, {
+            toolCallId: extra._meta?.["claudecode/toolUseId"] || "",
+            messages: []
+            // TODO: keep track of messages and pass them in
+          });
+          return {
+            content: [{ type: "text", text: JSON.stringify(result) }]
+          };
+        } catch (error) {
+          const errorMessage = error instanceof Error ? error.message : String(error);
+          return {
+            content: [{ type: "text", text: `Error: ${errorMessage}` }]
+          };
+        }
+      };
+      return (0, import_claude_agent_sdk.tool)(
+        name,
+        aiTool.description || "",
+        inputShape,
+        handler
+      );
+    });
+    const mcpServer = (0, import_claude_agent_sdk.createSdkMcpServer)({
+      name: "ai-sdk",
+      tools: sdkTools
+    });
+    return { "ai-sdk": mcpServer };
+  }
   createQueryOptions(abortController, responseFormat, stderrCollector, sdkOptions, effectiveResume) {
+    const combinedMcpServers = {
+      ...this.settings.mcpServers,
+      ...this.convertToolSetToMcpServer(this.settings.aiSdkTools)
+    };
     const opts = {
       model: this.getModel(),
       abortController,
@@ -943,7 +1025,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
       resumeSessionAt: this.settings.resumeSessionAt,
       sandbox: this.settings.sandbox,
       tools: this.settings.tools,
-      mcpServers: this.settings.mcpServers,
+      mcpServers: Object.keys(combinedMcpServers).length > 0 ? combinedMcpServers : void 0,
       canUseTool: this.settings.canUseTool
     };
     if (this.settings.systemPrompt !== void 0) {
@@ -1071,15 +1153,27 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
       this.logger.warn(`Claude Code Session: ${warning}`);
     }
   }
+  /**
+   * Strips the 'mcp__ai-sdk__' prefix from AI SDK tool names.
+   * This allows AI SDK to match tool names correctly.
+   *
+   * @param name - The tool name (may include the 'mcp__ai-sdk__' prefix)
+   * @returns The tool name with the prefix removed, or the original name if no prefix
+   */
+  normalizeToolName(name) {
+    return name.startsWith("mcp__ai-sdk__") ? name.slice("mcp__ai-sdk__".length) : name;
+  }
   async doGenerate(options) {
     this.logger.debug(`[claude-code] Starting doGenerate request with model: ${this.modelId}`);
     this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? "none"}`);
+    const sdkOptions = this.getSanitizedSdkOptions();
+    const effectiveResume = this.getEffectiveResume(sdkOptions);
     const {
       messagesPrompt,
       warnings: messageWarnings,
       streamingContentParts,
       hasImageParts
-    } = convertToClaudeCodeMessages(options.prompt);
+    } = convertToClaudeCodeMessages(options.prompt, effectiveResume);
     this.logger.debug(
       `[claude-code] Converted ${options.prompt.length} messages, hasImageParts: ${hasImageParts}`
     );
@@ -1095,8 +1189,6 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
     const stderrCollector = (data) => {
       collectedStderr += data;
     };
-    const sdkOptions = this.getSanitizedSdkOptions();
-    const effectiveResume = this.getEffectiveResume(sdkOptions);
     const queryOptions = this.createQueryOptions(
       abortController,
       options.responseFormat,
@@ -1252,12 +1344,15 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
   async doStream(options) {
     this.logger.debug(`[claude-code] Starting doStream request with model: ${this.modelId}`);
     this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? "none"}`);
+    const sdkOptions = this.getSanitizedSdkOptions();
+    const effectiveResume = this.getEffectiveResume(sdkOptions);
+    this.logger.debug(`[claude-code] Prompt: ${JSON.stringify(options.prompt)}`);
     const {
       messagesPrompt,
       warnings: messageWarnings,
       streamingContentParts,
       hasImageParts
-    } = convertToClaudeCodeMessages(options.prompt);
+    } = convertToClaudeCodeMessages(options.prompt, effectiveResume);
     this.logger.debug(
       `[claude-code] Converted ${options.prompt.length} messages for streaming, hasImageParts: ${hasImageParts}`
     );
@@ -1273,8 +1368,6 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
     const stderrCollector = (data) => {
       collectedStderr += data;
     };
-    const sdkOptions = this.getSanitizedSdkOptions();
-    const effectiveResume = this.getEffectiveResume(sdkOptions);
     const queryOptions = this.createQueryOptions(
       abortController,
       options.responseFormat,
@@ -1330,10 +1423,11 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
             return;
           }
           closeToolInput(toolId, state);
+          const toolName = this.normalizeToolName(state.name);
           controller.enqueue({
             type: "tool-call",
             toolCallId: toolId,
-            toolName: state.name,
+            toolName,
             input: state.lastSerializedInput ?? "",
             providerExecuted: true,
             dynamic: true,
@@ -1356,6 +1450,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
           toolStates.clear();
         };
         let usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };
+        let lastMessageRawUsage = void 0;
         let accumulatedText = "";
         let textPartId;
         let streamedTextLength = 0;
@@ -1385,6 +1480,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
             if (message.type === "stream_event") {
               const streamEvent = message;
               const event = streamEvent.event;
+              this.logger.debug(`[claude-code] Stream event: ${event.type}`);
               if (event.type === "content_block_delta" && event.delta.type === "text_delta" && "text" in event.delta && event.delta.text) {
                 const deltaText = event.delta.text;
                 hasReceivedStreamEvents = true;
@@ -1437,38 +1533,44 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                 );
                 continue;
               }
+              if ("usage" in message.message) {
+                this.logger.debug(
+                  `[claude-code] Assistant message usage: ${JSON.stringify(message.message.usage)}`
+                );
+                lastMessageRawUsage = message.message.usage;
+              }
               const content = message.message.content;
-              for (const tool3 of this.extractToolUses(content)) {
-                const toolId = tool3.id;
+              for (const tool4 of this.extractToolUses(content)) {
+                const toolId = tool4.id;
                 let state = toolStates.get(toolId);
                 if (!state) {
                   state = {
-                    name: tool3.name,
+                    name: tool4.name,
                     inputStarted: false,
                     inputClosed: false,
                     callEmitted: false
                   };
                   toolStates.set(toolId, state);
                   this.logger.debug(
-                    `[claude-code] New tool use detected - Tool: ${tool3.name}, ID: ${toolId}`
+                    `[claude-code] New tool use detected - Tool: ${tool4.name}, ID: ${toolId}`
                   );
                 }
-                state.name = tool3.name;
+                state.name = tool4.name;
                 if (!state.inputStarted) {
                   this.logger.debug(
-                    `[claude-code] Tool input started - Tool: ${tool3.name}, ID: ${toolId}`
+                    `[claude-code] Tool input started - Tool: ${tool4.name}, ID: ${toolId}`
                   );
                   controller.enqueue({
                     type: "tool-input-start",
                     id: toolId,
-                    toolName: tool3.name,
+                    toolName: this.normalizeToolName(tool4.name),
                     providerExecuted: true,
                     dynamic: true
                     // V3 field: indicates tool is provider-defined
                   });
                   state.inputStarted = true;
                 }
-                const serializedInput = this.serializeToolInput(tool3.input);
+                const serializedInput = this.serializeToolInput(tool4.input);
                 if (serializedInput) {
                   let deltaPayload = "";
                   if (state.lastSerializedInput === void 0) {
@@ -1529,6 +1631,15 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                   }
                 }
               }
+              if (textPartId) {
+                controller.enqueue({
+                  type: "text-end",
+                  id: textPartId
+                });
+                textPartId = void 0;
+                accumulatedText = "";
+                streamedTextLength = 0;
+              }
             } else if (message.type === "user") {
               if (!message.message?.content) {
                 this.logger.warn(
@@ -1536,10 +1647,26 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                 );
                 continue;
               }
+              if (textPartId) {
+                controller.enqueue({
+                  type: "text-end",
+                  id: textPartId
+                });
+                textPartId = void 0;
+                accumulatedText = "";
+                streamedTextLength = 0;
+                this.logger.debug("[claude-code] Closed text part due to user message with tool results");
+              }
+              this.logger.debug(`[claude-code] Received user message: ${JSON.stringify(message.message)}`);
+              if ("usage" in message.message) {
+                this.logger.debug(`[claude-code] User message usage: ${JSON.stringify(message.message.usage)}`);
+                lastMessageRawUsage = message.message.usage;
+              }
               const content = message.message.content;
               for (const result of this.extractToolResults(content)) {
                 let state = toolStates.get(result.id);
-                const toolName = result.name ?? state?.name ?? _ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;
+                const rawToolName = result.name ?? state?.name ?? _ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;
+                const toolName = this.normalizeToolName(rawToolName);
                 this.logger.debug(
                   `[claude-code] Tool result received - Tool: ${toolName}, ID: ${result.id}`
                 );
@@ -1574,7 +1701,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                   }
                 }
                 state.name = toolName;
-                const normalizedResult = this.normalizeToolResult(result.result);
+                const normalizedResult = this.normalizeToolResult(rawToolName, result.result);
                 const rawResult = typeof result.result === "string" ? result.result : (() => {
                   try {
                     return JSON.stringify(result.result);
@@ -1604,7 +1731,8 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
               }
               for (const error of this.extractToolErrors(content)) {
                 let state = toolStates.get(error.id);
-                const toolName = error.name ?? state?.name ?? _ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;
+                const rawToolName = error.name ?? state?.name ?? _ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;
+                const toolName = this.normalizeToolName(rawToolName);
                 this.logger.debug(
                   `[claude-code] Tool error received - Tool: ${toolName}, ID: ${error.id}`
                 );
@@ -1653,6 +1781,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
               this.logger.info(
                 `[claude-code] Stream completed - Session: ${message.session_id}, Cost: $${message.total_cost_usd?.toFixed(4) ?? "N/A"}, Duration: ${message.duration_ms ?? "N/A"}ms`
               );
+              this.logger.debug(`[claude-code] ModelUsage: ${JSON.stringify(message.modelUsage)}`);
               let rawUsage;
               if ("usage" in message) {
                 rawUsage = message.usage;
@@ -1728,6 +1857,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                     },
                     ...message.duration_ms !== void 0 && { durationMs: message.duration_ms },
                     ...rawUsage !== void 0 && { rawUsage },
+                    ...lastMessageRawUsage !== void 0 && { lastMessageRawUsage },
                     // JSON validation warnings are collected during streaming and included
                     // in providerMetadata since the AI SDK's finish event doesn't support
                     // a top-level warnings field (unlike stream-start which was already emitted)
@@ -1913,7 +2043,7 @@ var import_claude_agent_sdk3 = require("@anthropic-ai/claude-agent-sdk");
 
 // src/mcp-helpers.ts
 var import_claude_agent_sdk2 = require("@anthropic-ai/claude-agent-sdk");
-var import_zod2 = require("zod");
+var import_zod3 = require("zod");
 function createCustomMcpServer(config) {
   const defs = Object.entries(config.tools).map(
     ([name, def]) => (0, import_claude_agent_sdk2.tool)(
diff --git a/node_modules/ai-sdk-provider-claude-code/dist/index.cjs.map b/node_modules/ai-sdk-provider-claude-code/dist/index.cjs.map
index 7dc153a..b67c2f4 100644
--- a/node_modules/ai-sdk-provider-claude-code/dist/index.cjs.map
+++ b/node_modules/ai-sdk-provider-claude-code/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/index.ts","../src/claude-code-provider.ts","../src/claude-code-language-model.ts","../src/convert-to-claude-code-messages.ts","../src/errors.ts","../src/map-claude-code-finish-reason.ts","../src/validation.ts","../src/logger.ts","../src/mcp-helpers.ts"],"sourcesContent":["/**\n * Provider exports for creating and configuring Claude Code instances.\n * @module claude-code\n */\n\n/**\n * Creates a new Claude Code provider instance and the default provider instance.\n * @see {@link createClaudeCode} for creating custom provider instances\n * @see {@link claudeCode} for the default provider instance\n */\nexport { createClaudeCode, claudeCode } from './claude-code-provider.js';\n\n/**\n * Type definitions for the Claude Code provider.\n * @see {@link ClaudeCodeProvider} for the provider interface\n * @see {@link ClaudeCodeProviderSettings} for provider configuration options\n */\nexport type { ClaudeCodeProvider, ClaudeCodeProviderSettings } from './claude-code-provider.js';\n\n/**\n * Language model implementation for Claude Code.\n * This class implements the AI SDK's LanguageModelV2 interface.\n */\nexport { ClaudeCodeLanguageModel } from './claude-code-language-model.js';\n\n/**\n * Type definitions for Claude Code language models.\n * @see {@link ClaudeCodeModelId} for supported model identifiers\n * @see {@link ClaudeCodeLanguageModelOptions} for model configuration options\n */\nexport type {\n  ClaudeCodeModelId,\n  ClaudeCodeLanguageModelOptions,\n} from './claude-code-language-model.js';\n\n/**\n * Settings for configuring Claude Code behavior.\n * Includes options for customizing the CLI execution, permissions, and tool usage.\n */\nexport type { ClaudeCodeSettings, Logger } from './types.js';\n\n// Convenience re-exports from the SDK for custom tools and hooks\nexport { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';\nexport { createCustomMcpServer } from './mcp-helpers.js';\nexport type {\n  HookEvent,\n  HookCallback,\n  HookCallbackMatcher,\n  HookInput,\n  HookJSONOutput,\n  PreToolUseHookInput,\n  PostToolUseHookInput,\n  UserPromptSubmitHookInput,\n  SessionStartHookInput,\n  SessionEndHookInput,\n  CanUseTool,\n  PermissionResult,\n  PermissionUpdate,\n  PermissionBehavior,\n  PermissionRuleValue,\n  McpServerConfig,\n  McpSdkServerConfigWithInstance,\n  OutputFormat,\n} from '@anthropic-ai/claude-agent-sdk';\n\n/**\n * Error handling utilities for Claude Code.\n * These functions help create and identify specific error types.\n *\n * @see {@link isAuthenticationError} to check for authentication failures\n * @see {@link isTimeoutError} to check for timeout errors\n * @see {@link getErrorMetadata} to extract error metadata\n * @see {@link createAPICallError} to create general API errors\n * @see {@link createAuthenticationError} to create authentication errors\n * @see {@link createTimeoutError} to create timeout errors\n */\nexport {\n  isAuthenticationError,\n  isTimeoutError,\n  getErrorMetadata,\n  createAPICallError,\n  createAuthenticationError,\n  createTimeoutError,\n} from './errors.js';\n\n/**\n * Metadata associated with Claude Code errors.\n * Contains additional context about CLI execution failures.\n */\nexport type { ClaudeCodeErrorMetadata } from './errors.js';\n","import type { LanguageModelV2, ProviderV2 } from '@ai-sdk/provider';\nimport { NoSuchModelError } from '@ai-sdk/provider';\nimport { ClaudeCodeLanguageModel, type ClaudeCodeModelId } from './claude-code-language-model.js';\nimport type { ClaudeCodeSettings } from './types.js';\nimport { validateSettings } from './validation.js';\nimport { getLogger } from './logger.js';\n\n/**\n * Claude Code provider interface that extends the AI SDK's ProviderV1.\n * Provides methods to create language models for interacting with Claude via the CLI.\n *\n * @example\n * ```typescript\n * import { claudeCode } from 'ai-sdk-provider-claude-code';\n *\n * // Create a model instance\n * const model = claudeCode('opus');\n *\n * // Or use the explicit methods\n * const chatModel = claudeCode.chat('sonnet');\n * const languageModel = claudeCode.languageModel('opus', { maxTurns: 10 });\n * ```\n */\nexport interface ClaudeCodeProvider extends ProviderV2 {\n  /**\n   * Creates a language model instance for the specified model ID.\n   * This is a shorthand for calling `languageModel()`.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  (modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  /**\n   * Creates a language model instance for text generation.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  languageModel(modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  /**\n   * Alias for `languageModel()` to maintain compatibility with AI SDK patterns.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  chat(modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  imageModel(modelId: string): never;\n}\n\n/**\n * Configuration options for creating a Claude Code provider instance.\n * These settings will be applied as defaults to all models created by the provider.\n *\n * @example\n * ```typescript\n * const provider = createClaudeCode({\n *   defaultSettings: {\n *     maxTurns: 5,\n *     cwd: '/path/to/project'\n *   }\n * });\n * ```\n */\nexport interface ClaudeCodeProviderSettings {\n  /**\n   * Default settings to use for all models created by this provider.\n   * Individual model settings will override these defaults.\n   */\n  defaultSettings?: ClaudeCodeSettings;\n}\n\n/**\n * Creates a Claude Code provider instance with the specified configuration.\n * The provider can be used to create language models for interacting with Claude 4 models.\n *\n * @param options - Provider configuration options\n * @returns Claude Code provider instance\n *\n * @example\n * ```typescript\n * const provider = createClaudeCode({\n *   defaultSettings: {\n *     permissionMode: 'bypassPermissions',\n *     maxTurns: 10\n *   }\n * });\n *\n * const model = provider('opus');\n * ```\n */\nexport function createClaudeCode(options: ClaudeCodeProviderSettings = {}): ClaudeCodeProvider {\n  // Get logger from default settings if provided\n  const logger = getLogger(options.defaultSettings?.logger);\n\n  // Validate default settings if provided\n  if (options.defaultSettings) {\n    const validation = validateSettings(options.defaultSettings);\n    if (!validation.valid) {\n      throw new Error(`Invalid default settings: ${validation.errors.join(', ')}`);\n    }\n    if (validation.warnings.length > 0) {\n      validation.warnings.forEach((warning) => logger.warn(`Claude Code Provider: ${warning}`));\n    }\n  }\n\n  const createModel = (\n    modelId: ClaudeCodeModelId,\n    settings: ClaudeCodeSettings = {}\n  ): LanguageModelV2 => {\n    const mergedSettings = {\n      ...options.defaultSettings,\n      ...settings,\n    };\n\n    // Validate merged settings\n    const validation = validateSettings(mergedSettings);\n    if (!validation.valid) {\n      throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);\n    }\n\n    return new ClaudeCodeLanguageModel({\n      id: modelId,\n      settings: mergedSettings,\n      settingsValidationWarnings: validation.warnings,\n    });\n  };\n\n  const provider = function (modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings) {\n    if (new.target) {\n      throw new Error('The Claude Code model function cannot be called with the new keyword.');\n    }\n\n    return createModel(modelId, settings);\n  };\n\n  provider.languageModel = createModel;\n  provider.chat = createModel; // Alias for languageModel\n\n  // Add textEmbeddingModel method that throws NoSuchModelError\n  provider.textEmbeddingModel = (modelId: string) => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: 'textEmbeddingModel',\n    });\n  };\n\n  provider.imageModel = (modelId: string) => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: 'imageModel',\n    });\n  };\n\n  return provider as ClaudeCodeProvider;\n}\n\n/**\n * Default Claude Code provider instance.\n * Pre-configured provider for quick usage without custom settings.\n *\n * @example\n * ```typescript\n * import { claudeCode } from 'ai-sdk-provider-claude-code';\n * import { generateText } from 'ai';\n *\n * const { text } = await generateText({\n *   model: claudeCode('sonnet'),\n *   prompt: 'Hello, Claude!'\n * });\n * ```\n */\nexport const claudeCode = createClaudeCode();\n","import type {\n  LanguageModelV2,\n  LanguageModelV2CallWarning,\n  LanguageModelV2FinishReason,\n  LanguageModelV2StreamPart,\n  LanguageModelV2Usage,\n  JSONValue,\n} from '@ai-sdk/provider';\nimport { NoSuchModelError, APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/provider-utils';\nimport type { ClaudeCodeSettings, Logger } from './types.js';\nimport { convertToClaudeCodeMessages } from './convert-to-claude-code-messages.js';\nimport { createAPICallError, createAuthenticationError, createTimeoutError } from './errors.js';\nimport { mapClaudeCodeFinishReason } from './map-claude-code-finish-reason.js';\nimport { validateModelId, validatePrompt, validateSessionId } from './validation.js';\nimport { getLogger, createVerboseLogger } from './logger.js';\n\nimport { query, type Options } from '@anthropic-ai/claude-agent-sdk';\nimport type { SDKUserMessage, SDKPartialAssistantMessage } from '@anthropic-ai/claude-agent-sdk';\n\nconst CLAUDE_CODE_TRUNCATION_WARNING =\n  'Claude Code SDK output ended unexpectedly; returning truncated response from buffered text. Await upstream fix to avoid data loss.';\n\nconst MIN_TRUNCATION_LENGTH = 512;\n\n/**\n * Detects if an error represents a truncated SDK JSON stream.\n *\n * The Claude Code SDK can truncate JSON responses mid-stream, producing a SyntaxError.\n * This function distinguishes genuine truncation from normal JSON syntax errors by:\n * 1. Verifying the error is a SyntaxError with truncation-specific messages\n * 2. Ensuring we received meaningful content (>= MIN_TRUNCATION_LENGTH characters)\n * 3. Avoiding false positives from unrelated parse errors\n *\n * Note: We compare against `bufferedText` (assistant text content) rather than the raw\n * JSON buffer length, since the SDK layer doesn't expose buffer positions. The position\n * reported in SyntaxError messages measures the full JSON payload (metadata + content),\n * which is typically much larger than extracted text. Therefore, we cannot reliably use\n * position proximity checks and instead rely on message patterns and content length.\n *\n * @param error - The caught error (expected to be SyntaxError for truncation)\n * @param bufferedText - Accumulated assistant text content (measured in UTF-16 code units)\n * @returns true if error indicates SDK truncation; false otherwise\n */\nfunction isClaudeCodeTruncationError(error: unknown, bufferedText: string): boolean {\n  // Check for SyntaxError by instanceof or by name (for cross-realm errors)\n  const isSyntaxError =\n    error instanceof SyntaxError ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (typeof (error as any)?.name === 'string' &&\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (error as any).name.toLowerCase() === 'syntaxerror');\n\n  if (!isSyntaxError) {\n    return false;\n  }\n\n  if (!bufferedText) {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const rawMessage = typeof (error as any)?.message === 'string' ? (error as any).message : '';\n  const message = rawMessage.toLowerCase();\n\n  // Only match actual truncation patterns, not normal JSON parsing errors.\n  // Real truncation: \"Unexpected end of JSON input\" or \"Unterminated string in JSON...\"\n  // Normal errors: \"Unexpected token X in JSON at position N\" (should be surfaced as errors)\n  const truncationIndicators = [\n    'unexpected end of json input',\n    'unexpected end of input',\n    'unexpected end of string',\n    'unexpected eof',\n    'end of file',\n    'unterminated string',\n    'unterminated string constant',\n  ];\n\n  if (!truncationIndicators.some((indicator) => message.includes(indicator))) {\n    return false;\n  }\n\n  // Require meaningful content before treating as truncation.\n  // Short responses with \"end of input\" errors are likely genuine syntax errors.\n  // Note: bufferedText.length measures UTF-16 code units, not byte length.\n  if (bufferedText.length < MIN_TRUNCATION_LENGTH) {\n    return false;\n  }\n\n  // If we have a truncation indicator AND meaningful content, treat as truncation.\n  return true;\n}\n\nfunction isAbortError(err: unknown): boolean {\n  if (err && typeof err === 'object') {\n    const e = err as { name?: unknown; code?: unknown };\n    if (typeof e.name === 'string' && e.name === 'AbortError') return true;\n    if (typeof e.code === 'string' && e.code.toUpperCase() === 'ABORT_ERR') return true;\n  }\n  return false;\n}\n\nconst STREAMING_FEATURE_WARNING =\n  \"Claude Agent SDK features (hooks/MCP/images) require streaming input. Set `streamingInput: 'always'` or provide `canUseTool` (auto streams only when canUseTool is set).\";\n\nconst SDK_OPTIONS_BLOCKLIST = new Set(['model', 'abortController', 'prompt', 'outputFormat']);\n\ntype ClaudeToolUse = {\n  id: string;\n  name: string;\n  input: unknown;\n};\n\ntype ClaudeToolResult = {\n  id: string;\n  name?: string;\n  result: unknown;\n  isError: boolean;\n};\n\n// Provider extension for tool-error stream parts.\ntype ToolErrorPart = {\n  type: 'tool-error';\n  toolCallId: string;\n  toolName: string;\n  error: string;\n  providerExecuted: true;\n  providerMetadata?: Record<string, JSONValue>;\n};\n\n// Local extension of the AI SDK stream part union to include tool-error.\ntype ExtendedStreamPart = LanguageModelV2StreamPart | ToolErrorPart;\n\n/**\n * Tracks the streaming lifecycle state for a single tool invocation.\n *\n * The tool streaming lifecycle follows this sequence:\n * 1. Tool use detected → state created with all flags false\n * 2. First input seen → `inputStarted` = true, emit `tool-input-start`\n * 3. Input deltas streamed → emit `tool-input-delta` (may be skipped for large/non-prefix updates)\n * 4. Input finalized → `inputClosed` = true, emit `tool-input-end`\n * 5. Tool call formed → `callEmitted` = true, emit `tool-call`\n * 6. Tool results/errors arrive → emit `tool-result` or `tool-error` (may occur multiple times)\n * 7. Stream ends → state cleaned up by `finalizeToolCalls()`\n *\n * @property name - Tool name from SDK (e.g., \"Bash\", \"Read\")\n * @property lastSerializedInput - Most recent serialized input, used for delta calculation\n * @property inputStarted - True after `tool-input-start` emitted; prevents duplicate start events\n * @property inputClosed - True after `tool-input-end` emitted; ensures proper event ordering\n * @property callEmitted - True after `tool-call` emitted; prevents duplicate call events when\n *                         multiple result/error chunks arrive for the same tool invocation\n */\ntype ToolStreamState = {\n  name: string;\n  lastSerializedInput?: string;\n  inputStarted: boolean;\n  inputClosed: boolean;\n  callEmitted: boolean;\n};\n\nfunction toAsyncIterablePrompt(\n  messagesPrompt: string,\n  outputStreamEnded: Promise<unknown>,\n  sessionId?: string,\n  contentParts?: SDKUserMessage['message']['content']\n): AsyncIterable<SDKUserMessage> {\n  const content = (\n    contentParts && contentParts.length > 0\n      ? contentParts\n      : [{ type: 'text', text: messagesPrompt }]\n  ) as SDKUserMessage['message']['content'];\n\n  const msg: SDKUserMessage = {\n    type: 'user',\n    message: {\n      role: 'user',\n      content,\n    },\n    parent_tool_use_id: null,\n    session_id: sessionId ?? '',\n  };\n  return {\n    async *[Symbol.asyncIterator]() {\n      yield msg;\n      await outputStreamEnded;\n    },\n  };\n}\n\n/**\n * Options for creating a Claude Code language model instance.\n *\n * @example\n * ```typescript\n * const model = new ClaudeCodeLanguageModel({\n *   id: 'opus',\n *   settings: {\n *     maxTurns: 10,\n *     permissionMode: 'auto'\n *   }\n * });\n * ```\n */\nexport interface ClaudeCodeLanguageModelOptions {\n  /**\n   * The model identifier to use.\n   * Can be 'opus', 'sonnet', 'haiku', or a custom model string.\n   */\n  id: ClaudeCodeModelId;\n\n  /**\n   * Optional settings to configure the model behavior.\n   */\n  settings?: ClaudeCodeSettings;\n\n  /**\n   * Validation warnings from settings validation.\n   * Used internally to pass warnings from provider.\n   */\n  settingsValidationWarnings?: string[];\n}\n\n/**\n * Supported Claude model identifiers.\n * - 'opus': Claude Opus (most capable)\n * - 'sonnet': Claude Sonnet (balanced performance)\n * - 'haiku': Claude Haiku (fastest, most cost-effective)\n * - Custom string: Any full model identifier (e.g., 'claude-opus-4-5', 'claude-sonnet-4-5-20250514')\n *\n * @example\n * ```typescript\n * const opusModel = claudeCode('opus');\n * const sonnetModel = claudeCode('sonnet');\n * const haikuModel = claudeCode('haiku');\n * const customModel = claudeCode('claude-opus-4-5');\n * ```\n */\nexport type ClaudeCodeModelId = 'opus' | 'sonnet' | 'haiku' | (string & {});\n\nconst modelMap: Record<string, string> = {\n  opus: 'opus',\n  sonnet: 'sonnet',\n  haiku: 'haiku',\n};\n\n/**\n * Language model implementation for Claude Code SDK.\n * This class implements the AI SDK's LanguageModelV2 interface to provide\n * integration with Claude models through the Claude Agent SDK.\n *\n * Features:\n * - Supports streaming and non-streaming generation\n * - Native structured outputs via SDK's outputFormat (guaranteed schema compliance)\n * - Manages CLI sessions for conversation continuity\n * - Provides detailed error handling and retry logic\n *\n * Limitations:\n * - Image inputs require streaming mode\n * - Some parameters like temperature and max tokens are not supported by the CLI\n *\n * @example\n * ```typescript\n * const model = new ClaudeCodeLanguageModel({\n *   id: 'opus',\n *   settings: { maxTurns: 5 }\n * });\n *\n * const result = await model.doGenerate({\n *   prompt: [{ role: 'user', content: 'Hello!' }],\n *   mode: { type: 'regular' }\n * });\n * ```\n */\nexport class ClaudeCodeLanguageModel implements LanguageModelV2 {\n  readonly specificationVersion = 'v2' as const;\n  readonly defaultObjectGenerationMode = 'json' as const;\n  readonly supportsImageUrls = false;\n  readonly supportedUrls = {};\n  readonly supportsStructuredOutputs = true;\n\n  // Fallback/magic string constants\n  static readonly UNKNOWN_TOOL_NAME = 'unknown-tool';\n\n  // Tool input safety limits\n  private static readonly MAX_TOOL_INPUT_SIZE = 1_048_576; // 1MB hard limit\n  private static readonly MAX_TOOL_INPUT_WARN = 102_400; // 100KB warning threshold\n  private static readonly MAX_DELTA_CALC_SIZE = 10_000; // 10KB delta computation threshold\n\n  readonly modelId: ClaudeCodeModelId;\n  readonly settings: ClaudeCodeSettings;\n\n  private sessionId?: string;\n  private modelValidationWarning?: string;\n  private settingsValidationWarnings: string[];\n  private logger: Logger;\n\n  constructor(options: ClaudeCodeLanguageModelOptions) {\n    this.modelId = options.id;\n    this.settings = options.settings ?? {};\n    this.settingsValidationWarnings = options.settingsValidationWarnings ?? [];\n\n    // Create logger that respects verbose setting\n    const baseLogger = getLogger(this.settings.logger);\n    this.logger = createVerboseLogger(baseLogger, this.settings.verbose ?? false);\n\n    // Validate model ID format\n    if (!this.modelId || typeof this.modelId !== 'string' || this.modelId.trim() === '') {\n      throw new NoSuchModelError({\n        modelId: this.modelId,\n        modelType: 'languageModel',\n      });\n    }\n\n    // Additional model ID validation\n    this.modelValidationWarning = validateModelId(this.modelId);\n    if (this.modelValidationWarning) {\n      this.logger.warn(`Claude Code Model: ${this.modelValidationWarning}`);\n    }\n  }\n\n  get provider(): string {\n    return 'claude-code';\n  }\n\n  private getModel(): string {\n    const mapped = modelMap[this.modelId];\n    return mapped ?? this.modelId;\n  }\n\n  private getSanitizedSdkOptions(): Partial<Options> | undefined {\n    if (!this.settings.sdkOptions || typeof this.settings.sdkOptions !== 'object') {\n      return undefined;\n    }\n\n    const sanitized = { ...(this.settings.sdkOptions as Record<string, unknown>) };\n    const blockedKeys = Array.from(SDK_OPTIONS_BLOCKLIST).filter((key) => key in sanitized);\n\n    if (blockedKeys.length > 0) {\n      this.logger.warn(\n        `[claude-code] sdkOptions includes provider-managed fields (${blockedKeys.join(\n          ', '\n        )}); these will be ignored.`\n      );\n      blockedKeys.forEach((key) => delete sanitized[key]);\n    }\n\n    return sanitized as Partial<Options>;\n  }\n\n  private getEffectiveResume(sdkOptions?: Partial<Options>): string | undefined {\n    return sdkOptions?.resume ?? this.settings.resume ?? this.sessionId;\n  }\n\n  private extractToolUses(content: unknown): ClaudeToolUse[] {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (item): item is { type: string; id?: unknown; name?: unknown; input?: unknown } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_use'\n      )\n      .map((item) => {\n        const { id, name, input } = item as { id?: unknown; name?: unknown; input?: unknown };\n        return {\n          id: typeof id === 'string' && id.length > 0 ? id : generateId(),\n          name:\n            typeof name === 'string' && name.length > 0\n              ? name\n              : ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME,\n          input,\n        } satisfies ClaudeToolUse;\n      });\n  }\n\n  private extractToolResults(content: unknown): ClaudeToolResult[] {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (\n          item\n        ): item is {\n          type: string;\n          tool_use_id?: unknown;\n          content?: unknown;\n          is_error?: unknown;\n          name?: unknown;\n        } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_result'\n      )\n      .map((item) => {\n        const { tool_use_id, content, is_error, name } = item;\n        return {\n          id:\n            typeof tool_use_id === 'string' && tool_use_id.length > 0 ? tool_use_id : generateId(),\n          name: typeof name === 'string' && name.length > 0 ? name : undefined,\n          result: content,\n          isError: Boolean(is_error),\n        } satisfies ClaudeToolResult;\n      });\n  }\n\n  private extractToolErrors(content: unknown): Array<{\n    id: string;\n    name?: string;\n    error: unknown;\n  }> {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (\n          item\n        ): item is {\n          type: string;\n          tool_use_id?: unknown;\n          error?: unknown;\n          name?: unknown;\n        } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_error'\n      )\n      .map((item) => {\n        const { tool_use_id, error, name } = item as {\n          tool_use_id?: unknown;\n          error?: unknown;\n          name?: unknown;\n        };\n        return {\n          id:\n            typeof tool_use_id === 'string' && tool_use_id.length > 0 ? tool_use_id : generateId(),\n          name: typeof name === 'string' && name.length > 0 ? name : undefined,\n          error,\n        };\n      });\n  }\n\n  private serializeToolInput(input: unknown): string {\n    if (typeof input === 'string') {\n      return this.checkInputSize(input);\n    }\n\n    if (input === undefined) {\n      return '';\n    }\n\n    try {\n      const serialized = JSON.stringify(input);\n      return this.checkInputSize(serialized);\n    } catch {\n      const fallback = String(input);\n      return this.checkInputSize(fallback);\n    }\n  }\n\n  private checkInputSize(str: string): string {\n    const length = str.length;\n\n    if (length > ClaudeCodeLanguageModel.MAX_TOOL_INPUT_SIZE) {\n      throw new Error(\n        `Tool input exceeds maximum size of ${ClaudeCodeLanguageModel.MAX_TOOL_INPUT_SIZE} bytes (got ${length} bytes). This may indicate a malformed request or an attempt to process excessively large data.`\n      );\n    }\n\n    if (length > ClaudeCodeLanguageModel.MAX_TOOL_INPUT_WARN) {\n      this.logger.warn(\n        `[claude-code] Large tool input detected: ${length} bytes. Performance may be impacted. Consider chunking or reducing input size.`\n      );\n    }\n\n    return str;\n  }\n\n  private normalizeToolResult(result: unknown): unknown {\n    if (typeof result === 'string') {\n      try {\n        return JSON.parse(result);\n      } catch {\n        return result;\n      }\n    }\n\n    return result;\n  }\n\n  private generateAllWarnings(\n    options:\n      | Parameters<LanguageModelV2['doGenerate']>[0]\n      | Parameters<LanguageModelV2['doStream']>[0],\n    prompt: string\n  ): LanguageModelV2CallWarning[] {\n    const warnings: LanguageModelV2CallWarning[] = [];\n    const unsupportedParams: string[] = [];\n\n    // Check for unsupported parameters\n    if (options.temperature !== undefined) unsupportedParams.push('temperature');\n    if (options.topP !== undefined) unsupportedParams.push('topP');\n    if (options.topK !== undefined) unsupportedParams.push('topK');\n    if (options.presencePenalty !== undefined) unsupportedParams.push('presencePenalty');\n    if (options.frequencyPenalty !== undefined) unsupportedParams.push('frequencyPenalty');\n    if (options.stopSequences !== undefined && options.stopSequences.length > 0)\n      unsupportedParams.push('stopSequences');\n    if (options.seed !== undefined) unsupportedParams.push('seed');\n\n    if (unsupportedParams.length > 0) {\n      // Add a warning for each unsupported parameter\n      for (const param of unsupportedParams) {\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: param as\n            | 'temperature'\n            | 'maxTokens'\n            | 'topP'\n            | 'topK'\n            | 'presencePenalty'\n            | 'frequencyPenalty'\n            | 'stopSequences'\n            | 'seed',\n          details: `Claude Code SDK does not support the ${param} parameter. It will be ignored.`,\n        });\n      }\n    }\n\n    // Add model validation warning if present\n    if (this.modelValidationWarning) {\n      warnings.push({\n        type: 'other',\n        message: this.modelValidationWarning,\n      });\n    }\n\n    // Add settings validation warnings\n    this.settingsValidationWarnings.forEach((warning) => {\n      warnings.push({\n        type: 'other',\n        message: warning,\n      });\n    });\n\n    // Warn if JSON response format is requested without a schema\n    // Claude Code only supports structured outputs with schemas (like Anthropic's API)\n    if (options.responseFormat?.type === 'json' && !options.responseFormat.schema) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details:\n          'JSON response format requires a schema for the Claude Code provider. The JSON responseFormat is ignored and the call is treated as plain text.',\n      });\n    }\n\n    // Validate prompt\n    const promptWarning = validatePrompt(prompt);\n    if (promptWarning) {\n      warnings.push({\n        type: 'other',\n        message: promptWarning,\n      });\n    }\n\n    return warnings;\n  }\n\n  private createQueryOptions(\n    abortController: AbortController,\n    responseFormat?: Parameters<LanguageModelV2['doGenerate']>[0]['responseFormat'],\n    stderrCollector?: (data: string) => void,\n    sdkOptions?: Partial<Options>,\n    effectiveResume?: string\n  ): Options {\n    const opts: Partial<Options> & Record<string, unknown> = {\n      model: this.getModel(),\n      abortController,\n      resume: effectiveResume ?? this.settings.resume ?? this.sessionId,\n      pathToClaudeCodeExecutable: this.settings.pathToClaudeCodeExecutable,\n      maxTurns: this.settings.maxTurns,\n      maxThinkingTokens: this.settings.maxThinkingTokens,\n      cwd: this.settings.cwd,\n      executable: this.settings.executable,\n      executableArgs: this.settings.executableArgs,\n      permissionMode: this.settings.permissionMode,\n      permissionPromptToolName: this.settings.permissionPromptToolName,\n      continue: this.settings.continue,\n      allowedTools: this.settings.allowedTools,\n      disallowedTools: this.settings.disallowedTools,\n      betas: this.settings.betas,\n      allowDangerouslySkipPermissions: this.settings.allowDangerouslySkipPermissions,\n      enableFileCheckpointing: this.settings.enableFileCheckpointing,\n      maxBudgetUsd: this.settings.maxBudgetUsd,\n      plugins: this.settings.plugins,\n      resumeSessionAt: this.settings.resumeSessionAt,\n      sandbox: this.settings.sandbox,\n      tools: this.settings.tools,\n      mcpServers: this.settings.mcpServers,\n      canUseTool: this.settings.canUseTool,\n    };\n    // NEW: Agent SDK options with legacy mapping\n    if (this.settings.systemPrompt !== undefined) {\n      opts.systemPrompt = this.settings.systemPrompt;\n    } else if (this.settings.customSystemPrompt !== undefined) {\n      // Deprecation warning for legacy field\n      this.logger.warn(\n        \"[claude-code] 'customSystemPrompt' is deprecated and will be removed in a future major release. Please use 'systemPrompt' instead (string or { type: 'preset', preset: 'claude_code', append? }).\"\n      );\n      opts.systemPrompt = this.settings.customSystemPrompt;\n    } else if (this.settings.appendSystemPrompt !== undefined) {\n      // Deprecation warning for legacy field\n      this.logger.warn(\n        \"[claude-code] 'appendSystemPrompt' is deprecated and will be removed in a future major release. Please use 'systemPrompt: { type: 'preset', preset: 'claude_code', append: <text> }' instead.\"\n      );\n      opts.systemPrompt = {\n        type: 'preset',\n        preset: 'claude_code',\n        append: this.settings.appendSystemPrompt,\n      } as const;\n    }\n    if (this.settings.settingSources !== undefined) {\n      opts.settingSources = this.settings.settingSources;\n    }\n    if (this.settings.additionalDirectories !== undefined) {\n      opts.additionalDirectories = this.settings.additionalDirectories;\n    }\n    if (this.settings.agents !== undefined) {\n      opts.agents = this.settings.agents;\n    }\n    if (this.settings.includePartialMessages !== undefined) {\n      opts.includePartialMessages = this.settings.includePartialMessages;\n    }\n    if (this.settings.fallbackModel !== undefined) {\n      opts.fallbackModel = this.settings.fallbackModel;\n    }\n    if (this.settings.forkSession !== undefined) {\n      opts.forkSession = this.settings.forkSession;\n    }\n    if (this.settings.strictMcpConfig !== undefined) {\n      opts.strictMcpConfig = this.settings.strictMcpConfig;\n    }\n    if (this.settings.extraArgs !== undefined) {\n      opts.extraArgs = this.settings.extraArgs;\n    }\n    // hooks is supported in newer SDKs; include it if provided\n    if (this.settings.hooks) {\n      opts.hooks = this.settings.hooks;\n    }\n\n    const sdkOverrides = sdkOptions\n      ? (sdkOptions as Partial<Options> & Record<string, unknown>)\n      : undefined;\n    const sdkEnv =\n      sdkOverrides && typeof sdkOverrides.env === 'object' && sdkOverrides.env !== null\n        ? (sdkOverrides.env as Record<string, string | undefined>)\n        : undefined;\n    const sdkStderr =\n      sdkOverrides && typeof sdkOverrides.stderr === 'function'\n        ? (sdkOverrides.stderr as (data: string) => void)\n        : undefined;\n    if (sdkOverrides) {\n      const rest = { ...sdkOverrides };\n      delete rest.env;\n      delete rest.stderr;\n      Object.assign(opts, rest);\n    }\n\n    // Wrap stderr callback to also collect data for error reporting\n    const userStderrCallback = sdkStderr ?? this.settings.stderr;\n    if (stderrCollector || userStderrCallback) {\n      opts.stderr = (data: string) => {\n        if (stderrCollector) stderrCollector(data);\n        if (userStderrCallback) userStderrCallback(data);\n      };\n    }\n\n    if (this.settings.env !== undefined || sdkEnv !== undefined) {\n      opts.env = { ...process.env, ...this.settings.env, ...sdkEnv };\n    }\n\n    // Native structured outputs (SDK 0.1.45+)\n    if (responseFormat?.type === 'json' && responseFormat.schema) {\n      opts.outputFormat = {\n        type: 'json_schema',\n        schema: responseFormat.schema as Record<string, unknown>,\n      };\n    }\n\n    return opts as Options;\n  }\n\n  private handleClaudeCodeError(\n    error: unknown,\n    messagesPrompt: string,\n    collectedStderr?: string\n  ): APICallError | LoadAPIKeyError {\n    // Handle AbortError from the SDK\n    if (isAbortError(error)) {\n      // Return the abort reason if available, otherwise the error itself\n      throw error;\n    }\n\n    // Type guard for error with properties\n    const isErrorWithMessage = (err: unknown): err is { message?: string } => {\n      return typeof err === 'object' && err !== null && 'message' in err;\n    };\n\n    const isErrorWithCode = (\n      err: unknown\n    ): err is { code?: string; exitCode?: number; stderr?: string } => {\n      return typeof err === 'object' && err !== null;\n    };\n\n    // Check for authentication errors with improved detection\n    const authErrorPatterns = [\n      'not logged in',\n      'authentication',\n      'unauthorized',\n      'auth failed',\n      'please login',\n      'claude login',\n    ];\n\n    const errorMessage =\n      isErrorWithMessage(error) && error.message ? error.message.toLowerCase() : '';\n\n    const exitCode =\n      isErrorWithCode(error) && typeof error.exitCode === 'number' ? error.exitCode : undefined;\n\n    const isAuthError =\n      authErrorPatterns.some((pattern) => errorMessage.includes(pattern)) || exitCode === 401;\n\n    if (isAuthError) {\n      return createAuthenticationError({\n        message:\n          isErrorWithMessage(error) && error.message\n            ? error.message\n            : 'Authentication failed. Please ensure Claude Code SDK is properly authenticated.',\n      });\n    }\n\n    // Check for timeout errors\n    const errorCode = isErrorWithCode(error) && typeof error.code === 'string' ? error.code : '';\n\n    if (errorCode === 'ETIMEDOUT' || errorMessage.includes('timeout')) {\n      return createTimeoutError({\n        message: isErrorWithMessage(error) && error.message ? error.message : 'Request timed out',\n        promptExcerpt: messagesPrompt.substring(0, 200),\n        // Don't specify timeoutMs since we don't know the actual timeout value\n        // It's controlled by the consumer via AbortSignal\n      });\n    }\n\n    // Create general API call error with appropriate retry flag\n    const isRetryable =\n      errorCode === 'ENOENT' ||\n      errorCode === 'ECONNREFUSED' ||\n      errorCode === 'ETIMEDOUT' ||\n      errorCode === 'ECONNRESET';\n\n    // Use error.stderr if available from SDK, otherwise use collected stderr\n    const stderrFromError =\n      isErrorWithCode(error) && typeof error.stderr === 'string' ? error.stderr : undefined;\n    const stderr = stderrFromError || collectedStderr || undefined;\n\n    return createAPICallError({\n      message: isErrorWithMessage(error) && error.message ? error.message : 'Claude Code SDK error',\n      code: errorCode || undefined,\n      exitCode: exitCode,\n      stderr,\n      promptExcerpt: messagesPrompt.substring(0, 200),\n      isRetryable,\n    });\n  }\n\n  private setSessionId(sessionId: string): void {\n    this.sessionId = sessionId;\n    const warning = validateSessionId(sessionId);\n    if (warning) {\n      this.logger.warn(`Claude Code Session: ${warning}`);\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV2['doGenerate']>[0]\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>> {\n    this.logger.debug(`[claude-code] Starting doGenerate request with model: ${this.modelId}`);\n    this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? 'none'}`);\n\n    const {\n      messagesPrompt,\n      warnings: messageWarnings,\n      streamingContentParts,\n      hasImageParts,\n    } = convertToClaudeCodeMessages(options.prompt);\n\n    this.logger.debug(\n      `[claude-code] Converted ${options.prompt.length} messages, hasImageParts: ${hasImageParts}`\n    );\n\n    const abortController = new AbortController();\n    let abortListener: (() => void) | undefined;\n    if (options.abortSignal?.aborted) {\n      // Propagate already-aborted state immediately with original reason\n      abortController.abort(options.abortSignal.reason);\n    } else if (options.abortSignal) {\n      abortListener = () => abortController.abort(options.abortSignal?.reason);\n      options.abortSignal.addEventListener('abort', abortListener, { once: true });\n    }\n\n    // Collect stderr for error reporting (SDK may not include it in errors)\n    let collectedStderr = '';\n    const stderrCollector = (data: string) => {\n      collectedStderr += data;\n    };\n\n    const sdkOptions = this.getSanitizedSdkOptions();\n    const effectiveResume = this.getEffectiveResume(sdkOptions);\n    const queryOptions = this.createQueryOptions(\n      abortController,\n      options.responseFormat,\n      stderrCollector,\n      sdkOptions,\n      effectiveResume\n    );\n\n    let text = '';\n    let structuredOutput: unknown | undefined;\n    let usage: LanguageModelV2Usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n    let finishReason: LanguageModelV2FinishReason = 'stop';\n    let wasTruncated = false;\n    let costUsd: number | undefined;\n    let durationMs: number | undefined;\n    let rawUsage: unknown | undefined;\n    const warnings: LanguageModelV2CallWarning[] = this.generateAllWarnings(\n      options,\n      messagesPrompt\n    );\n\n    // Add warnings from message conversion\n    if (messageWarnings) {\n      messageWarnings.forEach((warning) => {\n        warnings.push({\n          type: 'other',\n          message: warning,\n        });\n      });\n    }\n\n    const modeSetting = this.settings.streamingInput ?? 'auto';\n    const effectiveCanUseTool = sdkOptions?.canUseTool ?? this.settings.canUseTool;\n    const effectivePermissionPromptToolName =\n      sdkOptions?.permissionPromptToolName ?? this.settings.permissionPromptToolName;\n    const wantsStreamInput =\n      modeSetting === 'always' || (modeSetting === 'auto' && !!effectiveCanUseTool);\n\n    if (!wantsStreamInput && hasImageParts) {\n      warnings.push({\n        type: 'other',\n        message: STREAMING_FEATURE_WARNING,\n      });\n    }\n\n    let done = () => {};\n    const outputStreamEnded = new Promise((resolve) => {\n      done = () => resolve(undefined);\n    });\n    try {\n      if (effectiveCanUseTool && effectivePermissionPromptToolName) {\n        throw new Error(\n          \"canUseTool requires streamingInput mode ('auto' or 'always') and cannot be used with permissionPromptToolName (SDK constraint). Set streamingInput: 'auto' (or 'always') and remove permissionPromptToolName, or remove canUseTool.\"\n        );\n      }\n      // hold input stream open until results\n      // see: https://github.com/anthropics/claude-code/issues/4775\n      const sdkPrompt = wantsStreamInput\n        ? toAsyncIterablePrompt(\n            messagesPrompt,\n            outputStreamEnded,\n            effectiveResume,\n            streamingContentParts\n          )\n        : messagesPrompt;\n\n      this.logger.debug(\n        `[claude-code] Executing query with streamingInput: ${wantsStreamInput}, session: ${effectiveResume ?? 'new'}`\n      );\n\n      const response = query({\n        prompt: sdkPrompt,\n        options: queryOptions,\n      });\n\n      for await (const message of response) {\n        this.logger.debug(`[claude-code] Received message type: ${message.type}`);\n        if (message.type === 'assistant') {\n          text += message.message.content\n            .map((c: { type: string; text?: string }) => (c.type === 'text' ? c.text : ''))\n            .join('');\n        } else if (message.type === 'result') {\n          done();\n          this.setSessionId(message.session_id);\n          costUsd = message.total_cost_usd;\n          durationMs = message.duration_ms;\n\n          // Handle structured output errors (SDK 0.1.45+)\n          // Use string comparison to support new SDK subtypes not yet in TypeScript definitions\n          if ((message.subtype as string) === 'error_max_structured_output_retries') {\n            throw new Error(\n              'Failed to generate valid structured output after maximum retries. The model could not produce a response matching the required schema.'\n            );\n          }\n\n          // Capture structured output if available (SDK 0.1.45+)\n          if ('structured_output' in message && message.structured_output !== undefined) {\n            structuredOutput = message.structured_output;\n            this.logger.debug('[claude-code] Received structured output from SDK');\n          }\n\n          this.logger.info(\n            `[claude-code] Request completed - Session: ${message.session_id}, Cost: $${costUsd?.toFixed(4) ?? 'N/A'}, Duration: ${durationMs ?? 'N/A'}ms`\n          );\n\n          if ('usage' in message) {\n            rawUsage = message.usage;\n            usage = {\n              inputTokens:\n                (message.usage.cache_creation_input_tokens ?? 0) +\n                (message.usage.cache_read_input_tokens ?? 0) +\n                (message.usage.input_tokens ?? 0),\n              outputTokens: message.usage.output_tokens ?? 0,\n              totalTokens:\n                (message.usage.cache_creation_input_tokens ?? 0) +\n                (message.usage.cache_read_input_tokens ?? 0) +\n                (message.usage.input_tokens ?? 0) +\n                (message.usage.output_tokens ?? 0),\n            };\n\n            this.logger.debug(\n              `[claude-code] Token usage - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`\n            );\n          }\n\n          finishReason = mapClaudeCodeFinishReason(message.subtype);\n          this.logger.debug(`[claude-code] Finish reason: ${finishReason}`);\n        } else if (message.type === 'system' && message.subtype === 'init') {\n          this.setSessionId(message.session_id);\n          this.logger.info(`[claude-code] Session initialized: ${message.session_id}`);\n        }\n      }\n    } catch (error: unknown) {\n      done();\n      this.logger.debug(\n        `[claude-code] Error during doGenerate: ${error instanceof Error ? error.message : String(error)}`\n      );\n\n      // Special handling for AbortError to preserve abort signal reason\n      if (isAbortError(error)) {\n        this.logger.debug('[claude-code] Request aborted by user');\n        throw options.abortSignal?.aborted ? options.abortSignal.reason : error;\n      }\n\n      if (isClaudeCodeTruncationError(error, text)) {\n        this.logger.warn(\n          `[claude-code] Detected truncated response, returning ${text.length} characters of buffered text`\n        );\n        wasTruncated = true;\n        finishReason = 'length';\n        warnings.push({\n          type: 'other',\n          message: CLAUDE_CODE_TRUNCATION_WARNING,\n        });\n      } else {\n        // Use unified error handler\n        throw this.handleClaudeCodeError(error, messagesPrompt, collectedStderr);\n      }\n    } finally {\n      if (options.abortSignal && abortListener) {\n        options.abortSignal.removeEventListener('abort', abortListener);\n      }\n    }\n\n    // Use structured output from SDK if available (native JSON schema support)\n    // Otherwise fall back to accumulated text\n    const finalText = structuredOutput !== undefined ? JSON.stringify(structuredOutput) : text;\n\n    return {\n      content: [{ type: 'text', text: finalText }],\n      usage,\n      finishReason,\n      warnings,\n      response: {\n        id: generateId(),\n        timestamp: new Date(),\n        modelId: this.modelId,\n      },\n      request: {\n        body: messagesPrompt,\n      },\n      providerMetadata: {\n        'claude-code': {\n          ...(this.sessionId !== undefined && { sessionId: this.sessionId }),\n          ...(costUsd !== undefined && { costUsd }),\n          ...(durationMs !== undefined && { durationMs }),\n          ...(rawUsage !== undefined && { rawUsage: rawUsage as JSONValue }),\n          ...(wasTruncated && { truncated: true }),\n        },\n      },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV2['doStream']>[0]\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>> {\n    this.logger.debug(`[claude-code] Starting doStream request with model: ${this.modelId}`);\n    this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? 'none'}`);\n\n    const {\n      messagesPrompt,\n      warnings: messageWarnings,\n      streamingContentParts,\n      hasImageParts,\n    } = convertToClaudeCodeMessages(options.prompt);\n\n    this.logger.debug(\n      `[claude-code] Converted ${options.prompt.length} messages for streaming, hasImageParts: ${hasImageParts}`\n    );\n\n    const abortController = new AbortController();\n    let abortListener: (() => void) | undefined;\n    if (options.abortSignal?.aborted) {\n      // Propagate already-aborted state immediately with original reason\n      abortController.abort(options.abortSignal.reason);\n    } else if (options.abortSignal) {\n      abortListener = () => abortController.abort(options.abortSignal?.reason);\n      options.abortSignal.addEventListener('abort', abortListener, { once: true });\n    }\n\n    // Collect stderr for error reporting (SDK may not include it in errors)\n    let collectedStderr = '';\n    const stderrCollector = (data: string) => {\n      collectedStderr += data;\n    };\n\n    const sdkOptions = this.getSanitizedSdkOptions();\n    const effectiveResume = this.getEffectiveResume(sdkOptions);\n    const queryOptions = this.createQueryOptions(\n      abortController,\n      options.responseFormat,\n      stderrCollector,\n      sdkOptions,\n      effectiveResume\n    );\n\n    // Enable partial messages for true streaming (token-by-token delivery)\n    // This can be overridden by user settings, but we default to true for doStream\n    if (queryOptions.includePartialMessages === undefined) {\n      queryOptions.includePartialMessages = true;\n    }\n\n    const warnings: LanguageModelV2CallWarning[] = this.generateAllWarnings(\n      options,\n      messagesPrompt\n    );\n\n    // Add warnings from message conversion\n    if (messageWarnings) {\n      messageWarnings.forEach((warning) => {\n        warnings.push({\n          type: 'other',\n          message: warning,\n        });\n      });\n    }\n\n    const modeSetting = this.settings.streamingInput ?? 'auto';\n    const effectiveCanUseTool = sdkOptions?.canUseTool ?? this.settings.canUseTool;\n    const effectivePermissionPromptToolName =\n      sdkOptions?.permissionPromptToolName ?? this.settings.permissionPromptToolName;\n    const wantsStreamInput =\n      modeSetting === 'always' || (modeSetting === 'auto' && !!effectiveCanUseTool);\n\n    if (!wantsStreamInput && hasImageParts) {\n      warnings.push({\n        type: 'other',\n        message: STREAMING_FEATURE_WARNING,\n      });\n    }\n\n    const stream = new ReadableStream<ExtendedStreamPart>({\n      start: async (controller) => {\n        let done = () => {};\n        const outputStreamEnded = new Promise((resolve) => {\n          done = () => resolve(undefined);\n        });\n        const toolStates = new Map<string, ToolStreamState>();\n        const streamWarnings: LanguageModelV2CallWarning[] = [];\n\n        const closeToolInput = (toolId: string, state: ToolStreamState) => {\n          if (!state.inputClosed && state.inputStarted) {\n            controller.enqueue({\n              type: 'tool-input-end',\n              id: toolId,\n            });\n            state.inputClosed = true;\n          }\n        };\n\n        const emitToolCall = (toolId: string, state: ToolStreamState) => {\n          if (state.callEmitted) {\n            return;\n          }\n\n          closeToolInput(toolId, state);\n\n          controller.enqueue({\n            type: 'tool-call',\n            toolCallId: toolId,\n            toolName: state.name,\n            input: state.lastSerializedInput ?? '',\n            providerExecuted: true,\n            dynamic: true, // V3 field: indicates tool is provider-defined (not in user's tools map)\n            providerMetadata: {\n              'claude-code': {\n                // rawInput preserves the original serialized format before AI SDK normalization.\n                // Use this if you need the exact string sent to the Claude CLI, which may differ\n                // from the `input` field after AI SDK processing.\n                rawInput: state.lastSerializedInput ?? '',\n              },\n            },\n          } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n          state.callEmitted = true;\n        };\n\n        const finalizeToolCalls = () => {\n          for (const [toolId, state] of toolStates) {\n            emitToolCall(toolId, state);\n          }\n          toolStates.clear();\n        };\n\n        let usage: LanguageModelV2Usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n        let accumulatedText = '';\n        let textPartId: string | undefined;\n        let streamedTextLength = 0; // Track text already emitted via stream_events to avoid duplication\n        let hasReceivedStreamEvents = false; // Track if we've received any stream_events\n\n        try {\n          // Emit stream-start with warnings\n          controller.enqueue({ type: 'stream-start', warnings });\n\n          if (effectiveCanUseTool && effectivePermissionPromptToolName) {\n            throw new Error(\n              \"canUseTool requires streamingInput mode ('auto' or 'always') and cannot be used with permissionPromptToolName (SDK constraint). Set streamingInput: 'auto' (or 'always') and remove permissionPromptToolName, or remove canUseTool.\"\n            );\n          }\n          // hold input stream open until results\n          // see: https://github.com/anthropics/claude-code/issues/4775\n          const sdkPrompt = wantsStreamInput\n            ? toAsyncIterablePrompt(\n                messagesPrompt,\n                outputStreamEnded,\n                effectiveResume,\n                streamingContentParts\n              )\n            : messagesPrompt;\n\n          this.logger.debug(\n            `[claude-code] Starting stream query with streamingInput: ${wantsStreamInput}, session: ${effectiveResume ?? 'new'}`\n          );\n\n          const response = query({\n            prompt: sdkPrompt,\n            options: queryOptions,\n          });\n\n          for await (const message of response) {\n            this.logger.debug(`[claude-code] Stream received message type: ${message.type}`);\n\n            // Handle streaming events (token-by-token delivery via includePartialMessages)\n            if (message.type === 'stream_event') {\n              const streamEvent = message as SDKPartialAssistantMessage;\n              const event = streamEvent.event;\n\n              // Check for text_delta events within content_block_delta\n              if (\n                event.type === 'content_block_delta' &&\n                event.delta.type === 'text_delta' &&\n                'text' in event.delta &&\n                event.delta.text\n              ) {\n                const deltaText = event.delta.text;\n                hasReceivedStreamEvents = true;\n\n                // Don't emit text deltas in JSON mode - accumulate instead\n                if (options.responseFormat?.type === 'json') {\n                  accumulatedText += deltaText;\n                  streamedTextLength += deltaText.length;\n                  continue;\n                }\n\n                // Emit text-start if this is the first text\n                if (!textPartId) {\n                  textPartId = generateId();\n                  controller.enqueue({\n                    type: 'text-start',\n                    id: textPartId,\n                  });\n                }\n\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: textPartId,\n                  delta: deltaText,\n                });\n                accumulatedText += deltaText;\n                streamedTextLength += deltaText.length;\n              }\n              // Handle input_json_delta events for structured output streaming\n              // The SDK uses a StructuredOutput tool internally, and JSON is streamed via input_json_delta\n              if (\n                event.type === 'content_block_delta' &&\n                event.delta.type === 'input_json_delta' &&\n                'partial_json' in event.delta &&\n                event.delta.partial_json\n              ) {\n                const jsonDelta = event.delta.partial_json;\n                hasReceivedStreamEvents = true;\n\n                // Only emit in JSON mode - this enables streamObject() to receive partial updates\n                if (options.responseFormat?.type === 'json') {\n                  // Emit text-start if this is the first JSON delta\n                  if (!textPartId) {\n                    textPartId = generateId();\n                    controller.enqueue({\n                      type: 'text-start',\n                      id: textPartId,\n                    });\n                  }\n\n                  controller.enqueue({\n                    type: 'text-delta',\n                    id: textPartId,\n                    delta: jsonDelta,\n                  });\n                  accumulatedText += jsonDelta;\n                  streamedTextLength += jsonDelta.length;\n                }\n                // In non-JSON mode, input_json_delta is ignored (it's internal tool use)\n              }\n\n              // Other stream_event types (content_block_start, content_block_stop, etc.)\n              // are informational and don't need to be forwarded to the AI SDK stream\n              continue;\n            }\n\n            if (message.type === 'assistant') {\n              if (!message.message?.content) {\n                this.logger.warn(\n                  `[claude-code] Unexpected assistant message structure: missing content field. Message type: ${message.type}. This may indicate an SDK protocol violation.`\n                );\n                continue;\n              }\n\n              const content = message.message.content;\n\n              for (const tool of this.extractToolUses(content)) {\n                const toolId = tool.id;\n                let state = toolStates.get(toolId);\n                if (!state) {\n                  state = {\n                    name: tool.name,\n                    inputStarted: false,\n                    inputClosed: false,\n                    callEmitted: false,\n                  };\n                  toolStates.set(toolId, state);\n                  this.logger.debug(\n                    `[claude-code] New tool use detected - Tool: ${tool.name}, ID: ${toolId}`\n                  );\n                }\n\n                state.name = tool.name;\n\n                if (!state.inputStarted) {\n                  this.logger.debug(\n                    `[claude-code] Tool input started - Tool: ${tool.name}, ID: ${toolId}`\n                  );\n                  controller.enqueue({\n                    type: 'tool-input-start',\n                    id: toolId,\n                    toolName: tool.name,\n                    providerExecuted: true,\n                    dynamic: true, // V3 field: indicates tool is provider-defined\n                  } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n                  state.inputStarted = true;\n                }\n\n                const serializedInput = this.serializeToolInput(tool.input);\n                if (serializedInput) {\n                  let deltaPayload = '';\n\n                  // First input: emit full delta only if small enough\n                  if (state.lastSerializedInput === undefined) {\n                    if (serializedInput.length <= ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE) {\n                      deltaPayload = serializedInput;\n                    }\n                  } else if (\n                    serializedInput.length <= ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE &&\n                    state.lastSerializedInput.length <=\n                      ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE &&\n                    serializedInput.startsWith(state.lastSerializedInput)\n                  ) {\n                    deltaPayload = serializedInput.slice(state.lastSerializedInput.length);\n                  } else if (serializedInput !== state.lastSerializedInput) {\n                    // Non-prefix updates or large inputs - defer to the final tool-call payload\n                    deltaPayload = '';\n                  }\n\n                  if (deltaPayload) {\n                    controller.enqueue({\n                      type: 'tool-input-delta',\n                      id: toolId,\n                      delta: deltaPayload,\n                    });\n                  }\n                  state.lastSerializedInput = serializedInput;\n                }\n              }\n\n              const text = content\n                .map((c: { type: string; text?: string }) => (c.type === 'text' ? c.text : ''))\n                .join('');\n\n              if (text) {\n                // When we've received stream_events, assistant messages contain cumulative text\n                // that we've already emitted via stream_event deltas - skip duplicates\n                // When no stream_events received, assistant messages contain incremental text\n                if (hasReceivedStreamEvents) {\n                  // Calculate delta: only emit text that wasn't already streamed via stream_events\n                  const newTextStart = streamedTextLength;\n                  const deltaText = text.length > newTextStart ? text.slice(newTextStart) : '';\n\n                  // Always accumulate for final result tracking\n                  accumulatedText = text; // Replace with full text (assistant msg contains full content)\n\n                  // In JSON mode, we accumulate the text and extract JSON at the end\n                  // Otherwise, stream any new text\n                  if (options.responseFormat?.type !== 'json' && deltaText) {\n                    // Emit text-start if this is the first text\n                    if (!textPartId) {\n                      textPartId = generateId();\n                      controller.enqueue({\n                        type: 'text-start',\n                        id: textPartId,\n                      });\n                    }\n\n                    controller.enqueue({\n                      type: 'text-delta',\n                      id: textPartId,\n                      delta: deltaText,\n                    });\n                  }\n\n                  // Update streamedTextLength to match what we now know is the full text\n                  streamedTextLength = text.length;\n                } else {\n                  // No stream_events - assistant messages contain incremental text chunks\n                  accumulatedText += text;\n\n                  // In JSON mode, we accumulate the text and extract JSON at the end\n                  // Otherwise, stream the text as it comes\n                  if (options.responseFormat?.type !== 'json') {\n                    // Emit text-start if this is the first text\n                    if (!textPartId) {\n                      textPartId = generateId();\n                      controller.enqueue({\n                        type: 'text-start',\n                        id: textPartId,\n                      });\n                    }\n\n                    controller.enqueue({\n                      type: 'text-delta',\n                      id: textPartId,\n                      delta: text,\n                    });\n                  }\n                }\n              }\n            } else if (message.type === 'user') {\n              if (!message.message?.content) {\n                this.logger.warn(\n                  `[claude-code] Unexpected user message structure: missing content field. Message type: ${message.type}. This may indicate an SDK protocol violation.`\n                );\n                continue;\n              }\n              const content = message.message.content;\n              for (const result of this.extractToolResults(content)) {\n                let state = toolStates.get(result.id);\n                const toolName =\n                  result.name ?? state?.name ?? ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;\n\n                this.logger.debug(\n                  `[claude-code] Tool result received - Tool: ${toolName}, ID: ${result.id}`\n                );\n\n                if (!state) {\n                  this.logger.warn(\n                    `[claude-code] Received tool result for unknown tool ID: ${result.id}`\n                  );\n                  state = {\n                    name: toolName,\n                    inputStarted: false,\n                    inputClosed: false,\n                    callEmitted: false,\n                  };\n                  toolStates.set(result.id, state);\n                  // Synthesize input lifecycle to preserve ordering when no prior tool_use was seen\n                  if (!state.inputStarted) {\n                    controller.enqueue({\n                      type: 'tool-input-start',\n                      id: result.id,\n                      toolName,\n                      providerExecuted: true,\n                      dynamic: true, // V3 field: indicates tool is provider-defined\n                    } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n                    state.inputStarted = true;\n                  }\n                  if (!state.inputClosed) {\n                    controller.enqueue({\n                      type: 'tool-input-end',\n                      id: result.id,\n                    });\n                    state.inputClosed = true;\n                  }\n                }\n                state.name = toolName;\n                const normalizedResult = this.normalizeToolResult(result.result);\n                const rawResult =\n                  typeof result.result === 'string'\n                    ? result.result\n                    : (() => {\n                        try {\n                          return JSON.stringify(result.result);\n                        } catch {\n                          return String(result.result);\n                        }\n                      })();\n\n                emitToolCall(result.id, state);\n\n                controller.enqueue({\n                  type: 'tool-result',\n                  toolCallId: result.id,\n                  toolName,\n                  result: normalizedResult,\n                  isError: result.isError,\n                  providerExecuted: true,\n                  dynamic: true, // V3 field: indicates tool is provider-defined\n                  providerMetadata: {\n                    'claude-code': {\n                      // rawResult preserves the original CLI output string before JSON parsing.\n                      // Use this when you need the exact string returned by the tool, especially\n                      // if the `result` field has been parsed/normalized and you need the original format.\n                      rawResult,\n                    },\n                  },\n                } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n              }\n              // Handle tool errors\n              for (const error of this.extractToolErrors(content)) {\n                let state = toolStates.get(error.id);\n                const toolName =\n                  error.name ?? state?.name ?? ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;\n\n                this.logger.debug(\n                  `[claude-code] Tool error received - Tool: ${toolName}, ID: ${error.id}`\n                );\n\n                if (!state) {\n                  this.logger.warn(\n                    `[claude-code] Received tool error for unknown tool ID: ${error.id}`\n                  );\n                  state = {\n                    name: toolName,\n                    inputStarted: true,\n                    inputClosed: true,\n                    callEmitted: false,\n                  };\n                  toolStates.set(error.id, state);\n                }\n\n                // Ensure tool-call is emitted before tool-error\n                emitToolCall(error.id, state);\n\n                const rawError =\n                  typeof error.error === 'string'\n                    ? error.error\n                    : typeof error.error === 'object' && error.error !== null\n                      ? (() => {\n                          try {\n                            return JSON.stringify(error.error);\n                          } catch {\n                            return String(error.error);\n                          }\n                        })()\n                      : String(error.error);\n\n                controller.enqueue({\n                  type: 'tool-error',\n                  toolCallId: error.id,\n                  toolName,\n                  error: rawError,\n                  providerExecuted: true,\n                  dynamic: true, // V3 field: indicates tool is provider-defined\n                  providerMetadata: {\n                    'claude-code': {\n                      rawError,\n                    },\n                  },\n                } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n              }\n            } else if (message.type === 'result') {\n              done();\n\n              // Handle structured output errors (SDK 0.1.45+)\n              // Use string comparison to support new SDK subtypes not yet in TypeScript definitions\n              if ((message.subtype as string) === 'error_max_structured_output_retries') {\n                throw new Error(\n                  'Failed to generate valid structured output after maximum retries. The model could not produce a response matching the required schema.'\n                );\n              }\n\n              this.logger.info(\n                `[claude-code] Stream completed - Session: ${message.session_id}, Cost: $${message.total_cost_usd?.toFixed(4) ?? 'N/A'}, Duration: ${message.duration_ms ?? 'N/A'}ms`\n              );\n\n              let rawUsage: unknown | undefined;\n              if ('usage' in message) {\n                rawUsage = message.usage;\n                usage = {\n                  inputTokens:\n                    (message.usage.cache_creation_input_tokens ?? 0) +\n                    (message.usage.cache_read_input_tokens ?? 0) +\n                    (message.usage.input_tokens ?? 0),\n                  outputTokens: message.usage.output_tokens ?? 0,\n                  totalTokens:\n                    (message.usage.cache_creation_input_tokens ?? 0) +\n                    (message.usage.cache_read_input_tokens ?? 0) +\n                    (message.usage.input_tokens ?? 0) +\n                    (message.usage.output_tokens ?? 0),\n                };\n\n                this.logger.debug(\n                  `[claude-code] Stream token usage - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`\n                );\n              }\n\n              const finishReason: LanguageModelV2FinishReason = mapClaudeCodeFinishReason(\n                message.subtype\n              );\n\n              this.logger.debug(`[claude-code] Stream finish reason: ${finishReason}`);\n\n              // Store session ID in the model instance\n              this.setSessionId(message.session_id);\n\n              // Use structured output from SDK if available (native JSON schema support)\n              const structuredOutput =\n                'structured_output' in message ? message.structured_output : undefined;\n\n              // Check if we've already streamed JSON via input_json_delta\n              const alreadyStreamedJson =\n                textPartId && options.responseFormat?.type === 'json' && hasReceivedStreamEvents;\n\n              if (alreadyStreamedJson && textPartId) {\n                // We've already streamed JSON deltas, just close the text part\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n              } else if (structuredOutput !== undefined) {\n                // Emit structured output as text (fallback when streaming didn't occur)\n                const jsonTextId = generateId();\n                const jsonText = JSON.stringify(structuredOutput);\n                controller.enqueue({\n                  type: 'text-start',\n                  id: jsonTextId,\n                });\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: jsonTextId,\n                  delta: jsonText,\n                });\n                controller.enqueue({\n                  type: 'text-end',\n                  id: jsonTextId,\n                });\n              } else if (textPartId) {\n                // Close the text part if it was opened (non-JSON mode)\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n              } else if (accumulatedText) {\n                // Fallback for JSON mode without schema: emit accumulated text\n                // This handles the case where responseFormat.type === 'json' but no schema\n                // was provided, so the SDK returns plain text instead of structured_output\n                const fallbackTextId = generateId();\n                controller.enqueue({\n                  type: 'text-start',\n                  id: fallbackTextId,\n                });\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: fallbackTextId,\n                  delta: accumulatedText,\n                });\n                controller.enqueue({\n                  type: 'text-end',\n                  id: fallbackTextId,\n                });\n              }\n\n              finalizeToolCalls();\n\n              // Prepare JSON-safe warnings for provider metadata\n              const warningsJson = this.serializeWarningsForMetadata(streamWarnings);\n\n              controller.enqueue({\n                type: 'finish',\n                finishReason,\n                usage,\n                providerMetadata: {\n                  'claude-code': {\n                    sessionId: message.session_id,\n                    ...(message.total_cost_usd !== undefined && {\n                      costUsd: message.total_cost_usd,\n                    }),\n                    ...(message.duration_ms !== undefined && { durationMs: message.duration_ms }),\n                    ...(rawUsage !== undefined && { rawUsage: rawUsage as JSONValue }),\n                    // JSON validation warnings are collected during streaming and included\n                    // in providerMetadata since the AI SDK's finish event doesn't support\n                    // a top-level warnings field (unlike stream-start which was already emitted)\n                    ...(streamWarnings.length > 0 && {\n                      warnings: warningsJson as unknown as JSONValue,\n                    }),\n                  },\n                },\n              });\n            } else if (message.type === 'system' && message.subtype === 'init') {\n              // Store session ID for future use\n              this.setSessionId(message.session_id);\n\n              this.logger.info(`[claude-code] Stream session initialized: ${message.session_id}`);\n\n              // Emit response metadata when session is initialized\n              controller.enqueue({\n                type: 'response-metadata',\n                id: message.session_id,\n                timestamp: new Date(),\n                modelId: this.modelId,\n              });\n            }\n          }\n\n          finalizeToolCalls();\n          this.logger.debug('[claude-code] Stream finalized, closing stream');\n          controller.close();\n        } catch (error: unknown) {\n          done();\n\n          this.logger.debug(\n            `[claude-code] Error during doStream: ${error instanceof Error ? error.message : String(error)}`\n          );\n\n          if (isClaudeCodeTruncationError(error, accumulatedText)) {\n            this.logger.warn(\n              `[claude-code] Detected truncated stream response, returning ${accumulatedText.length} characters of buffered text`\n            );\n            const truncationWarning: LanguageModelV2CallWarning = {\n              type: 'other',\n              message: CLAUDE_CODE_TRUNCATION_WARNING,\n            };\n            streamWarnings.push(truncationWarning);\n\n            if (textPartId) {\n              controller.enqueue({\n                type: 'text-end',\n                id: textPartId,\n              });\n            } else if (accumulatedText) {\n              const fallbackTextId = generateId();\n              controller.enqueue({\n                type: 'text-start',\n                id: fallbackTextId,\n              });\n              controller.enqueue({\n                type: 'text-delta',\n                id: fallbackTextId,\n                delta: accumulatedText,\n              });\n              controller.enqueue({\n                type: 'text-end',\n                id: fallbackTextId,\n              });\n            }\n\n            finalizeToolCalls();\n\n            const warningsJson = this.serializeWarningsForMetadata(streamWarnings);\n\n            controller.enqueue({\n              type: 'finish',\n              finishReason: 'length',\n              usage,\n              providerMetadata: {\n                'claude-code': {\n                  ...(this.sessionId !== undefined && { sessionId: this.sessionId }),\n                  truncated: true,\n                  ...(streamWarnings.length > 0 && {\n                    warnings: warningsJson as unknown as JSONValue,\n                  }),\n                },\n              },\n            });\n\n            controller.close();\n            return;\n          }\n\n          finalizeToolCalls();\n          let errorToEmit: unknown;\n\n          // Special handling for AbortError to preserve abort signal reason\n          if (isAbortError(error)) {\n            errorToEmit = options.abortSignal?.aborted ? options.abortSignal.reason : error;\n          } else {\n            // Use unified error handler\n            errorToEmit = this.handleClaudeCodeError(error, messagesPrompt, collectedStderr);\n          }\n\n          // Emit error as a stream part\n          controller.enqueue({\n            type: 'error',\n            error: errorToEmit,\n          });\n\n          controller.close();\n        } finally {\n          if (options.abortSignal && abortListener) {\n            options.abortSignal.removeEventListener('abort', abortListener);\n          }\n        }\n      },\n      cancel: () => {\n        if (options.abortSignal && abortListener) {\n          options.abortSignal.removeEventListener('abort', abortListener);\n        }\n      },\n    });\n\n    return {\n      stream: stream as unknown as ReadableStream<LanguageModelV2StreamPart>,\n      request: {\n        body: messagesPrompt,\n      },\n    };\n  }\n\n  private serializeWarningsForMetadata(warnings: LanguageModelV2CallWarning[]): JSONValue {\n    const result = warnings.map((w) => {\n      const base: Record<string, string> = { type: w.type };\n      if ('message' in w) {\n        const m = (w as { message?: unknown }).message;\n        if (m !== undefined) base.message = String(m);\n      }\n      if (w.type === 'unsupported-setting') {\n        const setting = (w as { setting: unknown }).setting;\n        if (setting !== undefined) base.setting = String(setting);\n        if ('details' in w) {\n          const d = (w as { details?: unknown }).details;\n          if (d !== undefined) base.details = String(d);\n        }\n      }\n      return base;\n    });\n    return result as unknown as JSONValue;\n  }\n}\n","import type { ModelMessage } from 'ai';\nimport type { SDKUserMessage } from '@anthropic-ai/claude-agent-sdk';\n\ntype SDKUserContentPart = SDKUserMessage['message']['content'][number];\n\ninterface StreamingSegment {\n  formatted: string;\n}\n\nconst IMAGE_URL_WARNING = 'Image URLs are not supported by this provider; supply base64/data URLs.';\nconst IMAGE_CONVERSION_WARNING = 'Unable to convert image content; supply base64/data URLs.';\n\nfunction normalizeBase64(base64: string): string {\n  return base64.replace(/\\s+/g, '');\n}\n\nfunction isImageMimeType(mimeType?: string): boolean {\n  return typeof mimeType === 'string' && mimeType.trim().toLowerCase().startsWith('image/');\n}\n\nfunction createImageContent(mediaType: string, data: string): SDKUserContentPart | undefined {\n  const trimmedType = mediaType.trim();\n  const trimmedData = normalizeBase64(data.trim());\n\n  if (!trimmedType || !trimmedData) {\n    return undefined;\n  }\n\n  return {\n    type: 'image',\n    source: {\n      type: 'base64',\n      media_type: trimmedType,\n      data: trimmedData,\n    },\n  } as SDKUserContentPart;\n}\n\nfunction extractMimeType(candidate: unknown): string | undefined {\n  if (typeof candidate === 'string' && candidate.trim()) {\n    return candidate.trim();\n  }\n  return undefined;\n}\n\nfunction parseObjectImage(\n  imageObj: Record<string, unknown>,\n  fallbackMimeType?: string\n): SDKUserContentPart | undefined {\n  const data = typeof imageObj.data === 'string' ? imageObj.data : undefined;\n  const mimeType = extractMimeType(\n    imageObj.mimeType ?? imageObj.mediaType ?? imageObj.media_type ?? fallbackMimeType\n  );\n  if (!data || !mimeType) {\n    return undefined;\n  }\n  return createImageContent(mimeType, data);\n}\n\nfunction parseStringImage(\n  value: string,\n  fallbackMimeType?: string\n): { content?: SDKUserContentPart; warning?: string } {\n  const trimmed = value.trim();\n\n  if (/^https?:\\/\\//i.test(trimmed)) {\n    return { warning: IMAGE_URL_WARNING };\n  }\n\n  const dataUrlMatch = trimmed.match(/^data:([^;]+);base64,(.+)$/i);\n  if (dataUrlMatch) {\n    const [, mediaType, data] = dataUrlMatch;\n    const content = createImageContent(mediaType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  const base64Match = trimmed.match(/^base64:([^,]+),(.+)$/i);\n  if (base64Match) {\n    const [, explicitMimeType, data] = base64Match;\n    const content = createImageContent(explicitMimeType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  if (fallbackMimeType) {\n    const content = createImageContent(fallbackMimeType, trimmed);\n    if (content) {\n      return { content };\n    }\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\nfunction parseImagePart(part: unknown): { content?: SDKUserContentPart; warning?: string } {\n  if (!part || typeof part !== 'object') {\n    return { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  const imageValue = (part as { image?: unknown }).image;\n  const mimeType = extractMimeType((part as { mimeType?: unknown }).mimeType);\n\n  if (typeof imageValue === 'string') {\n    return parseStringImage(imageValue, mimeType);\n  }\n\n  if (imageValue && typeof imageValue === 'object') {\n    const content = parseObjectImage(imageValue as Record<string, unknown>, mimeType);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\nfunction convertBinaryToBase64(data: Uint8Array | ArrayBuffer): string | undefined {\n  if (typeof Buffer !== 'undefined') {\n    const buffer =\n      data instanceof Uint8Array ? Buffer.from(data) : Buffer.from(new Uint8Array(data));\n    return buffer.toString('base64');\n  }\n\n  if (typeof btoa === 'function') {\n    const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n    let binary = '';\n    const chunkSize = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunkSize) {\n      const chunk = bytes.subarray(i, i + chunkSize);\n      binary += String.fromCharCode(...chunk);\n    }\n    return btoa(binary);\n  }\n\n  return undefined;\n}\n\ntype FileLikePart = {\n  mediaType?: unknown;\n  mimeType?: unknown;\n  data?: unknown;\n};\n\nfunction parseFilePart(part: FileLikePart): { content?: SDKUserContentPart; warning?: string } {\n  const mimeType = extractMimeType(part.mediaType ?? part.mimeType);\n  if (!mimeType || !isImageMimeType(mimeType)) {\n    return {};\n  }\n\n  const data = part.data;\n  if (typeof data === 'string') {\n    const content = createImageContent(mimeType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  if (\n    data instanceof Uint8Array ||\n    (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer)\n  ) {\n    const base64 = convertBinaryToBase64(data);\n    if (!base64) {\n      return { warning: IMAGE_CONVERSION_WARNING };\n    }\n    const content = createImageContent(mimeType, base64);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\n/**\n * Converts AI SDK prompt format to Claude Code SDK message format.\n * Handles system prompts, user messages, assistant responses, and tool interactions.\n *\n * @param prompt - The AI SDK prompt containing messages\n * @returns An object containing the formatted message prompt and optional system prompt\n *\n * @example\n * ```typescript\n * const { messagesPrompt } = convertToClaudeCodeMessages(\n *   [{ role: 'user', content: 'Hello!' }]\n * );\n * ```\n *\n * @remarks\n * - Image parts are collected for streaming input; unsupported variants produce warnings\n * - Tool calls are simplified to \"[Tool calls made]\" notation\n * - JSON schema enforcement is handled natively by the SDK's outputFormat option (v0.1.45+)\n */\nexport function convertToClaudeCodeMessages(prompt: readonly ModelMessage[]): {\n  messagesPrompt: string;\n  systemPrompt?: string;\n  warnings?: string[];\n  streamingContentParts: SDKUserMessage['message']['content'];\n  hasImageParts: boolean;\n} {\n  const messages: string[] = [];\n  const warnings: string[] = [];\n  let systemPrompt: string | undefined;\n  const streamingSegments: StreamingSegment[] = [];\n  const imageMap = new Map<number, SDKUserContentPart[]>();\n  let hasImageParts = false;\n\n  const addSegment = (formatted: string): number => {\n    streamingSegments.push({ formatted });\n    return streamingSegments.length - 1;\n  };\n\n  const addImageForSegment = (segmentIndex: number, content: SDKUserContentPart): void => {\n    hasImageParts = true;\n    if (!imageMap.has(segmentIndex)) {\n      imageMap.set(segmentIndex, []);\n    }\n    imageMap.get(segmentIndex)?.push(content);\n  };\n\n  for (const message of prompt) {\n    switch (message.role) {\n      case 'system':\n        systemPrompt = message.content;\n        if (typeof message.content === 'string' && message.content.trim().length > 0) {\n          addSegment(message.content);\n        } else {\n          addSegment('');\n        }\n        break;\n\n      case 'user':\n        if (typeof message.content === 'string') {\n          messages.push(message.content);\n          addSegment(`Human: ${message.content}`);\n        } else {\n          // Handle multi-part content\n          const textParts = message.content\n            .filter((part) => part.type === 'text')\n            .map((part) => part.text)\n            .join('\\n');\n\n          const segmentIndex = addSegment(textParts ? `Human: ${textParts}` : '');\n\n          if (textParts) {\n            messages.push(textParts);\n          }\n\n          for (const part of message.content) {\n            if (part.type === 'image') {\n              const { content, warning } = parseImagePart(part);\n              if (content) {\n                addImageForSegment(segmentIndex, content);\n              } else if (warning) {\n                warnings.push(warning);\n              }\n            } else if (part.type === 'file') {\n              const { content, warning } = parseFilePart(part);\n              if (content) {\n                addImageForSegment(segmentIndex, content);\n              } else if (warning) {\n                warnings.push(warning);\n              }\n            }\n          }\n        }\n        break;\n\n      case 'assistant': {\n        let assistantContent = '';\n        if (typeof message.content === 'string') {\n          assistantContent = message.content;\n        } else {\n          const textParts = message.content\n            .filter((part) => part.type === 'text')\n            .map((part) => part.text)\n            .join('\\n');\n\n          if (textParts) {\n            assistantContent = textParts;\n          }\n\n          // Handle tool calls if present\n          const toolCalls = message.content.filter((part) => part.type === 'tool-call');\n          if (toolCalls.length > 0) {\n            // For now, we'll just note that tool calls were made\n            assistantContent += `\\n[Tool calls made]`;\n          }\n        }\n        const formattedAssistant = `Assistant: ${assistantContent}`;\n        messages.push(formattedAssistant);\n        addSegment(formattedAssistant);\n        break;\n      }\n\n      case 'tool':\n        // Tool results could be included in the conversation\n        for (const tool of message.content) {\n          const resultText =\n            tool.output.type === 'text' ? tool.output.value : JSON.stringify(tool.output.value);\n          const formattedToolResult = `Tool Result (${tool.toolName}): ${resultText}`;\n          messages.push(formattedToolResult);\n          addSegment(formattedToolResult);\n        }\n        break;\n    }\n  }\n\n  // For the SDK, we need to provide a single prompt string\n  // Format the conversation history properly\n\n  // Combine system prompt with messages\n  let finalPrompt = '';\n\n  // Add system prompt at the beginning if present\n  if (systemPrompt) {\n    finalPrompt = systemPrompt;\n  }\n\n  if (messages.length > 0) {\n    // Format messages\n    const formattedMessages = [];\n    for (let i = 0; i < messages.length; i++) {\n      const msg = messages[i];\n      // Check if this is a user or assistant message based on content\n      if (msg.startsWith('Assistant:') || msg.startsWith('Tool Result')) {\n        formattedMessages.push(msg);\n      } else {\n        // User messages\n        formattedMessages.push(`Human: ${msg}`);\n      }\n    }\n\n    // Combine system prompt with messages\n    if (finalPrompt) {\n      const joinedMessages = formattedMessages.join('\\n\\n');\n      finalPrompt = joinedMessages ? `${finalPrompt}\\n\\n${joinedMessages}` : finalPrompt;\n    } else {\n      finalPrompt = formattedMessages.join('\\n\\n');\n    }\n  }\n\n  // Build streaming parts including text and images\n  const streamingParts: SDKUserContentPart[] = [];\n  const imagePartsInOrder: SDKUserContentPart[] = [];\n\n  const appendImagesForIndex = (index: number) => {\n    const images = imageMap.get(index);\n    if (!images) {\n      return;\n    }\n    images.forEach((image) => {\n      streamingParts.push(image);\n      imagePartsInOrder.push(image);\n    });\n  };\n\n  if (streamingSegments.length > 0) {\n    let accumulatedText = '';\n    let emittedText = false;\n\n    const flushText = () => {\n      if (!accumulatedText) {\n        return;\n      }\n      streamingParts.push({ type: 'text', text: accumulatedText });\n      accumulatedText = '';\n      emittedText = true;\n    };\n\n    streamingSegments.forEach((segment, index) => {\n      const segmentText = segment.formatted;\n      if (segmentText) {\n        if (!accumulatedText) {\n          accumulatedText = emittedText ? `\\n\\n${segmentText}` : segmentText;\n        } else {\n          accumulatedText += `\\n\\n${segmentText}`;\n        }\n      }\n\n      if (imageMap.has(index)) {\n        flushText();\n        appendImagesForIndex(index);\n      }\n    });\n\n    flushText();\n  }\n\n  // Note: JSON schema enforcement is now handled natively by the SDK's outputFormat option (v0.1.45+)\n  // No prompt injection needed - structured outputs are guaranteed by the SDK\n\n  return {\n    messagesPrompt: finalPrompt,\n    systemPrompt,\n    ...(warnings.length > 0 && { warnings }),\n    streamingContentParts:\n      streamingParts.length > 0\n        ? (streamingParts as SDKUserMessage['message']['content'])\n        : ([\n            { type: 'text', text: finalPrompt },\n            ...imagePartsInOrder,\n          ] as SDKUserMessage['message']['content']),\n    hasImageParts,\n  };\n}\n","import { APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\n\n/**\n * Metadata associated with Claude Code SDK errors.\n * Provides additional context about command execution failures.\n */\nexport interface ClaudeCodeErrorMetadata {\n  /**\n   * Error code from the CLI process (e.g., 'ENOENT', 'ETIMEDOUT').\n   */\n  code?: string;\n\n  /**\n   * Exit code from the Claude Code SDK process.\n   * Common codes:\n   * - 401: Authentication error\n   * - 1: General error\n   */\n  exitCode?: number;\n\n  /**\n   * Standard error output from the CLI process.\n   */\n  stderr?: string;\n\n  /**\n   * Excerpt from the prompt that caused the error.\n   * Limited to first 200 characters for debugging.\n   */\n  promptExcerpt?: string;\n}\n\n/**\n * Creates an APICallError with Claude Code specific metadata.\n * Used for general CLI execution errors.\n *\n * @param options - Error details and metadata\n * @param options.message - Human-readable error message\n * @param options.code - Error code from the CLI process\n * @param options.exitCode - Exit code from the CLI\n * @param options.stderr - Standard error output\n * @param options.promptExcerpt - Excerpt of the prompt that caused the error\n * @param options.isRetryable - Whether the error is potentially retryable\n * @returns An APICallError instance with Claude Code metadata\n *\n * @example\n * ```typescript\n * throw createAPICallError({\n *   message: 'Claude Code SDK failed',\n *   code: 'ENOENT',\n *   isRetryable: true\n * });\n * ```\n */\nexport function createAPICallError({\n  message,\n  code,\n  exitCode,\n  stderr,\n  promptExcerpt,\n  isRetryable = false,\n}: ClaudeCodeErrorMetadata & {\n  message: string;\n  isRetryable?: boolean;\n}): APICallError {\n  const metadata: ClaudeCodeErrorMetadata = {\n    code,\n    exitCode,\n    stderr,\n    promptExcerpt,\n  };\n\n  return new APICallError({\n    message,\n    isRetryable,\n    url: 'claude-code-cli://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : undefined,\n    data: metadata,\n  });\n}\n\n/**\n * Creates an authentication error for Claude Code SDK login failures.\n *\n * @param options - Error configuration\n * @param options.message - Error message describing the authentication failure\n * @returns A LoadAPIKeyError instance\n *\n * @example\n * ```typescript\n * throw createAuthenticationError({\n *   message: 'Please run \"claude login\" to authenticate'\n * });\n * ```\n */\nexport function createAuthenticationError({ message }: { message: string }): LoadAPIKeyError {\n  return new LoadAPIKeyError({\n    message:\n      message || 'Authentication failed. Please ensure Claude Code SDK is properly authenticated.',\n  });\n}\n\n/**\n * Creates a timeout error for Claude Code SDK operations.\n *\n * @param options - Timeout error details\n * @param options.message - Error message describing the timeout\n * @param options.promptExcerpt - Excerpt of the prompt that timed out\n * @param options.timeoutMs - Timeout duration in milliseconds\n * @returns An APICallError instance configured as a timeout error\n *\n * @example\n * ```typescript\n * throw createTimeoutError({\n *   message: 'Request timed out after 2 minutes',\n *   timeoutMs: 120000\n * });\n * ```\n */\nexport function createTimeoutError({\n  message,\n  promptExcerpt,\n  timeoutMs,\n}: {\n  message: string;\n  promptExcerpt?: string;\n  timeoutMs?: number;\n}): APICallError {\n  // Store timeoutMs in metadata for potential use by error handlers\n  const metadata: ClaudeCodeErrorMetadata = {\n    code: 'TIMEOUT',\n    promptExcerpt,\n  };\n\n  return new APICallError({\n    message,\n    isRetryable: true,\n    url: 'claude-code-cli://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : undefined,\n    data: timeoutMs !== undefined ? { ...metadata, timeoutMs } : metadata,\n  });\n}\n\n/**\n * Checks if an error is an authentication error.\n * Returns true for LoadAPIKeyError instances or APICallError with exit code 401.\n *\n * @param error - The error to check\n * @returns True if the error is an authentication error\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   if (isAuthenticationError(error)) {\n *     console.log('Please authenticate with Claude Code SDK');\n *   }\n * }\n * ```\n */\nexport function isAuthenticationError(error: unknown): boolean {\n  if (error instanceof LoadAPIKeyError) return true;\n  if (error instanceof APICallError && (error.data as ClaudeCodeErrorMetadata)?.exitCode === 401)\n    return true;\n  return false;\n}\n\n/**\n * Checks if an error is a timeout error.\n * Returns true for APICallError instances with code 'TIMEOUT'.\n *\n * @param error - The error to check\n * @returns True if the error is a timeout error\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   if (isTimeoutError(error)) {\n *     console.log('Request timed out, consider retrying');\n *   }\n * }\n * ```\n */\nexport function isTimeoutError(error: unknown): boolean {\n  if (error instanceof APICallError && (error.data as ClaudeCodeErrorMetadata)?.code === 'TIMEOUT')\n    return true;\n  return false;\n}\n\n/**\n * Extracts Claude Code error metadata from an error object.\n *\n * @param error - The error to extract metadata from\n * @returns The error metadata if available, undefined otherwise\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   const metadata = getErrorMetadata(error);\n *   if (metadata?.exitCode === 401) {\n *     console.log('Authentication required');\n *   }\n * }\n * ```\n */\nexport function getErrorMetadata(error: unknown): ClaudeCodeErrorMetadata | undefined {\n  if (error instanceof APICallError && error.data) {\n    return error.data as ClaudeCodeErrorMetadata;\n  }\n  return undefined;\n}\n","import type { LanguageModelV2FinishReason } from '@ai-sdk/provider';\n\n/**\n * Maps Claude Code SDK result subtypes to AI SDK finish reasons.\n *\n * @param subtype - The result subtype from Claude Code SDK\n * @returns The corresponding AI SDK finish reason\n *\n * @example\n * ```typescript\n * const finishReason = mapClaudeCodeFinishReason('error_max_turns');\n * // Returns: 'length'\n * ```\n *\n * @remarks\n * Mappings:\n * - 'success' -> 'stop' (normal completion)\n * - 'error_max_turns' -> 'length' (hit turn limit)\n * - 'error_during_execution' -> 'error' (execution error)\n * - default -> 'stop' (unknown subtypes treated as normal completion)\n */\nexport function mapClaudeCodeFinishReason(subtype?: string): LanguageModelV2FinishReason {\n  switch (subtype) {\n    case 'success':\n      return 'stop';\n    case 'error_max_turns':\n      return 'length';\n    case 'error_during_execution':\n      return 'error';\n    default:\n      return 'stop';\n  }\n}\n","import { z } from 'zod';\nimport { existsSync } from 'fs';\n\n/**\n * Validation schemas and utilities for Claude Code provider inputs.\n * Uses Zod for type-safe validation following AI SDK patterns.\n */\n\n// Helper for Zod v3/v4 compatibility\n// Use a simple z.any() for functions to work with both versions\nconst loggerFunctionSchema = z.object({\n  debug: z.any().refine((val) => typeof val === 'function', {\n    message: 'debug must be a function',\n  }),\n  info: z.any().refine((val) => typeof val === 'function', {\n    message: 'info must be a function',\n  }),\n  warn: z.any().refine((val) => typeof val === 'function', {\n    message: 'warn must be a function',\n  }),\n  error: z.any().refine((val) => typeof val === 'function', {\n    message: 'error must be a function',\n  }),\n});\n\n/**\n * Schema for validating Claude Code settings.\n * Ensures all settings are within acceptable ranges and formats.\n */\nexport const claudeCodeSettingsSchema = z\n  .object({\n    pathToClaudeCodeExecutable: z.string().optional(),\n    customSystemPrompt: z.string().optional(),\n    appendSystemPrompt: z.string().optional(),\n    systemPrompt: z\n      .union([\n        z.string(),\n        z.object({\n          type: z.literal('preset'),\n          preset: z.literal('claude_code'),\n          append: z.string().optional(),\n        }),\n      ])\n      .optional(),\n    maxTurns: z.number().int().min(1).max(100).optional(),\n    maxThinkingTokens: z.number().int().positive().max(100000).optional(),\n    cwd: z\n      .string()\n      .refine(\n        (val) => {\n          // Skip directory validation in non-Node environments\n          if (typeof process === 'undefined' || !process.versions?.node) {\n            return true;\n          }\n          return !val || existsSync(val);\n        },\n        { message: 'Working directory must exist' }\n      )\n      .optional(),\n    executable: z.enum(['bun', 'deno', 'node']).optional(),\n    executableArgs: z.array(z.string()).optional(),\n    permissionMode: z.enum(['default', 'acceptEdits', 'bypassPermissions', 'plan']).optional(),\n    permissionPromptToolName: z.string().optional(),\n    continue: z.boolean().optional(),\n    resume: z.string().optional(),\n    allowedTools: z.array(z.string()).optional(),\n    disallowedTools: z.array(z.string()).optional(),\n    betas: z.array(z.string()).optional(),\n    allowDangerouslySkipPermissions: z.boolean().optional(),\n    enableFileCheckpointing: z.boolean().optional(),\n    maxBudgetUsd: z.number().min(0).optional(),\n    plugins: z\n      .array(\n        z\n          .object({\n            type: z.string(),\n            path: z.string(),\n          })\n          .passthrough()\n      )\n      .optional(),\n    resumeSessionAt: z.string().optional(),\n    sandbox: z\n      .any()\n      .refine((val) => val === undefined || typeof val === 'object', {\n        message: 'sandbox must be an object',\n      })\n      .optional(),\n    tools: z\n      .union([\n        z.array(z.string()),\n        z.object({\n          type: z.literal('preset'),\n          preset: z.literal('claude_code'),\n        }),\n      ])\n      .optional(),\n    settingSources: z.array(z.enum(['user', 'project', 'local'])).optional(),\n    streamingInput: z.enum(['auto', 'always', 'off']).optional(),\n    // Hooks and tool-permission callback (permissive validation of shapes)\n    canUseTool: z\n      .any()\n      .refine((v) => v === undefined || typeof v === 'function', {\n        message: 'canUseTool must be a function',\n      })\n      .optional(),\n    hooks: z\n      .record(\n        z.string(),\n        z.array(\n          z.object({\n            matcher: z.string().optional(),\n            hooks: z.array(z.any()).nonempty(),\n          })\n        )\n      )\n      .optional(),\n    mcpServers: z\n      .record(\n        z.string(),\n        z.union([\n          // McpStdioServerConfig\n          z.object({\n            type: z.literal('stdio').optional(),\n            command: z.string(),\n            args: z.array(z.string()).optional(),\n            env: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpSSEServerConfig\n          z.object({\n            type: z.literal('sse'),\n            url: z.string(),\n            headers: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpHttpServerConfig\n          z.object({\n            type: z.literal('http'),\n            url: z.string(),\n            headers: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpSdkServerConfig (in-process custom tools)\n          z.object({\n            type: z.literal('sdk'),\n            name: z.string(),\n            instance: z.any(),\n          }),\n        ])\n      )\n      .optional(),\n    verbose: z.boolean().optional(),\n    logger: z.union([z.literal(false), loggerFunctionSchema]).optional(),\n    env: z.record(z.string(), z.string().optional()).optional(),\n    additionalDirectories: z.array(z.string()).optional(),\n    agents: z\n      .record(\n        z.string(),\n        z.object({\n          description: z.string(),\n          tools: z.array(z.string()).optional(),\n          prompt: z.string(),\n          model: z.enum(['sonnet', 'opus', 'haiku', 'inherit']).optional(),\n        })\n      )\n      .optional(),\n    includePartialMessages: z.boolean().optional(),\n    fallbackModel: z.string().optional(),\n    forkSession: z.boolean().optional(),\n    stderr: z\n      .any()\n      .refine((val) => val === undefined || typeof val === 'function', {\n        message: 'stderr must be a function',\n      })\n      .optional(),\n    strictMcpConfig: z.boolean().optional(),\n    extraArgs: z.record(z.string(), z.union([z.string(), z.null()])).optional(),\n    sdkOptions: z.record(z.string(), z.any()).optional(),\n  })\n  .strict();\n\n/**\n * Validates a model ID and returns warnings if needed.\n *\n * @param modelId - The model ID to validate\n * @returns Warning message if model is unknown, undefined otherwise\n */\nexport function validateModelId(modelId: string): string | undefined {\n  const knownModels = ['opus', 'sonnet', 'haiku'];\n\n  // Check for empty or whitespace-only\n  if (!modelId || modelId.trim() === '') {\n    throw new Error('Model ID cannot be empty');\n  }\n\n  // Warn about unknown models but allow them\n  if (!knownModels.includes(modelId)) {\n    return `Unknown model ID: '${modelId}'. Proceeding with custom model. Known models are: ${knownModels.join(', ')}`;\n  }\n\n  return undefined;\n}\n\n/**\n * Validates Claude Code settings and returns validation results.\n *\n * @param settings - The settings object to validate\n * @returns Object with validation results and any warnings\n */\nexport function validateSettings(settings: unknown): {\n  valid: boolean;\n  warnings: string[];\n  errors: string[];\n} {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  try {\n    // Parse with Zod schema\n    const result = claudeCodeSettingsSchema.safeParse(settings);\n\n    if (!result.success) {\n      // Extract user-friendly error messages\n      // Support both Zod v3 (errors) and v4 (issues)\n      const errorObject = result.error as {\n        errors?: Array<{ path: string[]; message: string }>;\n        issues?: Array<{ path: string[]; message: string }>;\n      };\n      const issues = errorObject.errors || errorObject.issues || [];\n      issues.forEach((err: { path: string[]; message: string }) => {\n        const path = err.path.join('.');\n        errors.push(`${path ? `${path}: ` : ''}${err.message}`);\n      });\n      return { valid: false, warnings, errors };\n    }\n\n    // Additional validation warnings\n    const validSettings = result.data;\n\n    // Warn about high turn limits\n    if (validSettings.maxTurns && validSettings.maxTurns > 20) {\n      warnings.push(\n        `High maxTurns value (${validSettings.maxTurns}) may lead to long-running conversations`\n      );\n    }\n\n    // Warn about very high thinking tokens\n    if (validSettings.maxThinkingTokens && validSettings.maxThinkingTokens > 50000) {\n      warnings.push(\n        `Very high maxThinkingTokens (${validSettings.maxThinkingTokens}) may increase response time`\n      );\n    }\n\n    // Check if both allowedTools and disallowedTools are specified\n    if (validSettings.allowedTools && validSettings.disallowedTools) {\n      warnings.push(\n        'Both allowedTools and disallowedTools are specified. Only allowedTools will be used.'\n      );\n    }\n\n    // Validate tool name format\n    const validateToolNames = (tools: string[], type: string) => {\n      tools.forEach((tool) => {\n        // Basic validation - tool names should be alphanumeric with optional specifiers\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\\([^)]*\\))?$/.test(tool) && !tool.startsWith('mcp__')) {\n          warnings.push(`Unusual ${type} tool name format: '${tool}'`);\n        }\n      });\n    };\n\n    if (validSettings.allowedTools) {\n      validateToolNames(validSettings.allowedTools, 'allowed');\n    }\n\n    if (validSettings.disallowedTools) {\n      validateToolNames(validSettings.disallowedTools, 'disallowed');\n    }\n\n    return { valid: true, warnings, errors };\n  } catch (error) {\n    errors.push(`Validation error: ${error instanceof Error ? error.message : String(error)}`);\n    return { valid: false, warnings, errors };\n  }\n}\n\n/**\n * Validates prompt length and format.\n *\n * @param prompt - The prompt to validate\n * @returns Warning message if prompt might cause issues\n */\nexport function validatePrompt(prompt: string): string | undefined {\n  // Very long prompts might cause issues\n  const MAX_PROMPT_LENGTH = 100000; // ~25k tokens\n\n  if (prompt.length > MAX_PROMPT_LENGTH) {\n    return `Very long prompt (${prompt.length} characters) may cause performance issues or timeouts`;\n  }\n\n  return undefined;\n}\n\n/**\n * Validates session ID format.\n *\n * @param sessionId - The session ID to validate\n * @returns Warning message if format is unusual\n */\nexport function validateSessionId(sessionId: string): string | undefined {\n  // Session IDs from Claude Code are typically UUID-like\n  // But we don't want to be too strict as format might change\n  if (sessionId && !/^[a-zA-Z0-9-_]+$/.test(sessionId)) {\n    return `Unusual session ID format. This may cause issues with session resumption.`;\n  }\n\n  return undefined;\n}\n","import type { Logger } from './types.js';\n\n/**\n * Default logger that uses console with level tags.\n */\nconst defaultLogger: Logger = {\n  // eslint-disable-next-line no-console\n  debug: (message: string) => console.debug(`[DEBUG] ${message}`),\n  // eslint-disable-next-line no-console\n  info: (message: string) => console.info(`[INFO] ${message}`),\n  warn: (message: string) => console.warn(`[WARN] ${message}`),\n  error: (message: string) => console.error(`[ERROR] ${message}`),\n};\n\n/**\n * No-op logger that discards all messages.\n */\nconst noopLogger: Logger = {\n  debug: () => {},\n  info: () => {},\n  warn: () => {},\n  error: () => {},\n};\n\n/**\n * Gets the appropriate logger based on configuration.\n *\n * @param logger - Logger configuration from settings\n * @returns The logger to use\n */\nexport function getLogger(logger: Logger | false | undefined): Logger {\n  if (logger === false) {\n    return noopLogger;\n  }\n\n  if (logger === undefined) {\n    return defaultLogger;\n  }\n\n  return logger;\n}\n\n/**\n * Creates a verbose-aware logger that only logs debug/info when verbose is enabled.\n * Warn and error are always logged regardless of verbose setting.\n *\n * @param logger - Base logger to wrap\n * @param verbose - Whether to enable verbose (debug/info) logging\n * @returns Logger with verbose-aware behavior\n */\nexport function createVerboseLogger(logger: Logger, verbose: boolean = false): Logger {\n  if (verbose) {\n    // When verbose is enabled, use all log levels\n    return logger;\n  }\n\n  // When verbose is disabled, only allow warn/error\n  // Bind methods to preserve 'this' context for custom loggers\n  return {\n    debug: () => {}, // No-op when not verbose\n    info: () => {}, // No-op when not verbose\n    warn: logger.warn.bind(logger),\n    error: logger.error.bind(logger),\n  };\n}\n","import { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';\nimport type { McpSdkServerConfigWithInstance } from '@anthropic-ai/claude-agent-sdk';\nimport { type ZodRawShape, type ZodObject } from 'zod';\n\n/**\n * Optional annotations for content items, per MCP specification.\n * Validated against MCP SDK schema version 2025-06-18.\n */\ntype ContentAnnotations = {\n  /** Intended audience(s) for this content */\n  audience?: ('user' | 'assistant')[];\n  /** Priority hint (0 = least important, 1 = most important) */\n  priority?: number;\n  /** ISO 8601 timestamp of last modification */\n  lastModified?: string;\n};\n\n/**\n * Convenience helper to create an SDK MCP server from a simple tool map.\n * Each tool provides a description, a Zod object schema, and a handler.\n *\n * Type definition validated against MCP SDK specification version 2025-06-18.\n * See: https://modelcontextprotocol.io/specification/2025-06-18/server/tools\n */\nexport type MinimalCallToolResult = {\n  content: Array<\n    | {\n        /** Text content */\n        type: 'text';\n        /** The text content (plain text or structured format like JSON) */\n        text: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Image content (base64-encoded) */\n        type: 'image';\n        /** Base64-encoded image data */\n        data: string;\n        /** MIME type of the image (e.g., image/png, image/jpeg) */\n        mimeType: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Audio content (base64-encoded) */\n        type: 'audio';\n        /** Base64-encoded audio data */\n        data: string;\n        /** MIME type of the audio (e.g., audio/wav, audio/mp3) */\n        mimeType: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Embedded resource with full content (text or blob) */\n        type: 'resource';\n        /** Resource contents - either text or blob variant */\n        resource: { uri: string; _meta?: Record<string, unknown>; [key: string]: unknown } & (\n          | { text: string; mimeType?: string }\n          | { blob: string; mimeType: string }\n        );\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Resource link (reference only - no embedded content) */\n        type: 'resource_link';\n        /** URI of the resource */\n        uri: string;\n        /** Human-readable name (required per MCP spec) */\n        name: string;\n        /** Optional description of what this resource represents */\n        description?: string;\n        /** MIME type of the resource, if known */\n        mimeType?: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n  >;\n  isError?: boolean;\n  structuredContent?: Record<string, unknown>;\n  _meta?: Record<string, unknown>;\n  [key: string]: unknown;\n};\n\nexport function createCustomMcpServer<\n  Tools extends Record<\n    string,\n    {\n      description: string;\n      inputSchema: ZodObject<ZodRawShape>;\n      handler: (args: Record<string, unknown>, extra: unknown) => Promise<MinimalCallToolResult>;\n    }\n  >,\n>(config: { name: string; version?: string; tools: Tools }): McpSdkServerConfigWithInstance {\n  const defs = Object.entries(config.tools).map(([name, def]) =>\n    tool(\n      name,\n      def.description,\n      def.inputSchema.shape as ZodRawShape,\n      (args: Record<string, unknown>, extra: unknown) => def.handler(args, extra)\n    )\n  );\n  return createSdkMcpServer({ name: config.name, version: config.version, tools: defs });\n}\n"],"mappings":"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","names":["import_provider","import_provider","tool","tool","content","tool","import_claude_agent_sdk","import_claude_agent_sdk","import_zod"]}
\ No newline at end of file
+{"version":3,"sources":["../src/index.ts","../src/claude-code-provider.ts","../src/claude-code-language-model.ts","../src/convert-to-claude-code-messages.ts","../src/errors.ts","../src/map-claude-code-finish-reason.ts","../src/validation.ts","../src/logger.ts","../src/mcp-helpers.ts"],"sourcesContent":["/**\n * Provider exports for creating and configuring Claude Code instances.\n * @module claude-code\n */\n\n/**\n * Creates a new Claude Code provider instance and the default provider instance.\n * @see {@link createClaudeCode} for creating custom provider instances\n * @see {@link claudeCode} for the default provider instance\n */\nexport { createClaudeCode, claudeCode } from './claude-code-provider.js';\n\n/**\n * Type definitions for the Claude Code provider.\n * @see {@link ClaudeCodeProvider} for the provider interface\n * @see {@link ClaudeCodeProviderSettings} for provider configuration options\n */\nexport type { ClaudeCodeProvider, ClaudeCodeProviderSettings } from './claude-code-provider.js';\n\n/**\n * Language model implementation for Claude Code.\n * This class implements the AI SDK's LanguageModelV2 interface.\n */\nexport { ClaudeCodeLanguageModel } from './claude-code-language-model.js';\n\n/**\n * Type definitions for Claude Code language models.\n * @see {@link ClaudeCodeModelId} for supported model identifiers\n * @see {@link ClaudeCodeLanguageModelOptions} for model configuration options\n */\nexport type {\n  ClaudeCodeModelId,\n  ClaudeCodeLanguageModelOptions,\n} from './claude-code-language-model.js';\n\n/**\n * Settings for configuring Claude Code behavior.\n * Includes options for customizing the CLI execution, permissions, and tool usage.\n */\nexport type { ClaudeCodeSettings, Logger } from './types.js';\n\n// Convenience re-exports from the SDK for custom tools and hooks\nexport { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';\nexport { createCustomMcpServer } from './mcp-helpers.js';\nexport type {\n  HookEvent,\n  HookCallback,\n  HookCallbackMatcher,\n  HookInput,\n  HookJSONOutput,\n  PreToolUseHookInput,\n  PostToolUseHookInput,\n  UserPromptSubmitHookInput,\n  SessionStartHookInput,\n  SessionEndHookInput,\n  CanUseTool,\n  PermissionResult,\n  PermissionUpdate,\n  PermissionBehavior,\n  PermissionRuleValue,\n  McpServerConfig,\n  McpSdkServerConfigWithInstance,\n  OutputFormat,\n} from '@anthropic-ai/claude-agent-sdk';\n\n/**\n * Error handling utilities for Claude Code.\n * These functions help create and identify specific error types.\n *\n * @see {@link isAuthenticationError} to check for authentication failures\n * @see {@link isTimeoutError} to check for timeout errors\n * @see {@link getErrorMetadata} to extract error metadata\n * @see {@link createAPICallError} to create general API errors\n * @see {@link createAuthenticationError} to create authentication errors\n * @see {@link createTimeoutError} to create timeout errors\n */\nexport {\n  isAuthenticationError,\n  isTimeoutError,\n  getErrorMetadata,\n  createAPICallError,\n  createAuthenticationError,\n  createTimeoutError,\n} from './errors.js';\n\n/**\n * Metadata associated with Claude Code errors.\n * Contains additional context about CLI execution failures.\n */\nexport type { ClaudeCodeErrorMetadata } from './errors.js';\n","import type { LanguageModelV2, ProviderV2 } from '@ai-sdk/provider';\nimport { NoSuchModelError } from '@ai-sdk/provider';\nimport { ClaudeCodeLanguageModel, type ClaudeCodeModelId } from './claude-code-language-model.js';\nimport type { ClaudeCodeSettings } from './types.js';\nimport { validateSettings } from './validation.js';\nimport { getLogger } from './logger.js';\n\n/**\n * Claude Code provider interface that extends the AI SDK's ProviderV1.\n * Provides methods to create language models for interacting with Claude via the CLI.\n *\n * @example\n * ```typescript\n * import { claudeCode } from 'ai-sdk-provider-claude-code';\n *\n * // Create a model instance\n * const model = claudeCode('opus');\n *\n * // Or use the explicit methods\n * const chatModel = claudeCode.chat('sonnet');\n * const languageModel = claudeCode.languageModel('opus', { maxTurns: 10 });\n * ```\n */\nexport interface ClaudeCodeProvider extends ProviderV2 {\n  /**\n   * Creates a language model instance for the specified model ID.\n   * This is a shorthand for calling `languageModel()`.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  (modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  /**\n   * Creates a language model instance for text generation.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  languageModel(modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  /**\n   * Alias for `languageModel()` to maintain compatibility with AI SDK patterns.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  chat(modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  imageModel(modelId: string): never;\n}\n\n/**\n * Configuration options for creating a Claude Code provider instance.\n * These settings will be applied as defaults to all models created by the provider.\n *\n * @example\n * ```typescript\n * const provider = createClaudeCode({\n *   defaultSettings: {\n *     maxTurns: 5,\n *     cwd: '/path/to/project'\n *   }\n * });\n * ```\n */\nexport interface ClaudeCodeProviderSettings {\n  /**\n   * Default settings to use for all models created by this provider.\n   * Individual model settings will override these defaults.\n   */\n  defaultSettings?: ClaudeCodeSettings;\n}\n\n/**\n * Creates a Claude Code provider instance with the specified configuration.\n * The provider can be used to create language models for interacting with Claude 4 models.\n *\n * @param options - Provider configuration options\n * @returns Claude Code provider instance\n *\n * @example\n * ```typescript\n * const provider = createClaudeCode({\n *   defaultSettings: {\n *     permissionMode: 'bypassPermissions',\n *     maxTurns: 10\n *   }\n * });\n *\n * const model = provider('opus');\n * ```\n */\nexport function createClaudeCode(options: ClaudeCodeProviderSettings = {}): ClaudeCodeProvider {\n  // Get logger from default settings if provided\n  const logger = getLogger(options.defaultSettings?.logger);\n\n  // Validate default settings if provided\n  if (options.defaultSettings) {\n    const validation = validateSettings(options.defaultSettings);\n    if (!validation.valid) {\n      throw new Error(`Invalid default settings: ${validation.errors.join(', ')}`);\n    }\n    if (validation.warnings.length > 0) {\n      validation.warnings.forEach((warning) => logger.warn(`Claude Code Provider: ${warning}`));\n    }\n  }\n\n  const createModel = (\n    modelId: ClaudeCodeModelId,\n    settings: ClaudeCodeSettings = {}\n  ): LanguageModelV2 => {\n    const mergedSettings = {\n      ...options.defaultSettings,\n      ...settings,\n    };\n\n    // Validate merged settings\n    const validation = validateSettings(mergedSettings);\n    if (!validation.valid) {\n      throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);\n    }\n\n    return new ClaudeCodeLanguageModel({\n      id: modelId,\n      settings: mergedSettings,\n      settingsValidationWarnings: validation.warnings,\n    });\n  };\n\n  const provider = function (modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings) {\n    if (new.target) {\n      throw new Error('The Claude Code model function cannot be called with the new keyword.');\n    }\n\n    return createModel(modelId, settings);\n  };\n\n  provider.languageModel = createModel;\n  provider.chat = createModel; // Alias for languageModel\n\n  // Add textEmbeddingModel method that throws NoSuchModelError\n  provider.textEmbeddingModel = (modelId: string) => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: 'textEmbeddingModel',\n    });\n  };\n\n  provider.imageModel = (modelId: string) => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: 'imageModel',\n    });\n  };\n\n  return provider as ClaudeCodeProvider;\n}\n\n/**\n * Default Claude Code provider instance.\n * Pre-configured provider for quick usage without custom settings.\n *\n * @example\n * ```typescript\n * import { claudeCode } from 'ai-sdk-provider-claude-code';\n * import { generateText } from 'ai';\n *\n * const { text } = await generateText({\n *   model: claudeCode('sonnet'),\n *   prompt: 'Hello, Claude!'\n * });\n * ```\n */\nexport const claudeCode = createClaudeCode();\n","import type {\n  LanguageModelV2,\n  LanguageModelV2CallWarning,\n  LanguageModelV2FinishReason,\n  LanguageModelV2StreamPart,\n  LanguageModelV2Usage,\n  JSONValue,\n} from '@ai-sdk/provider';\nimport { NoSuchModelError, APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/provider-utils';\nimport type { ToolSet } from 'ai';\nimport type { ClaudeCodeSettings, Logger } from './types.js';\n\nimport { convertToClaudeCodeMessages } from './convert-to-claude-code-messages.js';\nimport { createAPICallError, createAuthenticationError, createTimeoutError } from './errors.js';\nimport { mapClaudeCodeFinishReason } from './map-claude-code-finish-reason.js';\nimport { validateModelId, validatePrompt, validateSessionId } from './validation.js';\nimport { getLogger, createVerboseLogger } from './logger.js';\n\nimport {\n  query,\n  type Options,\n  createSdkMcpServer,\n  tool,\n  type McpServerConfig,\n} from '@anthropic-ai/claude-agent-sdk';\nimport type { SDKUserMessage, SDKPartialAssistantMessage } from '@anthropic-ai/claude-agent-sdk';\nimport { type ZodRawShape } from 'zod';\nimport type { MinimalCallToolResult } from './mcp-helpers.js';\n\nconst CLAUDE_CODE_TRUNCATION_WARNING =\n  'Claude Code SDK output ended unexpectedly; returning truncated response from buffered text. Await upstream fix to avoid data loss.';\n\nconst MIN_TRUNCATION_LENGTH = 512;\n\n/**\n * Detects if an error represents a truncated SDK JSON stream.\n *\n * The Claude Code SDK can truncate JSON responses mid-stream, producing a SyntaxError.\n * This function distinguishes genuine truncation from normal JSON syntax errors by:\n * 1. Verifying the error is a SyntaxError with truncation-specific messages\n * 2. Ensuring we received meaningful content (>= MIN_TRUNCATION_LENGTH characters)\n * 3. Avoiding false positives from unrelated parse errors\n *\n * Note: We compare against `bufferedText` (assistant text content) rather than the raw\n * JSON buffer length, since the SDK layer doesn't expose buffer positions. The position\n * reported in SyntaxError messages measures the full JSON payload (metadata + content),\n * which is typically much larger than extracted text. Therefore, we cannot reliably use\n * position proximity checks and instead rely on message patterns and content length.\n *\n * @param error - The caught error (expected to be SyntaxError for truncation)\n * @param bufferedText - Accumulated assistant text content (measured in UTF-16 code units)\n * @returns true if error indicates SDK truncation; false otherwise\n */\nfunction isClaudeCodeTruncationError(error: unknown, bufferedText: string): boolean {\n  // Check for SyntaxError by instanceof or by name (for cross-realm errors)\n  const isSyntaxError =\n    error instanceof SyntaxError ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (typeof (error as any)?.name === 'string' &&\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (error as any).name.toLowerCase() === 'syntaxerror');\n\n  if (!isSyntaxError) {\n    return false;\n  }\n\n  if (!bufferedText) {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const rawMessage = typeof (error as any)?.message === 'string' ? (error as any).message : '';\n  const message = rawMessage.toLowerCase();\n\n  // Only match actual truncation patterns, not normal JSON parsing errors.\n  // Real truncation: \"Unexpected end of JSON input\" or \"Unterminated string in JSON...\"\n  // Normal errors: \"Unexpected token X in JSON at position N\" (should be surfaced as errors)\n  const truncationIndicators = [\n    'unexpected end of json input',\n    'unexpected end of input',\n    'unexpected end of string',\n    'unexpected eof',\n    'end of file',\n    'unterminated string',\n    'unterminated string constant',\n  ];\n\n  if (!truncationIndicators.some((indicator) => message.includes(indicator))) {\n    return false;\n  }\n\n  // Require meaningful content before treating as truncation.\n  // Short responses with \"end of input\" errors are likely genuine syntax errors.\n  // Note: bufferedText.length measures UTF-16 code units, not byte length.\n  if (bufferedText.length < MIN_TRUNCATION_LENGTH) {\n    return false;\n  }\n\n  // If we have a truncation indicator AND meaningful content, treat as truncation.\n  return true;\n}\n\nfunction isAbortError(err: unknown): boolean {\n  if (err && typeof err === 'object') {\n    const e = err as { name?: unknown; code?: unknown };\n    if (typeof e.name === 'string' && e.name === 'AbortError') return true;\n    if (typeof e.code === 'string' && e.code.toUpperCase() === 'ABORT_ERR') return true;\n  }\n  return false;\n}\n\nconst STREAMING_FEATURE_WARNING =\n  \"Claude Agent SDK features (hooks/MCP/images) require streaming input. Set `streamingInput: 'always'` or provide `canUseTool` (auto streams only when canUseTool is set).\";\n\nconst SDK_OPTIONS_BLOCKLIST = new Set(['model', 'abortController', 'prompt', 'outputFormat']);\n\ntype ClaudeToolUse = {\n  id: string;\n  name: string;\n  input: unknown;\n};\n\ntype ClaudeToolResult = {\n  id: string;\n  name?: string;\n  result: unknown;\n  isError: boolean;\n};\n\n// Provider extension for tool-error stream parts.\ntype ToolErrorPart = {\n  type: 'tool-error';\n  toolCallId: string;\n  toolName: string;\n  error: string;\n  providerExecuted: true;\n  providerMetadata?: Record<string, JSONValue>;\n};\n\n// Local extension of the AI SDK stream part union to include tool-error.\ntype ExtendedStreamPart = LanguageModelV2StreamPart | ToolErrorPart;\n\n/**\n * Tracks the streaming lifecycle state for a single tool invocation.\n *\n * The tool streaming lifecycle follows this sequence:\n * 1. Tool use detected → state created with all flags false\n * 2. First input seen → `inputStarted` = true, emit `tool-input-start`\n * 3. Input deltas streamed → emit `tool-input-delta` (may be skipped for large/non-prefix updates)\n * 4. Input finalized → `inputClosed` = true, emit `tool-input-end`\n * 5. Tool call formed → `callEmitted` = true, emit `tool-call`\n * 6. Tool results/errors arrive → emit `tool-result` or `tool-error` (may occur multiple times)\n * 7. Stream ends → state cleaned up by `finalizeToolCalls()`\n *\n * @property name - Tool name from SDK (e.g., \"Bash\", \"Read\")\n * @property lastSerializedInput - Most recent serialized input, used for delta calculation\n * @property inputStarted - True after `tool-input-start` emitted; prevents duplicate start events\n * @property inputClosed - True after `tool-input-end` emitted; ensures proper event ordering\n * @property callEmitted - True after `tool-call` emitted; prevents duplicate call events when\n *                         multiple result/error chunks arrive for the same tool invocation\n */\ntype ToolStreamState = {\n  name: string;\n  lastSerializedInput?: string;\n  inputStarted: boolean;\n  inputClosed: boolean;\n  callEmitted: boolean;\n};\n\nfunction toAsyncIterablePrompt(\n  messagesPrompt: string,\n  outputStreamEnded: Promise<unknown>,\n  sessionId?: string,\n  contentParts?: SDKUserMessage['message']['content']\n): AsyncIterable<SDKUserMessage> {\n  const content = (\n    contentParts && contentParts.length > 0\n      ? contentParts\n      : [{ type: 'text', text: messagesPrompt }]\n  ) as SDKUserMessage['message']['content'];\n\n  const msg: SDKUserMessage = {\n    type: 'user',\n    message: {\n      role: 'user',\n      content,\n    },\n    parent_tool_use_id: null,\n    session_id: sessionId ?? '',\n  };\n  return {\n    async *[Symbol.asyncIterator]() {\n      yield msg;\n      await outputStreamEnded;\n    },\n  };\n}\n\n/**\n * Options for creating a Claude Code language model instance.\n *\n * @example\n * ```typescript\n * const model = new ClaudeCodeLanguageModel({\n *   id: 'opus',\n *   settings: {\n *     maxTurns: 10,\n *     permissionMode: 'auto'\n *   }\n * });\n * ```\n */\nexport interface ClaudeCodeLanguageModelOptions {\n  /**\n   * The model identifier to use.\n   * Can be 'opus', 'sonnet', 'haiku', or a custom model string.\n   */\n  id: ClaudeCodeModelId;\n\n  /**\n   * Optional settings to configure the model behavior.\n   */\n  settings?: ClaudeCodeSettings;\n\n  /**\n   * Validation warnings from settings validation.\n   * Used internally to pass warnings from provider.\n   */\n  settingsValidationWarnings?: string[];\n}\n\n/**\n * Supported Claude model identifiers.\n * - 'opus': Claude Opus (most capable)\n * - 'sonnet': Claude Sonnet (balanced performance)\n * - 'haiku': Claude Haiku (fastest, most cost-effective)\n * - Custom string: Any full model identifier (e.g., 'claude-opus-4-5', 'claude-sonnet-4-5-20250514')\n *\n * @example\n * ```typescript\n * const opusModel = claudeCode('opus');\n * const sonnetModel = claudeCode('sonnet');\n * const haikuModel = claudeCode('haiku');\n * const customModel = claudeCode('claude-opus-4-5');\n * ```\n */\nexport type ClaudeCodeModelId = 'opus' | 'sonnet' | 'haiku' | (string & {});\n\nconst modelMap: Record<string, string> = {\n  opus: 'opus',\n  sonnet: 'sonnet',\n  haiku: 'haiku',\n};\n\n/**\n * Language model implementation for Claude Code SDK.\n * This class implements the AI SDK's LanguageModelV2 interface to provide\n * integration with Claude models through the Claude Agent SDK.\n *\n * Features:\n * - Supports streaming and non-streaming generation\n * - Native structured outputs via SDK's outputFormat (guaranteed schema compliance)\n * - Manages CLI sessions for conversation continuity\n * - Provides detailed error handling and retry logic\n *\n * Limitations:\n * - Image inputs require streaming mode\n * - Some parameters like temperature and max tokens are not supported by the CLI\n *\n * @example\n * ```typescript\n * const model = new ClaudeCodeLanguageModel({\n *   id: 'opus',\n *   settings: { maxTurns: 5 }\n * });\n *\n * const result = await model.doGenerate({\n *   prompt: [{ role: 'user', content: 'Hello!' }],\n *   mode: { type: 'regular' }\n * });\n * ```\n */\nexport class ClaudeCodeLanguageModel implements LanguageModelV2 {\n  readonly specificationVersion = 'v2' as const;\n  readonly defaultObjectGenerationMode = 'json' as const;\n  readonly supportsImageUrls = false;\n  readonly supportedUrls = {};\n  readonly supportsStructuredOutputs = true;\n\n  // Fallback/magic string constants\n  static readonly UNKNOWN_TOOL_NAME = 'unknown-tool';\n\n  // Tool input safety limits\n  private static readonly MAX_TOOL_INPUT_SIZE = 1_048_576; // 1MB hard limit\n  private static readonly MAX_TOOL_INPUT_WARN = 102_400; // 100KB warning threshold\n  private static readonly MAX_DELTA_CALC_SIZE = 10_000; // 10KB delta computation threshold\n\n  readonly modelId: ClaudeCodeModelId;\n  readonly settings: ClaudeCodeSettings;\n\n  private sessionId?: string;\n  private modelValidationWarning?: string;\n  private settingsValidationWarnings: string[];\n  private logger: Logger;\n\n  constructor(options: ClaudeCodeLanguageModelOptions) {\n    this.modelId = options.id;\n    this.settings = options.settings ?? {};\n    this.settingsValidationWarnings = options.settingsValidationWarnings ?? [];\n\n    // Create logger that respects verbose setting\n    const baseLogger = getLogger(this.settings.logger);\n    this.logger = createVerboseLogger(baseLogger, this.settings.verbose ?? false);\n\n    // Validate model ID format\n    if (!this.modelId || typeof this.modelId !== 'string' || this.modelId.trim() === '') {\n      throw new NoSuchModelError({\n        modelId: this.modelId,\n        modelType: 'languageModel',\n      });\n    }\n\n    // Additional model ID validation\n    this.modelValidationWarning = validateModelId(this.modelId);\n    if (this.modelValidationWarning) {\n      this.logger.warn(`Claude Code Model: ${this.modelValidationWarning}`);\n    }\n  }\n\n  get provider(): string {\n    return 'claude-code';\n  }\n\n  private getModel(): string {\n    const mapped = modelMap[this.modelId];\n    return mapped ?? this.modelId;\n  }\n\n  private getSanitizedSdkOptions(): Partial<Options> | undefined {\n    if (!this.settings.sdkOptions || typeof this.settings.sdkOptions !== 'object') {\n      return undefined;\n    }\n\n    const sanitized = { ...(this.settings.sdkOptions as Record<string, unknown>) };\n    const blockedKeys = Array.from(SDK_OPTIONS_BLOCKLIST).filter((key) => key in sanitized);\n\n    if (blockedKeys.length > 0) {\n      this.logger.warn(\n        `[claude-code] sdkOptions includes provider-managed fields (${blockedKeys.join(\n          ', '\n        )}); these will be ignored.`\n      );\n      blockedKeys.forEach((key) => delete sanitized[key]);\n    }\n\n    return sanitized as Partial<Options>;\n  }\n\n  private getEffectiveResume(sdkOptions?: Partial<Options>): string | undefined {\n    return sdkOptions?.resume ?? this.settings.resume ?? this.sessionId;\n  }\n\n  private extractToolUses(content: unknown): ClaudeToolUse[] {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (item): item is { type: string; id?: unknown; name?: unknown; input?: unknown } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_use'\n      )\n      .map((item) => {\n        const { id, name, input } = item as { id?: unknown; name?: unknown; input?: unknown };\n        return {\n          id: typeof id === 'string' && id.length > 0 ? id : generateId(),\n          name:\n            typeof name === 'string' && name.length > 0\n              ? name\n              : ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME,\n          input,\n        } satisfies ClaudeToolUse;\n      });\n  }\n\n  private extractToolResults(content: unknown): ClaudeToolResult[] {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (\n          item\n        ): item is {\n          type: string;\n          tool_use_id?: unknown;\n          content?: unknown;\n          is_error?: unknown;\n          name?: unknown;\n        } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_result'\n      )\n      .map((item) => {\n        const { tool_use_id, content, is_error, name } = item;\n        return {\n          id:\n            typeof tool_use_id === 'string' && tool_use_id.length > 0 ? tool_use_id : generateId(),\n          name: typeof name === 'string' && name.length > 0 ? name : undefined,\n          result: content,\n          isError: Boolean(is_error),\n        } satisfies ClaudeToolResult;\n      });\n  }\n\n  private extractToolErrors(content: unknown): Array<{\n    id: string;\n    name?: string;\n    error: unknown;\n  }> {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (\n          item\n        ): item is {\n          type: string;\n          tool_use_id?: unknown;\n          error?: unknown;\n          name?: unknown;\n        } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_error'\n      )\n      .map((item) => {\n        const { tool_use_id, error, name } = item as {\n          tool_use_id?: unknown;\n          error?: unknown;\n          name?: unknown;\n        };\n        return {\n          id:\n            typeof tool_use_id === 'string' && tool_use_id.length > 0 ? tool_use_id : generateId(),\n          name: typeof name === 'string' && name.length > 0 ? name : undefined,\n          error,\n        };\n      });\n  }\n\n  private serializeToolInput(input: unknown): string {\n    if (typeof input === 'string') {\n      return this.checkInputSize(input);\n    }\n\n    if (input === undefined) {\n      return '';\n    }\n\n    try {\n      const serialized = JSON.stringify(input);\n      return this.checkInputSize(serialized);\n    } catch {\n      const fallback = String(input);\n      return this.checkInputSize(fallback);\n    }\n  }\n\n  private checkInputSize(str: string): string {\n    const length = str.length;\n\n    if (length > ClaudeCodeLanguageModel.MAX_TOOL_INPUT_SIZE) {\n      throw new Error(\n        `Tool input exceeds maximum size of ${ClaudeCodeLanguageModel.MAX_TOOL_INPUT_SIZE} bytes (got ${length} bytes). This may indicate a malformed request or an attempt to process excessively large data.`\n      );\n    }\n\n    if (length > ClaudeCodeLanguageModel.MAX_TOOL_INPUT_WARN) {\n      this.logger.warn(\n        `[claude-code] Large tool input detected: ${length} bytes. Performance may be impacted. Consider chunking or reducing input size.`\n      );\n    }\n\n    return str;\n  }\n\n  private normalizeToolResult(toolName: string, result: unknown): unknown {\n    if (toolName.startsWith('mcp__ai-sdk__') && Array.isArray(result) && result.length === 1 && 'text' in result[0]) {\n      return JSON.parse(result[0].text);\n    }\n\n    if (typeof result === 'string') {\n      try {\n        return JSON.parse(result);\n      } catch {\n        return result;\n      }\n    }\n\n    return result;\n  }\n\n  private generateAllWarnings(\n    options:\n      | Parameters<LanguageModelV2['doGenerate']>[0]\n      | Parameters<LanguageModelV2['doStream']>[0],\n    prompt: string\n  ): LanguageModelV2CallWarning[] {\n    const warnings: LanguageModelV2CallWarning[] = [];\n    const unsupportedParams: string[] = [];\n\n    // Check for unsupported parameters\n    if (options.temperature !== undefined) unsupportedParams.push('temperature');\n    if (options.topP !== undefined) unsupportedParams.push('topP');\n    if (options.topK !== undefined) unsupportedParams.push('topK');\n    if (options.presencePenalty !== undefined) unsupportedParams.push('presencePenalty');\n    if (options.frequencyPenalty !== undefined) unsupportedParams.push('frequencyPenalty');\n    if (options.stopSequences !== undefined && options.stopSequences.length > 0)\n      unsupportedParams.push('stopSequences');\n    if (options.seed !== undefined) unsupportedParams.push('seed');\n\n    if (unsupportedParams.length > 0) {\n      // Add a warning for each unsupported parameter\n      for (const param of unsupportedParams) {\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: param as\n            | 'temperature'\n            | 'maxTokens'\n            | 'topP'\n            | 'topK'\n            | 'presencePenalty'\n            | 'frequencyPenalty'\n            | 'stopSequences'\n            | 'seed',\n          details: `Claude Code SDK does not support the ${param} parameter. It will be ignored.`,\n        });\n      }\n    }\n\n    // Add model validation warning if present\n    if (this.modelValidationWarning) {\n      warnings.push({\n        type: 'other',\n        message: this.modelValidationWarning,\n      });\n    }\n\n    // Add settings validation warnings\n    this.settingsValidationWarnings.forEach((warning) => {\n      warnings.push({\n        type: 'other',\n        message: warning,\n      });\n    });\n\n    // Warn if JSON response format is requested without a schema\n    // Claude Code only supports structured outputs with schemas (like Anthropic's API)\n    if (options.responseFormat?.type === 'json' && !options.responseFormat.schema) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details:\n          'JSON response format requires a schema for the Claude Code provider. The JSON responseFormat is ignored and the call is treated as plain text.',\n      });\n    }\n\n    // Validate prompt\n    const promptWarning = validatePrompt(prompt);\n    if (promptWarning) {\n      warnings.push({\n        type: 'other',\n        message: promptWarning,\n      });\n    }\n\n    return warnings;\n  }\n\n  /**\n   * Converts AI SDK ToolSet to a single MCP server named 'ai-sdk'.\n   * This matches the pattern used in aider-desk where multiple tools\n   * are combined into one local MCP server.\n   *\n   * @param toolSet - ToolSet with execute functions from settings.aiSdkTools\n   * @returns MCP server configuration with all tools, or undefined if no tools\n   */\n  private convertToolSetToMcpServer(\n    toolSet?: ToolSet\n  ): Record<string, McpServerConfig> | undefined {\n    if (!toolSet || Object.keys(toolSet).length === 0) {\n      return undefined;\n    }\n\n    const sdkTools = Object.entries(toolSet).map(([name, aiTool]) => {\n      const inputSchema = aiTool.inputSchema;\n\n      // Extract Zod raw shape from input schema (handles both Zod 3 and Zod 4)\n      const inputShape =\n        'def' in inputSchema && inputSchema.def !== null && typeof inputSchema.def === 'object' && 'shape' in inputSchema.def\n          ? inputSchema.def.shape as ZodRawShape\n          : 'shape' in inputSchema\n            ? inputSchema.shape as ZodRawShape\n            : inputSchema;\n\n      // Create a tool handler that executes the AI SDK tool\n      const handler = async (\n        args: Record<string, unknown>,\n        extra: unknown\n      ): Promise<MinimalCallToolResult> => {\n        this.logger.debug(\n          `[claude-code] AI SDK tool executed: ${name} ${JSON.stringify({ args, extra })}`\n        );\n        if (!aiTool.execute) {\n          return {\n            content: [{ type: 'text', text: `Tool ${name} has no execute function` }],\n          };\n        }\n\n        try {\n          const result = await aiTool.execute(args, {\n            toolCallId: (extra as { _meta?: Record<string, unknown> })._meta?.['claudecode/toolUseId'] as string || '',\n            messages: [], // TODO: keep track of messages and pass them in\n          });\n          return {\n            content: [{ type: 'text', text: JSON.stringify(result) }],\n          };\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          return {\n            content: [{ type: 'text', text: `Error: ${errorMessage}` }],\n          };\n        }\n      };\n\n      return tool(\n        name,\n        aiTool.description || '',\n        inputShape as ZodRawShape,\n        handler\n      );\n    });\n\n    // Create a single MCP server with all tools\n    const mcpServer = createSdkMcpServer({\n      name: 'ai-sdk',\n      tools: sdkTools,\n    });\n\n    return { 'ai-sdk': mcpServer };\n  }\n\n  private createQueryOptions(\n    abortController: AbortController,\n    responseFormat?: Parameters<LanguageModelV2['doGenerate']>[0]['responseFormat'],\n    stderrCollector?: (data: string) => void,\n    sdkOptions?: Partial<Options>,\n    effectiveResume?: string\n  ): Options {\n    const combinedMcpServers = {\n      ...this.settings.mcpServers,\n      ...this.convertToolSetToMcpServer(this.settings.aiSdkTools),\n    };\n\n    const opts: Partial<Options> & Record<string, unknown> = {\n      model: this.getModel(),\n      abortController,\n      resume: effectiveResume ?? this.settings.resume ?? this.sessionId,\n      pathToClaudeCodeExecutable: this.settings.pathToClaudeCodeExecutable,\n      maxTurns: this.settings.maxTurns,\n      maxThinkingTokens: this.settings.maxThinkingTokens,\n      cwd: this.settings.cwd,\n      executable: this.settings.executable,\n      executableArgs: this.settings.executableArgs,\n      permissionMode: this.settings.permissionMode,\n      permissionPromptToolName: this.settings.permissionPromptToolName,\n      continue: this.settings.continue,\n      allowedTools: this.settings.allowedTools,\n      disallowedTools: this.settings.disallowedTools,\n      betas: this.settings.betas,\n      allowDangerouslySkipPermissions: this.settings.allowDangerouslySkipPermissions,\n      enableFileCheckpointing: this.settings.enableFileCheckpointing,\n      maxBudgetUsd: this.settings.maxBudgetUsd,\n      plugins: this.settings.plugins,\n      resumeSessionAt: this.settings.resumeSessionAt,\n      sandbox: this.settings.sandbox,\n      tools: this.settings.tools,\n      mcpServers: Object.keys(combinedMcpServers).length > 0 ? combinedMcpServers : undefined,\n      canUseTool: this.settings.canUseTool,\n    };\n    // NEW: Agent SDK options with legacy mapping\n    if (this.settings.systemPrompt !== undefined) {\n      opts.systemPrompt = this.settings.systemPrompt;\n    } else if (this.settings.customSystemPrompt !== undefined) {\n      // Deprecation warning for legacy field\n      this.logger.warn(\n        \"[claude-code] 'customSystemPrompt' is deprecated and will be removed in a future major release. Please use 'systemPrompt' instead (string or { type: 'preset', preset: 'claude_code', append? }).\"\n      );\n      opts.systemPrompt = this.settings.customSystemPrompt;\n    } else if (this.settings.appendSystemPrompt !== undefined) {\n      // Deprecation warning for legacy field\n      this.logger.warn(\n        \"[claude-code] 'appendSystemPrompt' is deprecated and will be removed in a future major release. Please use 'systemPrompt: { type: 'preset', preset: 'claude_code', append: <text> }' instead.\"\n      );\n      opts.systemPrompt = {\n        type: 'preset',\n        preset: 'claude_code',\n        append: this.settings.appendSystemPrompt,\n      } as const;\n    }\n    if (this.settings.settingSources !== undefined) {\n      opts.settingSources = this.settings.settingSources;\n    }\n    if (this.settings.additionalDirectories !== undefined) {\n      opts.additionalDirectories = this.settings.additionalDirectories;\n    }\n    if (this.settings.agents !== undefined) {\n      opts.agents = this.settings.agents;\n    }\n    if (this.settings.includePartialMessages !== undefined) {\n      opts.includePartialMessages = this.settings.includePartialMessages;\n    }\n    if (this.settings.fallbackModel !== undefined) {\n      opts.fallbackModel = this.settings.fallbackModel;\n    }\n    if (this.settings.forkSession !== undefined) {\n      opts.forkSession = this.settings.forkSession;\n    }\n    if (this.settings.strictMcpConfig !== undefined) {\n      opts.strictMcpConfig = this.settings.strictMcpConfig;\n    }\n    if (this.settings.extraArgs !== undefined) {\n      opts.extraArgs = this.settings.extraArgs;\n    }\n    // hooks is supported in newer SDKs; include it if provided\n    if (this.settings.hooks) {\n      opts.hooks = this.settings.hooks;\n    }\n\n    const sdkOverrides = sdkOptions\n      ? (sdkOptions as Partial<Options> & Record<string, unknown>)\n      : undefined;\n    const sdkEnv =\n      sdkOverrides && typeof sdkOverrides.env === 'object' && sdkOverrides.env !== null\n        ? (sdkOverrides.env as Record<string, string | undefined>)\n        : undefined;\n    const sdkStderr =\n      sdkOverrides && typeof sdkOverrides.stderr === 'function'\n        ? (sdkOverrides.stderr as (data: string) => void)\n        : undefined;\n    if (sdkOverrides) {\n      const rest = { ...sdkOverrides };\n      delete rest.env;\n      delete rest.stderr;\n      Object.assign(opts, rest);\n    }\n\n    // Wrap stderr callback to also collect data for error reporting\n    const userStderrCallback = sdkStderr ?? this.settings.stderr;\n    if (stderrCollector || userStderrCallback) {\n      opts.stderr = (data: string) => {\n        if (stderrCollector) stderrCollector(data);\n        if (userStderrCallback) userStderrCallback(data);\n      };\n    }\n\n    if (this.settings.env !== undefined || sdkEnv !== undefined) {\n      opts.env = { ...process.env, ...this.settings.env, ...sdkEnv };\n    }\n\n    // Native structured outputs (SDK 0.1.45+)\n    if (responseFormat?.type === 'json' && responseFormat.schema) {\n      opts.outputFormat = {\n        type: 'json_schema',\n        schema: responseFormat.schema as Record<string, unknown>,\n      };\n    }\n\n    return opts as Options;\n  }\n\n  private handleClaudeCodeError(\n    error: unknown,\n    messagesPrompt: string,\n    collectedStderr?: string\n  ): APICallError | LoadAPIKeyError {\n    // Handle AbortError from the SDK\n    if (isAbortError(error)) {\n      // Return the abort reason if available, otherwise the error itself\n      throw error;\n    }\n\n    // Type guard for error with properties\n    const isErrorWithMessage = (err: unknown): err is { message?: string } => {\n      return typeof err === 'object' && err !== null && 'message' in err;\n    };\n\n    const isErrorWithCode = (\n      err: unknown\n    ): err is { code?: string; exitCode?: number; stderr?: string } => {\n      return typeof err === 'object' && err !== null;\n    };\n\n    // Check for authentication errors with improved detection\n    const authErrorPatterns = [\n      'not logged in',\n      'authentication',\n      'unauthorized',\n      'auth failed',\n      'please login',\n      'claude login',\n    ];\n\n    const errorMessage =\n      isErrorWithMessage(error) && error.message ? error.message.toLowerCase() : '';\n\n    const exitCode =\n      isErrorWithCode(error) && typeof error.exitCode === 'number' ? error.exitCode : undefined;\n\n    const isAuthError =\n      authErrorPatterns.some((pattern) => errorMessage.includes(pattern)) || exitCode === 401;\n\n    if (isAuthError) {\n      return createAuthenticationError({\n        message:\n          isErrorWithMessage(error) && error.message\n            ? error.message\n            : 'Authentication failed. Please ensure Claude Code SDK is properly authenticated.',\n      });\n    }\n\n    // Check for timeout errors\n    const errorCode = isErrorWithCode(error) && typeof error.code === 'string' ? error.code : '';\n\n    if (errorCode === 'ETIMEDOUT' || errorMessage.includes('timeout')) {\n      return createTimeoutError({\n        message: isErrorWithMessage(error) && error.message ? error.message : 'Request timed out',\n        promptExcerpt: messagesPrompt.substring(0, 200),\n        // Don't specify timeoutMs since we don't know the actual timeout value\n        // It's controlled by the consumer via AbortSignal\n      });\n    }\n\n    // Create general API call error with appropriate retry flag\n    const isRetryable =\n      errorCode === 'ENOENT' ||\n      errorCode === 'ECONNREFUSED' ||\n      errorCode === 'ETIMEDOUT' ||\n      errorCode === 'ECONNRESET';\n\n    // Use error.stderr if available from SDK, otherwise use collected stderr\n    const stderrFromError =\n      isErrorWithCode(error) && typeof error.stderr === 'string' ? error.stderr : undefined;\n    const stderr = stderrFromError || collectedStderr || undefined;\n\n    return createAPICallError({\n      message: isErrorWithMessage(error) && error.message ? error.message : 'Claude Code SDK error',\n      code: errorCode || undefined,\n      exitCode: exitCode,\n      stderr,\n      promptExcerpt: messagesPrompt.substring(0, 200),\n      isRetryable,\n    });\n  }\n\n  private setSessionId(sessionId: string): void {\n    this.sessionId = sessionId;\n    const warning = validateSessionId(sessionId);\n    if (warning) {\n      this.logger.warn(`Claude Code Session: ${warning}`);\n    }\n  }\n\n  /**\n   * Strips the 'mcp__ai-sdk__' prefix from AI SDK tool names.\n   * This allows AI SDK to match tool names correctly.\n   *\n   * @param name - The tool name (may include the 'mcp__ai-sdk__' prefix)\n   * @returns The tool name with the prefix removed, or the original name if no prefix\n   */\n  private normalizeToolName(name: string): string {\n    return name.startsWith('mcp__ai-sdk__')\n      ? name.slice('mcp__ai-sdk__'.length)\n      : name;\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV2['doGenerate']>[0]\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>> {\n    this.logger.debug(`[claude-code] Starting doGenerate request with model: ${this.modelId}`);\n    this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? 'none'}`);\n\n    const sdkOptions = this.getSanitizedSdkOptions();\n    const effectiveResume = this.getEffectiveResume(sdkOptions);\n    const {\n      messagesPrompt,\n      warnings: messageWarnings,\n      streamingContentParts,\n      hasImageParts,\n    } = convertToClaudeCodeMessages(options.prompt, effectiveResume);\n\n    this.logger.debug(\n      `[claude-code] Converted ${options.prompt.length} messages, hasImageParts: ${hasImageParts}`\n    );\n\n    const abortController = new AbortController();\n    let abortListener: (() => void) | undefined;\n    if (options.abortSignal?.aborted) {\n      // Propagate already-aborted state immediately with original reason\n      abortController.abort(options.abortSignal.reason);\n    } else if (options.abortSignal) {\n      abortListener = () => abortController.abort(options.abortSignal?.reason);\n      options.abortSignal.addEventListener('abort', abortListener, { once: true });\n    }\n\n    // Collect stderr for error reporting (SDK may not include it in errors)\n    let collectedStderr = '';\n    const stderrCollector = (data: string) => {\n      collectedStderr += data;\n    };\n\n    const queryOptions = this.createQueryOptions(\n      abortController,\n      options.responseFormat,\n      stderrCollector,\n      sdkOptions,\n      effectiveResume\n    );\n\n    let text = '';\n    let structuredOutput: unknown | undefined;\n    let usage: LanguageModelV2Usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n    let finishReason: LanguageModelV2FinishReason = 'stop';\n    let wasTruncated = false;\n    let costUsd: number | undefined;\n    let durationMs: number | undefined;\n    let rawUsage: unknown | undefined;\n    const warnings: LanguageModelV2CallWarning[] = this.generateAllWarnings(\n      options,\n      messagesPrompt\n    );\n\n    // Add warnings from message conversion\n    if (messageWarnings) {\n      messageWarnings.forEach((warning) => {\n        warnings.push({\n          type: 'other',\n          message: warning,\n        });\n      });\n    }\n\n    const modeSetting = this.settings.streamingInput ?? 'auto';\n    const effectiveCanUseTool = sdkOptions?.canUseTool ?? this.settings.canUseTool;\n    const effectivePermissionPromptToolName =\n      sdkOptions?.permissionPromptToolName ?? this.settings.permissionPromptToolName;\n    const wantsStreamInput =\n      modeSetting === 'always' || (modeSetting === 'auto' && !!effectiveCanUseTool);\n\n    if (!wantsStreamInput && hasImageParts) {\n      warnings.push({\n        type: 'other',\n        message: STREAMING_FEATURE_WARNING,\n      });\n    }\n\n    let done = () => {};\n    const outputStreamEnded = new Promise((resolve) => {\n      done = () => resolve(undefined);\n    });\n    try {\n      if (effectiveCanUseTool && effectivePermissionPromptToolName) {\n        throw new Error(\n          \"canUseTool requires streamingInput mode ('auto' or 'always') and cannot be used with permissionPromptToolName (SDK constraint). Set streamingInput: 'auto' (or 'always') and remove permissionPromptToolName, or remove canUseTool.\"\n        );\n      }\n      // hold input stream open until results\n      // see: https://github.com/anthropics/claude-code/issues/4775\n      const sdkPrompt = wantsStreamInput\n        ? toAsyncIterablePrompt(\n            messagesPrompt,\n            outputStreamEnded,\n            effectiveResume,\n            streamingContentParts\n          )\n        : messagesPrompt;\n\n      this.logger.debug(\n        `[claude-code] Executing query with streamingInput: ${wantsStreamInput}, session: ${effectiveResume ?? 'new'}`\n      );\n\n      const response = query({\n        prompt: sdkPrompt,\n        options: queryOptions,\n      });\n\n      for await (const message of response) {\n        this.logger.debug(`[claude-code] Received message type: ${message.type}`);\n        if (message.type === 'assistant') {\n          text += message.message.content\n            .map((c: { type: string; text?: string }) => (c.type === 'text' ? c.text : ''))\n            .join('');\n        } else if (message.type === 'result') {\n          done();\n          this.setSessionId(message.session_id);\n          costUsd = message.total_cost_usd;\n          durationMs = message.duration_ms;\n\n          // Handle structured output errors (SDK 0.1.45+)\n          // Use string comparison to support new SDK subtypes not yet in TypeScript definitions\n          if ((message.subtype as string) === 'error_max_structured_output_retries') {\n            throw new Error(\n              'Failed to generate valid structured output after maximum retries. The model could not produce a response matching the required schema.'\n            );\n          }\n\n          // Capture structured output if available (SDK 0.1.45+)\n          if ('structured_output' in message && message.structured_output !== undefined) {\n            structuredOutput = message.structured_output;\n            this.logger.debug('[claude-code] Received structured output from SDK');\n          }\n\n          this.logger.info(\n            `[claude-code] Request completed - Session: ${message.session_id}, Cost: $${costUsd?.toFixed(4) ?? 'N/A'}, Duration: ${durationMs ?? 'N/A'}ms`\n          );\n\n          if ('usage' in message) {\n            rawUsage = message.usage;\n            usage = {\n              inputTokens:\n                (message.usage.cache_creation_input_tokens ?? 0) +\n                (message.usage.cache_read_input_tokens ?? 0) +\n                (message.usage.input_tokens ?? 0),\n              outputTokens: message.usage.output_tokens ?? 0,\n              totalTokens:\n                (message.usage.cache_creation_input_tokens ?? 0) +\n                (message.usage.cache_read_input_tokens ?? 0) +\n                (message.usage.input_tokens ?? 0) +\n                (message.usage.output_tokens ?? 0),\n            };\n\n            this.logger.debug(\n              `[claude-code] Token usage - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`\n            );\n          }\n\n          finishReason = mapClaudeCodeFinishReason(message.subtype);\n          this.logger.debug(`[claude-code] Finish reason: ${finishReason}`);\n        } else if (message.type === 'system' && message.subtype === 'init') {\n          this.setSessionId(message.session_id);\n          this.logger.info(`[claude-code] Session initialized: ${message.session_id}`);\n        }\n      }\n    } catch (error: unknown) {\n      done();\n      this.logger.debug(\n        `[claude-code] Error during doGenerate: ${error instanceof Error ? error.message : String(error)}`\n      );\n\n      // Special handling for AbortError to preserve abort signal reason\n      if (isAbortError(error)) {\n        this.logger.debug('[claude-code] Request aborted by user');\n        throw options.abortSignal?.aborted ? options.abortSignal.reason : error;\n      }\n\n      if (isClaudeCodeTruncationError(error, text)) {\n        this.logger.warn(\n          `[claude-code] Detected truncated response, returning ${text.length} characters of buffered text`\n        );\n        wasTruncated = true;\n        finishReason = 'length';\n        warnings.push({\n          type: 'other',\n          message: CLAUDE_CODE_TRUNCATION_WARNING,\n        });\n      } else {\n        // Use unified error handler\n        throw this.handleClaudeCodeError(error, messagesPrompt, collectedStderr);\n      }\n    } finally {\n      if (options.abortSignal && abortListener) {\n        options.abortSignal.removeEventListener('abort', abortListener);\n      }\n    }\n\n    // Use structured output from SDK if available (native JSON schema support)\n    // Otherwise fall back to accumulated text\n    const finalText = structuredOutput !== undefined ? JSON.stringify(structuredOutput) : text;\n\n    return {\n      content: [{ type: 'text', text: finalText }],\n      usage,\n      finishReason,\n      warnings,\n      response: {\n        id: generateId(),\n        timestamp: new Date(),\n        modelId: this.modelId,\n      },\n      request: {\n        body: messagesPrompt,\n      },\n      providerMetadata: {\n        'claude-code': {\n          ...(this.sessionId !== undefined && { sessionId: this.sessionId }),\n          ...(costUsd !== undefined && { costUsd }),\n          ...(durationMs !== undefined && { durationMs }),\n          ...(rawUsage !== undefined && { rawUsage: rawUsage as JSONValue }),\n          ...(wasTruncated && { truncated: true }),\n        },\n      },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV2['doStream']>[0]\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>> {\n    this.logger.debug(`[claude-code] Starting doStream request with model: ${this.modelId}`);\n    this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? 'none'}`);\n\n    const sdkOptions = this.getSanitizedSdkOptions();\n    const effectiveResume = this.getEffectiveResume(sdkOptions);\n    this.logger.debug(`[claude-code] Prompt: ${JSON.stringify(options.prompt)}`);\n    const {\n      messagesPrompt,\n      warnings: messageWarnings,\n      streamingContentParts,\n      hasImageParts,\n    } = convertToClaudeCodeMessages(options.prompt, effectiveResume);\n\n    this.logger.debug(\n      `[claude-code] Converted ${options.prompt.length} messages for streaming, hasImageParts: ${hasImageParts}`\n    );\n\n    const abortController = new AbortController();\n    let abortListener: (() => void) | undefined;\n    if (options.abortSignal?.aborted) {\n      // Propagate already-aborted state immediately with original reason\n      abortController.abort(options.abortSignal.reason);\n    } else if (options.abortSignal) {\n      abortListener = () => abortController.abort(options.abortSignal?.reason);\n      options.abortSignal.addEventListener('abort', abortListener, { once: true });\n    }\n\n    // Collect stderr for error reporting (SDK may not include it in errors)\n    let collectedStderr = '';\n    const stderrCollector = (data: string) => {\n      collectedStderr += data;\n    };\n\n    const queryOptions = this.createQueryOptions(\n      abortController,\n      options.responseFormat,\n      stderrCollector,\n      sdkOptions,\n      effectiveResume\n    );\n\n    // Enable partial messages for true streaming (token-by-token delivery)\n    // This can be overridden by user settings, but we default to true for doStream\n    if (queryOptions.includePartialMessages === undefined) {\n      queryOptions.includePartialMessages = true;\n    }\n\n    const warnings: LanguageModelV2CallWarning[] = this.generateAllWarnings(\n      options,\n      messagesPrompt\n    );\n\n    // Add warnings from message conversion\n    if (messageWarnings) {\n      messageWarnings.forEach((warning) => {\n        warnings.push({\n          type: 'other',\n          message: warning,\n        });\n      });\n    }\n\n    const modeSetting = this.settings.streamingInput ?? 'auto';\n    const effectiveCanUseTool = sdkOptions?.canUseTool ?? this.settings.canUseTool;\n    const effectivePermissionPromptToolName =\n      sdkOptions?.permissionPromptToolName ?? this.settings.permissionPromptToolName;\n    const wantsStreamInput =\n      modeSetting === 'always' || (modeSetting === 'auto' && !!effectiveCanUseTool);\n\n    if (!wantsStreamInput && hasImageParts) {\n      warnings.push({\n        type: 'other',\n        message: STREAMING_FEATURE_WARNING,\n      });\n    }\n\n    const stream = new ReadableStream<ExtendedStreamPart>({\n      start: async (controller) => {\n        let done = () => {};\n        const outputStreamEnded = new Promise((resolve) => {\n          done = () => resolve(undefined);\n        });\n        const toolStates = new Map<string, ToolStreamState>();\n        const streamWarnings: LanguageModelV2CallWarning[] = [];\n\n        const closeToolInput = (toolId: string, state: ToolStreamState) => {\n          if (!state.inputClosed && state.inputStarted) {\n            controller.enqueue({\n              type: 'tool-input-end',\n              id: toolId,\n            });\n            state.inputClosed = true;\n          }\n        };\n\n        const emitToolCall = (toolId: string, state: ToolStreamState) => {\n          if (state.callEmitted) {\n            return;\n          }\n\n          closeToolInput(toolId, state);\n\n          const toolName = this.normalizeToolName(state.name);\n\n          controller.enqueue({\n            type: 'tool-call',\n            toolCallId: toolId,\n            toolName,\n            input: state.lastSerializedInput ?? '',\n            providerExecuted: true,\n            dynamic: true, // V3 field: indicates tool is provider-defined (not in user's tools map)\n            providerMetadata: {\n              'claude-code': {\n                // rawInput preserves the original serialized format before AI SDK normalization.\n                // Use this if you need the exact string sent to the Claude CLI, which may differ\n                // from the `input` field after AI SDK processing.\n                rawInput: state.lastSerializedInput ?? '',\n              },\n            },\n          } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n          state.callEmitted = true;\n        };\n\n        const finalizeToolCalls = () => {\n          for (const [toolId, state] of toolStates) {\n            emitToolCall(toolId, state);\n          }\n          toolStates.clear();\n        };\n\n        let usage: LanguageModelV2Usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n        let lastMessageRawUsage: unknown | undefined = undefined;\n        let accumulatedText = '';\n        let textPartId: string | undefined;\n        let streamedTextLength = 0; // Track text already emitted via stream_events to avoid duplication\n        let hasReceivedStreamEvents = false; // Track if we've received any stream_events\n\n        try {\n          // Emit stream-start with warnings\n          controller.enqueue({ type: 'stream-start', warnings });\n\n          if (effectiveCanUseTool && effectivePermissionPromptToolName) {\n            throw new Error(\n              \"canUseTool requires streamingInput mode ('auto' or 'always') and cannot be used with permissionPromptToolName (SDK constraint). Set streamingInput: 'auto' (or 'always') and remove permissionPromptToolName, or remove canUseTool.\"\n            );\n          }\n          // hold input stream open until results\n          // see: https://github.com/anthropics/claude-code/issues/4775\n          const sdkPrompt = wantsStreamInput\n            ? toAsyncIterablePrompt(\n                messagesPrompt,\n                outputStreamEnded,\n                effectiveResume,\n                streamingContentParts\n              )\n            : messagesPrompt;\n\n          this.logger.debug(\n            `[claude-code] Starting stream query with streamingInput: ${wantsStreamInput}, session: ${effectiveResume ?? 'new'}`\n          );\n\n          const response = query({\n            prompt: sdkPrompt,\n            options: queryOptions,\n          });\n\n          for await (const message of response) {\n            this.logger.debug(`[claude-code] Stream received message type: ${message.type}`);\n\n            // Handle streaming events (token-by-token delivery via includePartialMessages)\n            if (message.type === 'stream_event') {\n              const streamEvent = message as SDKPartialAssistantMessage;\n              const event = streamEvent.event;\n              this.logger.debug(`[claude-code] Stream event: ${event.type}`);\n\n              // Check for text_delta events within content_block_delta\n              if (\n                event.type === 'content_block_delta' &&\n                event.delta.type === 'text_delta' &&\n                'text' in event.delta &&\n                event.delta.text\n              ) {\n                const deltaText = event.delta.text;\n                hasReceivedStreamEvents = true;\n\n                // Don't emit text deltas in JSON mode - accumulate instead\n                if (options.responseFormat?.type === 'json') {\n                  accumulatedText += deltaText;\n                  streamedTextLength += deltaText.length;\n                  continue;\n                }\n\n                // Emit text-start if this is the first text\n                if (!textPartId) {\n                  textPartId = generateId();\n                  controller.enqueue({\n                    type: 'text-start',\n                    id: textPartId,\n                  });\n                }\n\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: textPartId,\n                  delta: deltaText,\n                });\n                accumulatedText += deltaText;\n                streamedTextLength += deltaText.length;\n              }\n              // Handle input_json_delta events for structured output streaming\n              // The SDK uses a StructuredOutput tool internally, and JSON is streamed via input_json_delta\n              if (\n                event.type === 'content_block_delta' &&\n                event.delta.type === 'input_json_delta' &&\n                'partial_json' in event.delta &&\n                event.delta.partial_json\n              ) {\n                const jsonDelta = event.delta.partial_json;\n                hasReceivedStreamEvents = true;\n\n                // Only emit in JSON mode - this enables streamObject() to receive partial updates\n                if (options.responseFormat?.type === 'json') {\n                  // Emit text-start if this is the first JSON delta\n                  if (!textPartId) {\n                    textPartId = generateId();\n                    controller.enqueue({\n                      type: 'text-start',\n                      id: textPartId,\n                    });\n                  }\n\n                  controller.enqueue({\n                    type: 'text-delta',\n                    id: textPartId,\n                    delta: jsonDelta,\n                  });\n                  accumulatedText += jsonDelta;\n                  streamedTextLength += jsonDelta.length;\n                }\n                // In non-JSON mode, input_json_delta is ignored (it's internal tool use)\n              }\n\n              // Other stream_event types (content_block_start, content_block_stop, etc.)\n              // are informational and don't need to be forwarded to the AI SDK stream\n              continue;\n            }\n\n            if (message.type === 'assistant') {\n              if (!message.message?.content) {\n                this.logger.warn(\n                  `[claude-code] Unexpected assistant message structure: missing content field. Message type: ${message.type}. This may indicate an SDK protocol violation.`\n                );\n                continue;\n              }\n\n              if ('usage' in message.message) {\n                this.logger.debug(\n                  `[claude-code] Assistant message usage: ${JSON.stringify(message.message.usage)}`\n                );\n                lastMessageRawUsage = message.message.usage;\n              }\n\n              const content = message.message.content;\n\n              for (const tool of this.extractToolUses(content)) {\n                const toolId = tool.id;\n                let state = toolStates.get(toolId);\n                if (!state) {\n                  state = {\n                    name: tool.name,\n                    inputStarted: false,\n                    inputClosed: false,\n                    callEmitted: false,\n                  };\n                  toolStates.set(toolId, state);\n                  this.logger.debug(\n                    `[claude-code] New tool use detected - Tool: ${tool.name}, ID: ${toolId}`\n                  );\n                }\n\n                state.name = tool.name;\n\n                if (!state.inputStarted) {\n                  this.logger.debug(\n                    `[claude-code] Tool input started - Tool: ${tool.name}, ID: ${toolId}`\n                  );\n                  controller.enqueue({\n                    type: 'tool-input-start',\n                    id: toolId,\n                    toolName: this.normalizeToolName(tool.name),\n                    providerExecuted: true,\n                    dynamic: true, // V3 field: indicates tool is provider-defined\n                  } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n                  state.inputStarted = true;\n                }\n\n                const serializedInput = this.serializeToolInput(tool.input);\n                if (serializedInput) {\n                  let deltaPayload = '';\n\n                  // First input: emit full delta only if small enough\n                  if (state.lastSerializedInput === undefined) {\n                    if (serializedInput.length <= ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE) {\n                      deltaPayload = serializedInput;\n                    }\n                  } else if (\n                    serializedInput.length <= ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE &&\n                    state.lastSerializedInput.length <=\n                      ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE &&\n                    serializedInput.startsWith(state.lastSerializedInput)\n                  ) {\n                    deltaPayload = serializedInput.slice(state.lastSerializedInput.length);\n                  } else if (serializedInput !== state.lastSerializedInput) {\n                    // Non-prefix updates or large inputs - defer to the final tool-call payload\n                    deltaPayload = '';\n                  }\n\n                  if (deltaPayload) {\n                    controller.enqueue({\n                      type: 'tool-input-delta',\n                      id: toolId,\n                      delta: deltaPayload,\n                    });\n                  }\n                  state.lastSerializedInput = serializedInput;\n                }\n              }\n\n              const text = content\n                .map((c: { type: string; text?: string }) => (c.type === 'text' ? c.text : ''))\n                .join('');\n\n              if (text) {\n                // When we've received stream_events, assistant messages contain cumulative text\n                // that we've already emitted via stream_event deltas - skip duplicates\n                // When no stream_events received, assistant messages contain incremental text\n                if (hasReceivedStreamEvents) {\n                  // Calculate delta: only emit text that wasn't already streamed via stream_events\n                  const newTextStart = streamedTextLength;\n                  const deltaText = text.length > newTextStart ? text.slice(newTextStart) : '';\n\n                  // Always accumulate for final result tracking\n                  accumulatedText = text; // Replace with full text (assistant msg contains full content)\n\n                  // In JSON mode, we accumulate the text and extract JSON at the end\n                  // Otherwise, stream any new text\n                  if (options.responseFormat?.type !== 'json' && deltaText) {\n                    // Emit text-start if this is the first text\n                    if (!textPartId) {\n                      textPartId = generateId();\n                      controller.enqueue({\n                        type: 'text-start',\n                        id: textPartId,\n                      });\n                    }\n\n                    controller.enqueue({\n                      type: 'text-delta',\n                      id: textPartId,\n                      delta: deltaText,\n                    });\n                  }\n\n                  // Update streamedTextLength to match what we now know is the full text\n                  streamedTextLength = text.length;\n                } else {\n                  // No stream_events - assistant messages contain incremental text chunks\n                  accumulatedText += text;\n\n                  // In JSON mode, we accumulate the text and extract JSON at the end\n                  // Otherwise, stream the text as it comes\n                  if (options.responseFormat?.type !== 'json') {\n                    // Emit text-start if this is the first text\n                    if (!textPartId) {\n                      textPartId = generateId();\n                      controller.enqueue({\n                        type: 'text-start',\n                        id: textPartId,\n                      });\n                    }\n\n                    controller.enqueue({\n                      type: 'text-delta',\n                      id: textPartId,\n                      delta: text,\n                    });\n                  }\n                }\n              }\n\n              if (textPartId) {\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n                textPartId = undefined;\n                accumulatedText = '';\n                streamedTextLength = 0;\n              }\n            } else if (message.type === 'user') {\n              if (!message.message?.content) {\n                this.logger.warn(\n                  `[claude-code] Unexpected user message structure: missing content field. Message type: ${message.type}. This may indicate an SDK protocol violation.`\n                );\n                continue;\n              }\n\n              // A user message with tool results signals the end of the current assistant message.\n              // Reset text state to ensure the next assistant message starts with a new text part.\n              // This prevents text from different assistant messages from being merged together.\n              if (textPartId) {\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n\n                });\n                textPartId = undefined;\n                accumulatedText = '';\n                streamedTextLength = 0;\n                this.logger.debug('[claude-code] Closed text part due to user message with tool results');\n              }\n\n              this.logger.debug(`[claude-code] Received user message: ${JSON.stringify(message.message)}`);\n\n              if ('usage' in message.message) {\n                this.logger.debug(`[claude-code] User message usage: ${JSON.stringify(message.message.usage)}`);\n                lastMessageRawUsage = message.message.usage;\n              }\n\n              const content = message.message.content;\n              for (const result of this.extractToolResults(content)) {\n                let state = toolStates.get(result.id);\n                const rawToolName =\n                  result.name ?? state?.name ?? ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;\n                const toolName = this.normalizeToolName(rawToolName);\n\n                this.logger.debug(\n                  `[claude-code] Tool result received - Tool: ${toolName}, ID: ${result.id}`\n                );\n\n                if (!state) {\n                  this.logger.warn(\n                    `[claude-code] Received tool result for unknown tool ID: ${result.id}`\n                  );\n                  state = {\n                    name: toolName,\n                    inputStarted: false,\n                    inputClosed: false,\n                    callEmitted: false,\n                  };\n                  toolStates.set(result.id, state);\n                  // Synthesize input lifecycle to preserve ordering when no prior tool_use was seen\n                  if (!state.inputStarted) {\n                    controller.enqueue({\n                      type: 'tool-input-start',\n                      id: result.id,\n                      toolName,\n                      providerExecuted: true,\n                      dynamic: true, // V3 field: indicates tool is provider-defined\n                    } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n                    state.inputStarted = true;\n                  }\n                  if (!state.inputClosed) {\n                    controller.enqueue({\n                      type: 'tool-input-end',\n                      id: result.id,\n                    });\n                    state.inputClosed = true;\n                  }\n                }\n                state.name = toolName;\n                const normalizedResult = this.normalizeToolResult(rawToolName, result.result);\n                const rawResult =\n                  typeof result.result === 'string'\n                    ? result.result\n                    : (() => {\n                        try {\n                          return JSON.stringify(result.result);\n                        } catch {\n                          return String(result.result);\n                        }\n                      })();\n\n                emitToolCall(result.id, state);\n\n                controller.enqueue({\n                  type: 'tool-result',\n                  toolCallId: result.id,\n                  toolName,\n                  result: normalizedResult,\n                  isError: result.isError,\n                  providerExecuted: true,\n                  dynamic: true, // V3 field: indicates tool is provider-defined\n                  providerMetadata: {\n                    'claude-code': {\n                      // rawResult preserves the original CLI output string before JSON parsing.\n                      // Use this when you need the exact string returned by the tool, especially\n                      // if the `result` field has been parsed/normalized and you need the original format.\n                      rawResult,\n                    },\n                  },\n                } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n              }\n              // Handle tool errors\n              for (const error of this.extractToolErrors(content)) {\n                let state = toolStates.get(error.id);\n                const rawToolName =\n                  error.name ?? state?.name ?? ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;\n                const toolName = this.normalizeToolName(rawToolName);\n\n                this.logger.debug(\n                  `[claude-code] Tool error received - Tool: ${toolName}, ID: ${error.id}`\n                );\n\n                if (!state) {\n                  this.logger.warn(\n                    `[claude-code] Received tool error for unknown tool ID: ${error.id}`\n                  );\n                  state = {\n                    name: toolName,\n                    inputStarted: true,\n                    inputClosed: true,\n                    callEmitted: false,\n                  };\n                  toolStates.set(error.id, state);\n                }\n\n                // Ensure tool-call is emitted before tool-error\n                emitToolCall(error.id, state);\n\n                const rawError =\n                  typeof error.error === 'string'\n                    ? error.error\n                    : typeof error.error === 'object' && error.error !== null\n                      ? (() => {\n                          try {\n                            return JSON.stringify(error.error);\n                          } catch {\n                            return String(error.error);\n                          }\n                        })()\n                      : String(error.error);\n\n                controller.enqueue({\n                  type: 'tool-error',\n                  toolCallId: error.id,\n                  toolName,\n                  error: rawError,\n                  providerExecuted: true,\n                  dynamic: true, // V3 field: indicates tool is provider-defined\n                  providerMetadata: {\n                    'claude-code': {\n                      rawError,\n                    },\n                  },\n                } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n              }\n            } else if (message.type === 'result') {\n              done();\n\n              // Handle structured output errors (SDK 0.1.45+)\n              // Use string comparison to support new SDK subtypes not yet in TypeScript definitions\n              if ((message.subtype as string) === 'error_max_structured_output_retries') {\n                throw new Error(\n                  'Failed to generate valid structured output after maximum retries. The model could not produce a response matching the required schema.'\n                );\n              }\n\n              this.logger.info(\n                `[claude-code] Stream completed - Session: ${message.session_id}, Cost: $${message.total_cost_usd?.toFixed(4) ?? 'N/A'}, Duration: ${message.duration_ms ?? 'N/A'}ms`\n              );\n\n              this.logger.debug(`[claude-code] ModelUsage: ${JSON.stringify(message.modelUsage)}`);\n\n              let rawUsage: unknown | undefined;\n              if ('usage' in message) {\n                rawUsage = message.usage;\n                usage = {\n                  inputTokens:\n                    (message.usage.cache_creation_input_tokens ?? 0) +\n                    (message.usage.cache_read_input_tokens ?? 0) +\n                    (message.usage.input_tokens ?? 0),\n                  outputTokens: message.usage.output_tokens ?? 0,\n                  totalTokens:\n                    (message.usage.cache_creation_input_tokens ?? 0) +\n                    (message.usage.cache_read_input_tokens ?? 0) +\n                    (message.usage.input_tokens ?? 0) +\n                    (message.usage.output_tokens ?? 0),\n                };\n\n                this.logger.debug(\n                  `[claude-code] Stream token usage - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`\n                );\n              }\n\n              const finishReason: LanguageModelV2FinishReason = mapClaudeCodeFinishReason(\n                message.subtype\n              );\n\n              this.logger.debug(`[claude-code] Stream finish reason: ${finishReason}`);\n\n              // Store session ID in the model instance\n              this.setSessionId(message.session_id);\n\n              // Use structured output from SDK if available (native JSON schema support)\n              const structuredOutput =\n                'structured_output' in message ? message.structured_output : undefined;\n\n              // Check if we've already streamed JSON via input_json_delta\n              const alreadyStreamedJson =\n                textPartId && options.responseFormat?.type === 'json' && hasReceivedStreamEvents;\n\n              if (alreadyStreamedJson && textPartId) {\n                // We've already streamed JSON deltas, just close the text part\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n              } else if (structuredOutput !== undefined) {\n                // Emit structured output as text (fallback when streaming didn't occur)\n                const jsonTextId = generateId();\n                const jsonText = JSON.stringify(structuredOutput);\n                controller.enqueue({\n                  type: 'text-start',\n                  id: jsonTextId,\n                });\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: jsonTextId,\n                  delta: jsonText,\n                });\n                controller.enqueue({\n                  type: 'text-end',\n                  id: jsonTextId,\n                });\n              } else if (textPartId) {\n                // Close the text part if it was opened (non-JSON mode)\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n              } else if (accumulatedText) {\n                // Fallback for JSON mode without schema: emit accumulated text\n                // This handles the case where responseFormat.type === 'json' but no schema\n                // was provided, so the SDK returns plain text instead of structured_output\n                const fallbackTextId = generateId();\n                controller.enqueue({\n                  type: 'text-start',\n                  id: fallbackTextId,\n                });\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: fallbackTextId,\n                  delta: accumulatedText,\n                });\n                controller.enqueue({\n                  type: 'text-end',\n                  id: fallbackTextId,\n                });\n              }\n\n              finalizeToolCalls();\n\n              // Prepare JSON-safe warnings for provider metadata\n              const warningsJson = this.serializeWarningsForMetadata(streamWarnings);\n\n              controller.enqueue({\n                type: 'finish',\n                finishReason,\n                usage,\n                providerMetadata: {\n                  'claude-code': {\n                    sessionId: message.session_id,\n                    ...(message.total_cost_usd !== undefined && {\n                      costUsd: message.total_cost_usd,\n                    }),\n                    ...(message.duration_ms !== undefined && { durationMs: message.duration_ms }),\n                    ...(rawUsage !== undefined && { rawUsage: rawUsage as JSONValue }),\n                    ...(lastMessageRawUsage !== undefined && { lastMessageRawUsage: lastMessageRawUsage as JSONValue }),\n                    // JSON validation warnings are collected during streaming and included\n                    // in providerMetadata since the AI SDK's finish event doesn't support\n                    // a top-level warnings field (unlike stream-start which was already emitted)\n                    ...(streamWarnings.length > 0 && {\n                      warnings: warningsJson as unknown as JSONValue,\n                    }),\n                  },\n                },\n              });\n            } else if (message.type === 'system' && message.subtype === 'init') {\n              // Store session ID for future use\n              this.setSessionId(message.session_id);\n\n              this.logger.info(`[claude-code] Stream session initialized: ${message.session_id}`);\n\n              // Emit response metadata when session is initialized\n              controller.enqueue({\n                type: 'response-metadata',\n                id: message.session_id,\n                timestamp: new Date(),\n                modelId: this.modelId,\n              });\n            }\n          }\n\n          finalizeToolCalls();\n          this.logger.debug('[claude-code] Stream finalized, closing stream');\n          controller.close();\n        } catch (error: unknown) {\n          done();\n\n          this.logger.debug(\n            `[claude-code] Error during doStream: ${error instanceof Error ? error.message : String(error)}`\n          );\n\n          if (isClaudeCodeTruncationError(error, accumulatedText)) {\n            this.logger.warn(\n              `[claude-code] Detected truncated stream response, returning ${accumulatedText.length} characters of buffered text`\n            );\n            const truncationWarning: LanguageModelV2CallWarning = {\n              type: 'other',\n              message: CLAUDE_CODE_TRUNCATION_WARNING,\n            };\n            streamWarnings.push(truncationWarning);\n\n            if (textPartId) {\n              controller.enqueue({\n                type: 'text-end',\n                id: textPartId,\n              });\n            } else if (accumulatedText) {\n              const fallbackTextId = generateId();\n              controller.enqueue({\n                type: 'text-start',\n                id: fallbackTextId,\n              });\n              controller.enqueue({\n                type: 'text-delta',\n                id: fallbackTextId,\n                delta: accumulatedText,\n              });\n              controller.enqueue({\n                type: 'text-end',\n                id: fallbackTextId,\n              });\n            }\n\n            finalizeToolCalls();\n\n            const warningsJson = this.serializeWarningsForMetadata(streamWarnings);\n\n            controller.enqueue({\n              type: 'finish',\n              finishReason: 'length',\n              usage,\n              providerMetadata: {\n                'claude-code': {\n                  ...(this.sessionId !== undefined && { sessionId: this.sessionId }),\n                  truncated: true,\n                  ...(streamWarnings.length > 0 && {\n                    warnings: warningsJson as unknown as JSONValue,\n                  }),\n                },\n              },\n            });\n\n            controller.close();\n            return;\n          }\n\n          finalizeToolCalls();\n          let errorToEmit: unknown;\n\n          // Special handling for AbortError to preserve abort signal reason\n          if (isAbortError(error)) {\n            errorToEmit = options.abortSignal?.aborted ? options.abortSignal.reason : error;\n          } else {\n            // Use unified error handler\n            errorToEmit = this.handleClaudeCodeError(error, messagesPrompt, collectedStderr);\n          }\n\n          // Emit error as a stream part\n          controller.enqueue({\n            type: 'error',\n            error: errorToEmit,\n          });\n\n          controller.close();\n        } finally {\n          if (options.abortSignal && abortListener) {\n            options.abortSignal.removeEventListener('abort', abortListener);\n          }\n        }\n      },\n      cancel: () => {\n        if (options.abortSignal && abortListener) {\n          options.abortSignal.removeEventListener('abort', abortListener);\n        }\n      },\n    });\n\n    return {\n      stream: stream as unknown as ReadableStream<LanguageModelV2StreamPart>,\n      request: {\n        body: messagesPrompt,\n      },\n    };\n  }\n\n  private serializeWarningsForMetadata(warnings: LanguageModelV2CallWarning[]): JSONValue {\n    const result = warnings.map((w) => {\n      const base: Record<string, string> = { type: w.type };\n      if ('message' in w) {\n        const m = (w as { message?: unknown }).message;\n        if (m !== undefined) base.message = String(m);\n      }\n      if (w.type === 'unsupported-setting') {\n        const setting = (w as { setting: unknown }).setting;\n        if (setting !== undefined) base.setting = String(setting);\n        if ('details' in w) {\n          const d = (w as { details?: unknown }).details;\n          if (d !== undefined) base.details = String(d);\n        }\n      }\n      return base;\n    });\n    return result as unknown as JSONValue;\n  }\n}\n","import type { ModelMessage } from 'ai';\nimport type { SDKUserMessage } from '@anthropic-ai/claude-agent-sdk';\n\ntype SDKUserContentPart = SDKUserMessage['message']['content'][number];\n\ninterface StreamingSegment {\n  formatted: string;\n}\n\nconst IMAGE_URL_WARNING = 'Image URLs are not supported by this provider; supply base64/data URLs.';\nconst IMAGE_CONVERSION_WARNING = 'Unable to convert image content; supply base64/data URLs.';\n\nfunction normalizeBase64(base64: string): string {\n  return base64.replace(/\\s+/g, '');\n}\n\nfunction isImageMimeType(mimeType?: string): boolean {\n  return typeof mimeType === 'string' && mimeType.trim().toLowerCase().startsWith('image/');\n}\n\nfunction createImageContent(mediaType: string, data: string): SDKUserContentPart | undefined {\n  const trimmedType = mediaType.trim();\n  const trimmedData = normalizeBase64(data.trim());\n\n  if (!trimmedType || !trimmedData) {\n    return undefined;\n  }\n\n  return {\n    type: 'image',\n    source: {\n      type: 'base64',\n      media_type: trimmedType,\n      data: trimmedData,\n    },\n  } as SDKUserContentPart;\n}\n\nfunction extractMimeType(candidate: unknown): string | undefined {\n  if (typeof candidate === 'string' && candidate.trim()) {\n    return candidate.trim();\n  }\n  return undefined;\n}\n\nfunction parseObjectImage(\n  imageObj: Record<string, unknown>,\n  fallbackMimeType?: string\n): SDKUserContentPart | undefined {\n  const data = typeof imageObj.data === 'string' ? imageObj.data : undefined;\n  const mimeType = extractMimeType(\n    imageObj.mimeType ?? imageObj.mediaType ?? imageObj.media_type ?? fallbackMimeType\n  );\n  if (!data || !mimeType) {\n    return undefined;\n  }\n  return createImageContent(mimeType, data);\n}\n\nfunction parseStringImage(\n  value: string,\n  fallbackMimeType?: string\n): { content?: SDKUserContentPart; warning?: string } {\n  const trimmed = value.trim();\n\n  if (/^https?:\\/\\//i.test(trimmed)) {\n    return { warning: IMAGE_URL_WARNING };\n  }\n\n  const dataUrlMatch = trimmed.match(/^data:([^;]+);base64,(.+)$/i);\n  if (dataUrlMatch) {\n    const [, mediaType, data] = dataUrlMatch;\n    const content = createImageContent(mediaType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  const base64Match = trimmed.match(/^base64:([^,]+),(.+)$/i);\n  if (base64Match) {\n    const [, explicitMimeType, data] = base64Match;\n    const content = createImageContent(explicitMimeType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  if (fallbackMimeType) {\n    const content = createImageContent(fallbackMimeType, trimmed);\n    if (content) {\n      return { content };\n    }\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\nfunction parseImagePart(part: unknown): { content?: SDKUserContentPart; warning?: string } {\n  if (!part || typeof part !== 'object') {\n    return { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  const imageValue = (part as { image?: unknown }).image;\n  const mimeType = extractMimeType((part as { mimeType?: unknown }).mimeType);\n\n  if (typeof imageValue === 'string') {\n    return parseStringImage(imageValue, mimeType);\n  }\n\n  if (imageValue && typeof imageValue === 'object') {\n    const content = parseObjectImage(imageValue as Record<string, unknown>, mimeType);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\nfunction convertBinaryToBase64(data: Uint8Array | ArrayBuffer): string | undefined {\n  if (typeof Buffer !== 'undefined') {\n    const buffer =\n      data instanceof Uint8Array ? Buffer.from(data) : Buffer.from(new Uint8Array(data));\n    return buffer.toString('base64');\n  }\n\n  if (typeof btoa === 'function') {\n    const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n    let binary = '';\n    const chunkSize = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunkSize) {\n      const chunk = bytes.subarray(i, i + chunkSize);\n      binary += String.fromCharCode(...chunk);\n    }\n    return btoa(binary);\n  }\n\n  return undefined;\n}\n\ntype FileLikePart = {\n  mediaType?: unknown;\n  mimeType?: unknown;\n  data?: unknown;\n};\n\nfunction parseFilePart(part: FileLikePart): { content?: SDKUserContentPart; warning?: string } {\n  const mimeType = extractMimeType(part.mediaType ?? part.mimeType);\n  if (!mimeType || !isImageMimeType(mimeType)) {\n    return {};\n  }\n\n  const data = part.data;\n  if (typeof data === 'string') {\n    const content = createImageContent(mimeType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  if (\n    data instanceof Uint8Array ||\n    (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer)\n  ) {\n    const base64 = convertBinaryToBase64(data);\n    if (!base64) {\n      return { warning: IMAGE_CONVERSION_WARNING };\n    }\n    const content = createImageContent(mimeType, base64);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\n/**\n * Converts AI SDK prompt format to Claude Code SDK message format.\n * Handles system prompts, user messages, assistant responses, and tool interactions.\n *\n * @param prompt - The AI SDK prompt containing messages\n * @param sessionId - The ID of the session to resume, if any\n * @returns An object containing the formatted message prompt and optional system prompt\n *\n * @example\n * ```typescript\n * const { messagesPrompt } = convertToClaudeCodeMessages(\n *   [{ role: 'user', content: 'Hello!' }]\n * );\n * ```\n *\n * @remarks\n * - Image parts are collected for streaming input; unsupported variants produce warnings\n * - Tool calls are simplified to \"[Tool calls made]\" notation\n * - JSON schema enforcement is handled natively by the SDK's outputFormat option (v0.1.45+)\n */\nexport function convertToClaudeCodeMessages(prompt: readonly ModelMessage[], sessionId?: string): {\n  messagesPrompt: string;\n  systemPrompt?: string;\n  warnings?: string[];\n  streamingContentParts: SDKUserMessage['message']['content'];\n  hasImageParts: boolean;\n} {\n  const messages: string[] = [];\n  const warnings: string[] = [];\n  let systemPrompt: string | undefined;\n  const streamingSegments: StreamingSegment[] = [];\n  const imageMap = new Map<number, SDKUserContentPart[]>();\n  let hasImageParts = false;\n  const lastMessage = prompt.length > 0 ? prompt[prompt.length - 1] : undefined;\n\n  const extractTextContent = (content: ModelMessage['content']): string => {\n    return typeof content === 'string'\n      ? content\n      : content.filter((part) => part.type === 'text').map((part) => part.text).join('\\n');\n  }\n\n  if (lastMessage?.role === 'user' && sessionId) {\n    // in case we are resuming a session, the last message is the one we want to continue with\n    const textContent = extractTextContent(lastMessage.content);\n    return {\n      messagesPrompt: textContent,\n      streamingContentParts: [{ type: 'text', text: textContent }],\n      hasImageParts,\n    };\n  }\n\n  const addSegment = (formatted: string): number => {\n    streamingSegments.push({ formatted });\n    return streamingSegments.length - 1;\n  };\n\n  const addImageForSegment = (segmentIndex: number, content: SDKUserContentPart): void => {\n    hasImageParts = true;\n    if (!imageMap.has(segmentIndex)) {\n      imageMap.set(segmentIndex, []);\n    }\n    imageMap.get(segmentIndex)?.push(content);\n  };\n\n  for (const message of prompt) {\n    switch (message.role) {\n      case 'system':\n        systemPrompt = message.content;\n        if (typeof message.content === 'string' && message.content.trim().length > 0) {\n          addSegment(message.content);\n        } else {\n          addSegment('');\n        }\n        break;\n\n      case 'user':\n        if (typeof message.content === 'string') {\n          messages.push(message.content);\n          addSegment(prompt.length > 1 ? `Human: ${message.content}` : message.content);\n        } else {\n          // Handle multi-part content\n          const textParts = message.content\n            .filter((part) => part.type === 'text')\n            .map((part) => part.text)\n            .join('\\n');\n\n          const segmentIndex = addSegment(textParts ? `Human: ${textParts}` : '');\n\n          if (textParts) {\n            messages.push(textParts);\n          }\n\n          for (const part of message.content) {\n            if (part.type === 'image') {\n              const { content, warning } = parseImagePart(part);\n              if (content) {\n                addImageForSegment(segmentIndex, content);\n              } else if (warning) {\n                warnings.push(warning);\n              }\n            } else if (part.type === 'file') {\n              const { content, warning } = parseFilePart(part);\n              if (content) {\n                addImageForSegment(segmentIndex, content);\n              } else if (warning) {\n                warnings.push(warning);\n              }\n            }\n          }\n        }\n        break;\n\n      case 'assistant': {\n        let assistantContent = '';\n        if (typeof message.content === 'string') {\n          assistantContent = message.content;\n        } else {\n          const textParts = message.content\n            .filter((part) => part.type === 'text')\n            .map((part) => part.text)\n            .join('\\n');\n\n          if (textParts) {\n            assistantContent = textParts;\n          }\n\n          // Handle tool calls if present\n          const toolCalls = message.content.filter((part) => part.type === 'tool-call');\n          if (toolCalls.length > 0) {\n            // For now, we'll just note that tool calls were made\n            assistantContent += `\\n[Tool calls made]`;\n          }\n        }\n        const formattedAssistant = `Assistant: ${assistantContent}`;\n        messages.push(formattedAssistant);\n        addSegment(formattedAssistant);\n        break;\n      }\n\n      case 'tool':\n        // Tool results could be included in the conversation\n        for (const tool of message.content) {\n          const resultText =\n            tool.output.type === 'text' ? tool.output.value : JSON.stringify(tool.output.value);\n          const formattedToolResult = `Tool Result (${tool.toolName}): ${resultText}`;\n          messages.push(formattedToolResult);\n          addSegment(formattedToolResult);\n        }\n        break;\n    }\n  }\n\n  // For the SDK, we need to provide a single prompt string\n  // Format the conversation history properly\n\n  // Combine system prompt with messages\n  let finalPrompt = '';\n\n  // Add system prompt at the beginning if present\n  if (systemPrompt) {\n    finalPrompt = systemPrompt;\n  }\n\n  if (messages.length > 0) {\n    // Format messages\n    const formattedMessages = [];\n    for (let i = 0; i < messages.length; i++) {\n      const msg = messages[i];\n      // Check if this is a user or assistant message based on content\n      if (msg.startsWith('Assistant:') || msg.startsWith('Tool Result')) {\n        formattedMessages.push(msg);\n      } else {\n        // User messages\n        formattedMessages.push(`Human: ${msg}`);\n      }\n    }\n\n    // Combine system prompt with messages\n    if (finalPrompt) {\n      const joinedMessages = formattedMessages.join('\\n\\n');\n      finalPrompt = joinedMessages ? `${finalPrompt}\\n\\n${joinedMessages}` : finalPrompt;\n    } else {\n      finalPrompt = formattedMessages.join('\\n\\n');\n    }\n  }\n\n  // Build streaming parts including text and images\n  const streamingParts: SDKUserContentPart[] = [];\n  const imagePartsInOrder: SDKUserContentPart[] = [];\n\n  const appendImagesForIndex = (index: number) => {\n    const images = imageMap.get(index);\n    if (!images) {\n      return;\n    }\n    images.forEach((image) => {\n      streamingParts.push(image);\n      imagePartsInOrder.push(image);\n    });\n  };\n\n  if (streamingSegments.length > 0) {\n    let accumulatedText = '';\n    let emittedText = false;\n\n    const flushText = () => {\n      if (!accumulatedText) {\n        return;\n      }\n      streamingParts.push({ type: 'text', text: accumulatedText });\n      accumulatedText = '';\n      emittedText = true;\n    };\n\n    streamingSegments.forEach((segment, index) => {\n      const segmentText = segment.formatted;\n      if (segmentText) {\n        if (!accumulatedText) {\n          accumulatedText = emittedText ? `\\n\\n${segmentText}` : segmentText;\n        } else {\n          accumulatedText += `\\n\\n${segmentText}`;\n        }\n      }\n\n      if (imageMap.has(index)) {\n        flushText();\n        appendImagesForIndex(index);\n      }\n    });\n\n    flushText();\n  }\n\n  // Note: JSON schema enforcement is now handled natively by the SDK's outputFormat option (v0.1.45+)\n  // No prompt injection needed - structured outputs are guaranteed by the SDK\n\n  return {\n    messagesPrompt: finalPrompt,\n    systemPrompt,\n    ...(warnings.length > 0 && { warnings }),\n    streamingContentParts:\n      streamingParts.length > 0\n        ? (streamingParts as SDKUserMessage['message']['content'])\n        : ([\n            { type: 'text', text: finalPrompt },\n            ...imagePartsInOrder,\n          ] as SDKUserMessage['message']['content']),\n    hasImageParts,\n  };\n}\n","import { APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\n\n/**\n * Metadata associated with Claude Code SDK errors.\n * Provides additional context about command execution failures.\n */\nexport interface ClaudeCodeErrorMetadata {\n  /**\n   * Error code from the CLI process (e.g., 'ENOENT', 'ETIMEDOUT').\n   */\n  code?: string;\n\n  /**\n   * Exit code from the Claude Code SDK process.\n   * Common codes:\n   * - 401: Authentication error\n   * - 1: General error\n   */\n  exitCode?: number;\n\n  /**\n   * Standard error output from the CLI process.\n   */\n  stderr?: string;\n\n  /**\n   * Excerpt from the prompt that caused the error.\n   * Limited to first 200 characters for debugging.\n   */\n  promptExcerpt?: string;\n}\n\n/**\n * Creates an APICallError with Claude Code specific metadata.\n * Used for general CLI execution errors.\n *\n * @param options - Error details and metadata\n * @param options.message - Human-readable error message\n * @param options.code - Error code from the CLI process\n * @param options.exitCode - Exit code from the CLI\n * @param options.stderr - Standard error output\n * @param options.promptExcerpt - Excerpt of the prompt that caused the error\n * @param options.isRetryable - Whether the error is potentially retryable\n * @returns An APICallError instance with Claude Code metadata\n *\n * @example\n * ```typescript\n * throw createAPICallError({\n *   message: 'Claude Code SDK failed',\n *   code: 'ENOENT',\n *   isRetryable: true\n * });\n * ```\n */\nexport function createAPICallError({\n  message,\n  code,\n  exitCode,\n  stderr,\n  promptExcerpt,\n  isRetryable = false,\n}: ClaudeCodeErrorMetadata & {\n  message: string;\n  isRetryable?: boolean;\n}): APICallError {\n  const metadata: ClaudeCodeErrorMetadata = {\n    code,\n    exitCode,\n    stderr,\n    promptExcerpt,\n  };\n\n  return new APICallError({\n    message,\n    isRetryable,\n    url: 'claude-code-cli://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : undefined,\n    data: metadata,\n  });\n}\n\n/**\n * Creates an authentication error for Claude Code SDK login failures.\n *\n * @param options - Error configuration\n * @param options.message - Error message describing the authentication failure\n * @returns A LoadAPIKeyError instance\n *\n * @example\n * ```typescript\n * throw createAuthenticationError({\n *   message: 'Please run \"claude login\" to authenticate'\n * });\n * ```\n */\nexport function createAuthenticationError({ message }: { message: string }): LoadAPIKeyError {\n  return new LoadAPIKeyError({\n    message:\n      message || 'Authentication failed. Please ensure Claude Code SDK is properly authenticated.',\n  });\n}\n\n/**\n * Creates a timeout error for Claude Code SDK operations.\n *\n * @param options - Timeout error details\n * @param options.message - Error message describing the timeout\n * @param options.promptExcerpt - Excerpt of the prompt that timed out\n * @param options.timeoutMs - Timeout duration in milliseconds\n * @returns An APICallError instance configured as a timeout error\n *\n * @example\n * ```typescript\n * throw createTimeoutError({\n *   message: 'Request timed out after 2 minutes',\n *   timeoutMs: 120000\n * });\n * ```\n */\nexport function createTimeoutError({\n  message,\n  promptExcerpt,\n  timeoutMs,\n}: {\n  message: string;\n  promptExcerpt?: string;\n  timeoutMs?: number;\n}): APICallError {\n  // Store timeoutMs in metadata for potential use by error handlers\n  const metadata: ClaudeCodeErrorMetadata = {\n    code: 'TIMEOUT',\n    promptExcerpt,\n  };\n\n  return new APICallError({\n    message,\n    isRetryable: true,\n    url: 'claude-code-cli://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : undefined,\n    data: timeoutMs !== undefined ? { ...metadata, timeoutMs } : metadata,\n  });\n}\n\n/**\n * Checks if an error is an authentication error.\n * Returns true for LoadAPIKeyError instances or APICallError with exit code 401.\n *\n * @param error - The error to check\n * @returns True if the error is an authentication error\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   if (isAuthenticationError(error)) {\n *     console.log('Please authenticate with Claude Code SDK');\n *   }\n * }\n * ```\n */\nexport function isAuthenticationError(error: unknown): boolean {\n  if (error instanceof LoadAPIKeyError) return true;\n  if (error instanceof APICallError && (error.data as ClaudeCodeErrorMetadata)?.exitCode === 401)\n    return true;\n  return false;\n}\n\n/**\n * Checks if an error is a timeout error.\n * Returns true for APICallError instances with code 'TIMEOUT'.\n *\n * @param error - The error to check\n * @returns True if the error is a timeout error\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   if (isTimeoutError(error)) {\n *     console.log('Request timed out, consider retrying');\n *   }\n * }\n * ```\n */\nexport function isTimeoutError(error: unknown): boolean {\n  if (error instanceof APICallError && (error.data as ClaudeCodeErrorMetadata)?.code === 'TIMEOUT')\n    return true;\n  return false;\n}\n\n/**\n * Extracts Claude Code error metadata from an error object.\n *\n * @param error - The error to extract metadata from\n * @returns The error metadata if available, undefined otherwise\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   const metadata = getErrorMetadata(error);\n *   if (metadata?.exitCode === 401) {\n *     console.log('Authentication required');\n *   }\n * }\n * ```\n */\nexport function getErrorMetadata(error: unknown): ClaudeCodeErrorMetadata | undefined {\n  if (error instanceof APICallError && error.data) {\n    return error.data as ClaudeCodeErrorMetadata;\n  }\n  return undefined;\n}\n","import type { LanguageModelV2FinishReason } from '@ai-sdk/provider';\n\n/**\n * Maps Claude Code SDK result subtypes to AI SDK finish reasons.\n *\n * @param subtype - The result subtype from Claude Code SDK\n * @returns The corresponding AI SDK finish reason\n *\n * @example\n * ```typescript\n * const finishReason = mapClaudeCodeFinishReason('error_max_turns');\n * // Returns: 'length'\n * ```\n *\n * @remarks\n * Mappings:\n * - 'success' -> 'stop' (normal completion)\n * - 'error_max_turns' -> 'length' (hit turn limit)\n * - 'error_during_execution' -> 'error' (execution error)\n * - default -> 'stop' (unknown subtypes treated as normal completion)\n */\nexport function mapClaudeCodeFinishReason(subtype?: string): LanguageModelV2FinishReason {\n  switch (subtype) {\n    case 'success':\n      return 'stop';\n    case 'error_max_turns':\n      return 'length';\n    case 'error_during_execution':\n      return 'error';\n    default:\n      return 'stop';\n  }\n}\n","import { z } from 'zod';\nimport { existsSync } from 'fs';\n\n/**\n * Validation schemas and utilities for Claude Code provider inputs.\n * Uses Zod for type-safe validation following AI SDK patterns.\n */\n\n// Helper for Zod v3/v4 compatibility\n// Use a simple z.any() for functions to work with both versions\nconst loggerFunctionSchema = z.object({\n  debug: z.any().refine((val) => typeof val === 'function', {\n    message: 'debug must be a function',\n  }),\n  info: z.any().refine((val) => typeof val === 'function', {\n    message: 'info must be a function',\n  }),\n  warn: z.any().refine((val) => typeof val === 'function', {\n    message: 'warn must be a function',\n  }),\n  error: z.any().refine((val) => typeof val === 'function', {\n    message: 'error must be a function',\n  }),\n});\n\n/**\n * Schema for validating Claude Code settings.\n * Ensures all settings are within acceptable ranges and formats.\n */\nexport const claudeCodeSettingsSchema = z\n  .object({\n    pathToClaudeCodeExecutable: z.string().optional(),\n    customSystemPrompt: z.string().optional(),\n    appendSystemPrompt: z.string().optional(),\n    systemPrompt: z\n      .union([\n        z.string(),\n        z.object({\n          type: z.literal('preset'),\n          preset: z.literal('claude_code'),\n          append: z.string().optional(),\n        }),\n      ])\n      .optional(),\n    maxTurns: z.number().int().min(1).max(100).optional(),\n    maxThinkingTokens: z.number().int().positive().max(100000).optional(),\n    cwd: z\n      .string()\n      .refine(\n        (val) => {\n          // Skip directory validation in non-Node environments\n          if (typeof process === 'undefined' || !process.versions?.node) {\n            return true;\n          }\n          return !val || existsSync(val);\n        },\n        { message: 'Working directory must exist' }\n      )\n      .optional(),\n    executable: z.enum(['bun', 'deno', 'node']).optional(),\n    executableArgs: z.array(z.string()).optional(),\n    permissionMode: z.enum(['default', 'acceptEdits', 'bypassPermissions', 'plan']).optional(),\n    permissionPromptToolName: z.string().optional(),\n    continue: z.boolean().optional(),\n    resume: z.string().optional(),\n    allowedTools: z.array(z.string()).optional(),\n    disallowedTools: z.array(z.string()).optional(),\n    betas: z.array(z.string()).optional(),\n    allowDangerouslySkipPermissions: z.boolean().optional(),\n    enableFileCheckpointing: z.boolean().optional(),\n    maxBudgetUsd: z.number().min(0).optional(),\n    plugins: z\n      .array(\n        z\n          .object({\n            type: z.string(),\n            path: z.string(),\n          })\n          .passthrough()\n      )\n      .optional(),\n    resumeSessionAt: z.string().optional(),\n    sandbox: z\n      .any()\n      .refine((val) => val === undefined || typeof val === 'object', {\n        message: 'sandbox must be an object',\n      })\n      .optional(),\n    tools: z\n      .union([\n        z.array(z.string()),\n        z.object({\n          type: z.literal('preset'),\n          preset: z.literal('claude_code'),\n        }),\n      ])\n      .optional(),\n    settingSources: z.array(z.enum(['user', 'project', 'local'])).optional(),\n    streamingInput: z.enum(['auto', 'always', 'off']).optional(),\n    // Hooks and tool-permission callback (permissive validation of shapes)\n    canUseTool: z\n      .any()\n      .refine((v) => v === undefined || typeof v === 'function', {\n        message: 'canUseTool must be a function',\n      })\n      .optional(),\n    hooks: z\n      .record(\n        z.string(),\n        z.array(\n          z.object({\n            matcher: z.string().optional(),\n            hooks: z.array(z.any()).nonempty(),\n          })\n        )\n      )\n      .optional(),\n    aiSdkTools: z\n      .record(\n        z.string(),\n        z.object({\n          description: z.string().optional(),\n          inputSchema: z.any().optional(),\n          parameters: z.any().optional(),\n          execute: z.function().optional(),\n        })\n      )\n      .optional(),\n    mcpServers: z\n      .record(\n        z.string(),\n        z.union([\n          // McpStdioServerConfig\n          z.object({\n            type: z.literal('stdio').optional(),\n            command: z.string(),\n            args: z.array(z.string()).optional(),\n            env: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpSSEServerConfig\n          z.object({\n            type: z.literal('sse'),\n            url: z.string(),\n            headers: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpHttpServerConfig\n          z.object({\n            type: z.literal('http'),\n            url: z.string(),\n            headers: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpSdkServerConfig (in-process custom tools)\n          z.object({\n            type: z.literal('sdk'),\n            name: z.string(),\n            instance: z.any(),\n          }),\n        ])\n      )\n      .optional(),\n    verbose: z.boolean().optional(),\n    logger: z.union([z.literal(false), loggerFunctionSchema]).optional(),\n    env: z.record(z.string(), z.string().optional()).optional(),\n    additionalDirectories: z.array(z.string()).optional(),\n    agents: z\n      .record(\n        z.string(),\n        z.object({\n          description: z.string(),\n          tools: z.array(z.string()).optional(),\n          prompt: z.string(),\n          model: z.enum(['sonnet', 'opus', 'haiku', 'inherit']).optional(),\n        })\n      )\n      .optional(),\n    includePartialMessages: z.boolean().optional(),\n    fallbackModel: z.string().optional(),\n    forkSession: z.boolean().optional(),\n    stderr: z\n      .any()\n      .refine((val) => val === undefined || typeof val === 'function', {\n        message: 'stderr must be a function',\n      })\n      .optional(),\n    strictMcpConfig: z.boolean().optional(),\n    extraArgs: z.record(z.string(), z.union([z.string(), z.null()])).optional(),\n    sdkOptions: z.record(z.string(), z.any()).optional(),\n  })\n  .strict();\n\n/**\n * Validates a model ID and returns warnings if needed.\n *\n * @param modelId - The model ID to validate\n * @returns Warning message if model is unknown, undefined otherwise\n */\nexport function validateModelId(modelId: string): string | undefined {\n  const knownModels = ['opus', 'sonnet', 'haiku'];\n\n  // Check for empty or whitespace-only\n  if (!modelId || modelId.trim() === '') {\n    throw new Error('Model ID cannot be empty');\n  }\n\n  // Warn about unknown models but allow them\n  if (!knownModels.includes(modelId)) {\n    return `Unknown model ID: '${modelId}'. Proceeding with custom model. Known models are: ${knownModels.join(', ')}`;\n  }\n\n  return undefined;\n}\n\n/**\n * Validates Claude Code settings and returns validation results.\n *\n * @param settings - The settings object to validate\n * @returns Object with validation results and any warnings\n */\nexport function validateSettings(settings: unknown): {\n  valid: boolean;\n  warnings: string[];\n  errors: string[];\n} {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  try {\n    // Parse with Zod schema\n    const result = claudeCodeSettingsSchema.safeParse(settings);\n\n    if (!result.success) {\n      // Extract user-friendly error messages\n      // Support both Zod v3 (errors) and v4 (issues)\n      const errorObject = result.error as {\n        errors?: Array<{ path: string[]; message: string }>;\n        issues?: Array<{ path: string[]; message: string }>;\n      };\n      const issues = errorObject.errors || errorObject.issues || [];\n      issues.forEach((err: { path: string[]; message: string }) => {\n        const path = err.path.join('.');\n        errors.push(`${path ? `${path}: ` : ''}${err.message}`);\n      });\n      return { valid: false, warnings, errors };\n    }\n\n    // Additional validation warnings\n    const validSettings = result.data;\n\n    // Warn about high turn limits\n    if (validSettings.maxTurns && validSettings.maxTurns > 20) {\n      warnings.push(\n        `High maxTurns value (${validSettings.maxTurns}) may lead to long-running conversations`\n      );\n    }\n\n    // Warn about very high thinking tokens\n    if (validSettings.maxThinkingTokens && validSettings.maxThinkingTokens > 50000) {\n      warnings.push(\n        `Very high maxThinkingTokens (${validSettings.maxThinkingTokens}) may increase response time`\n      );\n    }\n\n    // Check if both allowedTools and disallowedTools are specified\n    if (validSettings.allowedTools && validSettings.disallowedTools) {\n      warnings.push(\n        'Both allowedTools and disallowedTools are specified. Only allowedTools will be used.'\n      );\n    }\n\n    // Validate tool name format\n    const validateToolNames = (tools: string[], type: string) => {\n      tools.forEach((tool) => {\n        // Basic validation - tool names should be alphanumeric with optional specifiers\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\\([^)]*\\))?$/.test(tool) && !tool.startsWith('mcp__')) {\n          warnings.push(`Unusual ${type} tool name format: '${tool}'`);\n        }\n      });\n    };\n\n    if (validSettings.allowedTools) {\n      validateToolNames(validSettings.allowedTools, 'allowed');\n    }\n\n    if (validSettings.disallowedTools) {\n      validateToolNames(validSettings.disallowedTools, 'disallowed');\n    }\n\n    return { valid: true, warnings, errors };\n  } catch (error) {\n    errors.push(`Validation error: ${error instanceof Error ? error.message : String(error)}`);\n    return { valid: false, warnings, errors };\n  }\n}\n\n/**\n * Validates prompt length and format.\n *\n * @param prompt - The prompt to validate\n * @returns Warning message if prompt might cause issues\n */\nexport function validatePrompt(prompt: string): string | undefined {\n  // Very long prompts might cause issues\n  const MAX_PROMPT_LENGTH = 100000; // ~25k tokens\n\n  if (prompt.length > MAX_PROMPT_LENGTH) {\n    return `Very long prompt (${prompt.length} characters) may cause performance issues or timeouts`;\n  }\n\n  return undefined;\n}\n\n/**\n * Validates session ID format.\n *\n * @param sessionId - The session ID to validate\n * @returns Warning message if format is unusual\n */\nexport function validateSessionId(sessionId: string): string | undefined {\n  // Session IDs from Claude Code are typically UUID-like\n  // But we don't want to be too strict as format might change\n  if (sessionId && !/^[a-zA-Z0-9-_]+$/.test(sessionId)) {\n    return `Unusual session ID format. This may cause issues with session resumption.`;\n  }\n\n  return undefined;\n}\n","import type { Logger } from './types.js';\n\n/**\n * Default logger that uses console with level tags.\n */\nconst defaultLogger: Logger = {\n  // eslint-disable-next-line no-console\n  debug: (message: string) => console.debug(`[DEBUG] ${message}`),\n  // eslint-disable-next-line no-console\n  info: (message: string) => console.info(`[INFO] ${message}`),\n  warn: (message: string) => console.warn(`[WARN] ${message}`),\n  error: (message: string) => console.error(`[ERROR] ${message}`),\n};\n\n/**\n * No-op logger that discards all messages.\n */\nconst noopLogger: Logger = {\n  debug: () => {},\n  info: () => {},\n  warn: () => {},\n  error: () => {},\n};\n\n/**\n * Gets the appropriate logger based on configuration.\n *\n * @param logger - Logger configuration from settings\n * @returns The logger to use\n */\nexport function getLogger(logger: Logger | false | undefined): Logger {\n  if (logger === false) {\n    return noopLogger;\n  }\n\n  if (logger === undefined) {\n    return defaultLogger;\n  }\n\n  return logger;\n}\n\n/**\n * Creates a verbose-aware logger that only logs debug/info when verbose is enabled.\n * Warn and error are always logged regardless of verbose setting.\n *\n * @param logger - Base logger to wrap\n * @param verbose - Whether to enable verbose (debug/info) logging\n * @returns Logger with verbose-aware behavior\n */\nexport function createVerboseLogger(logger: Logger, verbose: boolean = false): Logger {\n  if (verbose) {\n    // When verbose is enabled, use all log levels\n    return logger;\n  }\n\n  // When verbose is disabled, only allow warn/error\n  // Bind methods to preserve 'this' context for custom loggers\n  return {\n    debug: () => {}, // No-op when not verbose\n    info: () => {}, // No-op when not verbose\n    warn: logger.warn.bind(logger),\n    error: logger.error.bind(logger),\n  };\n}\n","import { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';\nimport type { McpSdkServerConfigWithInstance } from '@anthropic-ai/claude-agent-sdk';\nimport { type ZodRawShape, type ZodObject } from 'zod';\n\n/**\n * Optional annotations for content items, per MCP specification.\n * Validated against MCP SDK schema version 2025-06-18.\n */\ntype ContentAnnotations = {\n  /** Intended audience(s) for this content */\n  audience?: ('user' | 'assistant')[];\n  /** Priority hint (0 = least important, 1 = most important) */\n  priority?: number;\n  /** ISO 8601 timestamp of last modification */\n  lastModified?: string;\n};\n\n/**\n * Convenience helper to create an SDK MCP server from a simple tool map.\n * Each tool provides a description, a Zod object schema, and a handler.\n *\n * Type definition validated against MCP SDK specification version 2025-06-18.\n * See: https://modelcontextprotocol.io/specification/2025-06-18/server/tools\n */\nexport type MinimalCallToolResult = {\n  content: Array<\n    | {\n        /** Text content */\n        type: 'text';\n        /** The text content (plain text or structured format like JSON) */\n        text: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Image content (base64-encoded) */\n        type: 'image';\n        /** Base64-encoded image data */\n        data: string;\n        /** MIME type of the image (e.g., image/png, image/jpeg) */\n        mimeType: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Audio content (base64-encoded) */\n        type: 'audio';\n        /** Base64-encoded audio data */\n        data: string;\n        /** MIME type of the audio (e.g., audio/wav, audio/mp3) */\n        mimeType: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Embedded resource with full content (text or blob) */\n        type: 'resource';\n        /** Resource contents - either text or blob variant */\n        resource: { uri: string; _meta?: Record<string, unknown>; [key: string]: unknown } & (\n          | { text: string; mimeType?: string }\n          | { blob: string; mimeType: string }\n        );\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Resource link (reference only - no embedded content) */\n        type: 'resource_link';\n        /** URI of the resource */\n        uri: string;\n        /** Human-readable name (required per MCP spec) */\n        name: string;\n        /** Optional description of what this resource represents */\n        description?: string;\n        /** MIME type of the resource, if known */\n        mimeType?: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n  >;\n  isError?: boolean;\n  structuredContent?: Record<string, unknown>;\n  _meta?: Record<string, unknown>;\n  [key: string]: unknown;\n};\n\nexport function createCustomMcpServer<\n  Tools extends Record<\n    string,\n    {\n      description: string;\n      inputSchema: ZodObject<ZodRawShape>;\n      handler: (args: Record<string, unknown>, extra: unknown) => Promise<MinimalCallToolResult>;\n    }\n  >,\n>(config: { name: string; version?: string; tools: Tools }): McpSdkServerConfigWithInstance {\n  const defs = Object.entries(config.tools).map(([name, def]) =>\n    tool(\n      name,\n      def.description,\n      def.inputSchema.shape as ZodRawShape,\n      (args: Record<string, unknown>, extra: unknown) => def.handler(args, extra)\n    )\n  );\n  return createSdkMcpServer({ name: config.name, version: config.version, tools: defs });\n}\n"],"mappings":"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","names":["import_provider","import_provider","tool","tool","import_zod","content","tool","import_claude_agent_sdk","import_claude_agent_sdk","import_zod"]}
\ No newline at end of file
diff --git a/node_modules/ai-sdk-provider-claude-code/dist/index.d.cts b/node_modules/ai-sdk-provider-claude-code/dist/index.d.cts
index da6fb11..b878b1b 100644
--- a/node_modules/ai-sdk-provider-claude-code/dist/index.d.cts
+++ b/node_modules/ai-sdk-provider-claude-code/dist/index.d.cts
@@ -1,6 +1,7 @@
 import { LanguageModelV2, ProviderV2, APICallError, LoadAPIKeyError } from '@ai-sdk/provider';
 import { PermissionMode, SdkBeta, SdkPluginConfig, SandboxSettings, Options, McpServerConfig, CanUseTool, McpSdkServerConfigWithInstance } from '@anthropic-ai/claude-agent-sdk';
 export { CanUseTool, HookCallback, HookCallbackMatcher, HookEvent, HookInput, HookJSONOutput, McpSdkServerConfigWithInstance, McpServerConfig, OutputFormat, PermissionBehavior, PermissionResult, PermissionRuleValue, PermissionUpdate, PostToolUseHookInput, PreToolUseHookInput, SessionEndHookInput, SessionStartHookInput, UserPromptSubmitHookInput, createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';
+import { ToolSet } from 'ai';
 import { ZodObject, ZodRawShape } from 'zod';
 
 type StreamingInputMode = 'auto' | 'always' | 'off';
@@ -163,6 +164,34 @@ interface ClaudeCodeSettings {
      * MCP server configuration
      */
     mcpServers?: Record<string, McpServerConfig>;
+    /**
+     * AI SDK ToolSet to automatically convert to MCP servers.
+     * Accepts AI SDK tool definitions with execute functions and creates
+     * an in-process MCP server named 'ai-sdk'.
+     *
+     * Tools will be available as `mcp__ai-sdk__<toolName>` in the CLI.
+     * Tool names are automatically stripped of this prefix when emitting tool-call
+     * events to the AI SDK so it can match tools correctly.
+     *
+     * @example
+     * ```typescript
+     * import { z } from 'zod';
+     *
+     * const provider = createClaudeCode({
+     *   defaultSettings: {
+     *     aiSdkTools: {
+     *       add: {
+     *         description: 'Add two numbers',
+     *         parameters: z.object({ a: z.number(), b: z.number() }),
+     *         execute: async ({ a, b }) => ({ result: a + b }),
+     *       },
+     *     },
+     *     allowedTools: ['mcp__ai-sdk__add'],
+     *   },
+     * });
+     * ```
+     */
+    aiSdkTools?: ToolSet;
     /**
      * Filesystem settings sources to load (CLAUDE.md, settings.json, etc.)
      * When omitted, the Agent SDK loads no filesystem settings.
@@ -365,9 +394,26 @@ declare class ClaudeCodeLanguageModel implements LanguageModelV2 {
     private checkInputSize;
     private normalizeToolResult;
     private generateAllWarnings;
+    /**
+     * Converts AI SDK ToolSet to a single MCP server named 'ai-sdk'.
+     * This matches the pattern used in aider-desk where multiple tools
+     * are combined into one local MCP server.
+     *
+     * @param toolSet - ToolSet with execute functions from settings.aiSdkTools
+     * @returns MCP server configuration with all tools, or undefined if no tools
+     */
+    private convertToolSetToMcpServer;
     private createQueryOptions;
     private handleClaudeCodeError;
     private setSessionId;
+    /**
+     * Strips the 'mcp__ai-sdk__' prefix from AI SDK tool names.
+     * This allows AI SDK to match tool names correctly.
+     *
+     * @param name - The tool name (may include the 'mcp__ai-sdk__' prefix)
+     * @returns The tool name with the prefix removed, or the original name if no prefix
+     */
+    private normalizeToolName;
     doGenerate(options: Parameters<LanguageModelV2['doGenerate']>[0]): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>>;
     doStream(options: Parameters<LanguageModelV2['doStream']>[0]): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>>;
     private serializeWarningsForMetadata;
diff --git a/node_modules/ai-sdk-provider-claude-code/dist/index.d.ts b/node_modules/ai-sdk-provider-claude-code/dist/index.d.ts
index da6fb11..b878b1b 100644
--- a/node_modules/ai-sdk-provider-claude-code/dist/index.d.ts
+++ b/node_modules/ai-sdk-provider-claude-code/dist/index.d.ts
@@ -1,6 +1,7 @@
 import { LanguageModelV2, ProviderV2, APICallError, LoadAPIKeyError } from '@ai-sdk/provider';
 import { PermissionMode, SdkBeta, SdkPluginConfig, SandboxSettings, Options, McpServerConfig, CanUseTool, McpSdkServerConfigWithInstance } from '@anthropic-ai/claude-agent-sdk';
 export { CanUseTool, HookCallback, HookCallbackMatcher, HookEvent, HookInput, HookJSONOutput, McpSdkServerConfigWithInstance, McpServerConfig, OutputFormat, PermissionBehavior, PermissionResult, PermissionRuleValue, PermissionUpdate, PostToolUseHookInput, PreToolUseHookInput, SessionEndHookInput, SessionStartHookInput, UserPromptSubmitHookInput, createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';
+import { ToolSet } from 'ai';
 import { ZodObject, ZodRawShape } from 'zod';
 
 type StreamingInputMode = 'auto' | 'always' | 'off';
@@ -163,6 +164,34 @@ interface ClaudeCodeSettings {
      * MCP server configuration
      */
     mcpServers?: Record<string, McpServerConfig>;
+    /**
+     * AI SDK ToolSet to automatically convert to MCP servers.
+     * Accepts AI SDK tool definitions with execute functions and creates
+     * an in-process MCP server named 'ai-sdk'.
+     *
+     * Tools will be available as `mcp__ai-sdk__<toolName>` in the CLI.
+     * Tool names are automatically stripped of this prefix when emitting tool-call
+     * events to the AI SDK so it can match tools correctly.
+     *
+     * @example
+     * ```typescript
+     * import { z } from 'zod';
+     *
+     * const provider = createClaudeCode({
+     *   defaultSettings: {
+     *     aiSdkTools: {
+     *       add: {
+     *         description: 'Add two numbers',
+     *         parameters: z.object({ a: z.number(), b: z.number() }),
+     *         execute: async ({ a, b }) => ({ result: a + b }),
+     *       },
+     *     },
+     *     allowedTools: ['mcp__ai-sdk__add'],
+     *   },
+     * });
+     * ```
+     */
+    aiSdkTools?: ToolSet;
     /**
      * Filesystem settings sources to load (CLAUDE.md, settings.json, etc.)
      * When omitted, the Agent SDK loads no filesystem settings.
@@ -365,9 +394,26 @@ declare class ClaudeCodeLanguageModel implements LanguageModelV2 {
     private checkInputSize;
     private normalizeToolResult;
     private generateAllWarnings;
+    /**
+     * Converts AI SDK ToolSet to a single MCP server named 'ai-sdk'.
+     * This matches the pattern used in aider-desk where multiple tools
+     * are combined into one local MCP server.
+     *
+     * @param toolSet - ToolSet with execute functions from settings.aiSdkTools
+     * @returns MCP server configuration with all tools, or undefined if no tools
+     */
+    private convertToolSetToMcpServer;
     private createQueryOptions;
     private handleClaudeCodeError;
     private setSessionId;
+    /**
+     * Strips the 'mcp__ai-sdk__' prefix from AI SDK tool names.
+     * This allows AI SDK to match tool names correctly.
+     *
+     * @param name - The tool name (may include the 'mcp__ai-sdk__' prefix)
+     * @returns The tool name with the prefix removed, or the original name if no prefix
+     */
+    private normalizeToolName;
     doGenerate(options: Parameters<LanguageModelV2['doGenerate']>[0]): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>>;
     doStream(options: Parameters<LanguageModelV2['doStream']>[0]): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>>;
     private serializeWarningsForMetadata;
diff --git a/node_modules/ai-sdk-provider-claude-code/dist/index.js b/node_modules/ai-sdk-provider-claude-code/dist/index.js
index 525facb..5d5a577 100644
--- a/node_modules/ai-sdk-provider-claude-code/dist/index.js
+++ b/node_modules/ai-sdk-provider-claude-code/dist/index.js
@@ -122,13 +122,25 @@ function parseFilePart(part) {
   }
   return { warning: IMAGE_CONVERSION_WARNING };
 }
-function convertToClaudeCodeMessages(prompt) {
+function convertToClaudeCodeMessages(prompt, sessionId) {
   const messages = [];
   const warnings = [];
   let systemPrompt;
   const streamingSegments = [];
   const imageMap = /* @__PURE__ */ new Map();
   let hasImageParts = false;
+  const lastMessage = prompt.length > 0 ? prompt[prompt.length - 1] : void 0;
+  const extractTextContent = (content) => {
+    return typeof content === "string" ? content : content.filter((part) => part.type === "text").map((part) => part.text).join("\n");
+  };
+  if (lastMessage?.role === "user" && sessionId) {
+    const textContent = extractTextContent(lastMessage.content);
+    return {
+      messagesPrompt: textContent,
+      streamingContentParts: [{ type: "text", text: textContent }],
+      hasImageParts
+    };
+  }
   const addSegment = (formatted) => {
     streamingSegments.push({ formatted });
     return streamingSegments.length - 1;
@@ -153,7 +165,7 @@ function convertToClaudeCodeMessages(prompt) {
       case "user":
         if (typeof message.content === "string") {
           messages.push(message.content);
-          addSegment(`Human: ${message.content}`);
+          addSegment(prompt.length > 1 ? `Human: ${message.content}` : message.content);
         } else {
           const textParts = message.content.filter((part) => part.type === "text").map((part) => part.text).join("\n");
           const segmentIndex = addSegment(textParts ? `Human: ${textParts}` : "");
@@ -200,9 +212,9 @@ function convertToClaudeCodeMessages(prompt) {
         break;
       }
       case "tool":
-        for (const tool3 of message.content) {
-          const resultText = tool3.output.type === "text" ? tool3.output.value : JSON.stringify(tool3.output.value);
-          const formattedToolResult = `Tool Result (${tool3.toolName}): ${resultText}`;
+        for (const tool4 of message.content) {
+          const resultText = tool4.output.type === "text" ? tool4.output.value : JSON.stringify(tool4.output.value);
+          const formattedToolResult = `Tool Result (${tool4.toolName}): ${resultText}`;
           messages.push(formattedToolResult);
           addSegment(formattedToolResult);
         }
@@ -449,6 +461,15 @@ var claudeCodeSettingsSchema = z.object({
       })
     )
   ).optional(),
+  aiSdkTools: z.record(
+    z.string(),
+    z.object({
+      description: z.string().optional(),
+      inputSchema: z.any().optional(),
+      parameters: z.any().optional(),
+      execute: z.function().optional()
+    })
+  ).optional(),
   mcpServers: z.record(
     z.string(),
     z.union([
@@ -543,9 +564,9 @@ function validateSettings(settings) {
       );
     }
     const validateToolNames = (tools, type) => {
-      tools.forEach((tool3) => {
-        if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\([^)]*\))?$/.test(tool3) && !tool3.startsWith("mcp__")) {
-          warnings.push(`Unusual ${type} tool name format: '${tool3}'`);
+      tools.forEach((tool4) => {
+        if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\([^)]*\))?$/.test(tool4) && !tool4.startsWith("mcp__")) {
+          warnings.push(`Unusual ${type} tool name format: '${tool4}'`);
         }
       });
     };
@@ -620,7 +641,12 @@ function createVerboseLogger(logger, verbose = false) {
 }
 
 // src/claude-code-language-model.ts
-import { query } from "@anthropic-ai/claude-agent-sdk";
+import {
+  query,
+  createSdkMcpServer,
+  tool
+} from "@anthropic-ai/claude-agent-sdk";
+import "zod";
 var CLAUDE_CODE_TRUNCATION_WARNING = "Claude Code SDK output ended unexpectedly; returning truncated response from buffered text. Await upstream fix to avoid data loss.";
 var MIN_TRUNCATION_LENGTH = 512;
 function isClaudeCodeTruncationError(error, bufferedText) {
@@ -824,7 +850,10 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
     }
     return str;
   }
-  normalizeToolResult(result) {
+  normalizeToolResult(toolName, result) {
+    if (toolName.startsWith("mcp__ai-sdk__") && Array.isArray(result) && result.length === 1 && "text" in result[0]) {
+      return JSON.parse(result[0].text);
+    }
     if (typeof result === "string") {
       try {
         return JSON.parse(result);
@@ -882,7 +911,64 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
     }
     return warnings;
   }
+  /**
+   * Converts AI SDK ToolSet to a single MCP server named 'ai-sdk'.
+   * This matches the pattern used in aider-desk where multiple tools
+   * are combined into one local MCP server.
+   *
+   * @param toolSet - ToolSet with execute functions from settings.aiSdkTools
+   * @returns MCP server configuration with all tools, or undefined if no tools
+   */
+  convertToolSetToMcpServer(toolSet) {
+    if (!toolSet || Object.keys(toolSet).length === 0) {
+      return void 0;
+    }
+    const sdkTools = Object.entries(toolSet).map(([name, aiTool]) => {
+      const inputSchema = aiTool.inputSchema;
+      const inputShape = "def" in inputSchema && inputSchema.def !== null && typeof inputSchema.def === "object" && "shape" in inputSchema.def ? inputSchema.def.shape : "shape" in inputSchema ? inputSchema.shape : inputSchema;
+      const handler = async (args, extra) => {
+        this.logger.debug(
+          `[claude-code] AI SDK tool executed: ${name} ${JSON.stringify({ args, extra })}`
+        );
+        if (!aiTool.execute) {
+          return {
+            content: [{ type: "text", text: `Tool ${name} has no execute function` }]
+          };
+        }
+        try {
+          const result = await aiTool.execute(args, {
+            toolCallId: extra._meta?.["claudecode/toolUseId"] || "",
+            messages: []
+            // TODO: keep track of messages and pass them in
+          });
+          return {
+            content: [{ type: "text", text: JSON.stringify(result) }]
+          };
+        } catch (error) {
+          const errorMessage = error instanceof Error ? error.message : String(error);
+          return {
+            content: [{ type: "text", text: `Error: ${errorMessage}` }]
+          };
+        }
+      };
+      return tool(
+        name,
+        aiTool.description || "",
+        inputShape,
+        handler
+      );
+    });
+    const mcpServer = createSdkMcpServer({
+      name: "ai-sdk",
+      tools: sdkTools
+    });
+    return { "ai-sdk": mcpServer };
+  }
   createQueryOptions(abortController, responseFormat, stderrCollector, sdkOptions, effectiveResume) {
+    const combinedMcpServers = {
+      ...this.settings.mcpServers,
+      ...this.convertToolSetToMcpServer(this.settings.aiSdkTools)
+    };
     const opts = {
       model: this.getModel(),
       abortController,
@@ -906,7 +992,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
       resumeSessionAt: this.settings.resumeSessionAt,
       sandbox: this.settings.sandbox,
       tools: this.settings.tools,
-      mcpServers: this.settings.mcpServers,
+      mcpServers: Object.keys(combinedMcpServers).length > 0 ? combinedMcpServers : void 0,
       canUseTool: this.settings.canUseTool
     };
     if (this.settings.systemPrompt !== void 0) {
@@ -1034,15 +1120,27 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
       this.logger.warn(`Claude Code Session: ${warning}`);
     }
   }
+  /**
+   * Strips the 'mcp__ai-sdk__' prefix from AI SDK tool names.
+   * This allows AI SDK to match tool names correctly.
+   *
+   * @param name - The tool name (may include the 'mcp__ai-sdk__' prefix)
+   * @returns The tool name with the prefix removed, or the original name if no prefix
+   */
+  normalizeToolName(name) {
+    return name.startsWith("mcp__ai-sdk__") ? name.slice("mcp__ai-sdk__".length) : name;
+  }
   async doGenerate(options) {
     this.logger.debug(`[claude-code] Starting doGenerate request with model: ${this.modelId}`);
     this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? "none"}`);
+    const sdkOptions = this.getSanitizedSdkOptions();
+    const effectiveResume = this.getEffectiveResume(sdkOptions);
     const {
       messagesPrompt,
       warnings: messageWarnings,
       streamingContentParts,
       hasImageParts
-    } = convertToClaudeCodeMessages(options.prompt);
+    } = convertToClaudeCodeMessages(options.prompt, effectiveResume);
     this.logger.debug(
       `[claude-code] Converted ${options.prompt.length} messages, hasImageParts: ${hasImageParts}`
     );
@@ -1058,8 +1156,6 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
     const stderrCollector = (data) => {
       collectedStderr += data;
     };
-    const sdkOptions = this.getSanitizedSdkOptions();
-    const effectiveResume = this.getEffectiveResume(sdkOptions);
     const queryOptions = this.createQueryOptions(
       abortController,
       options.responseFormat,
@@ -1215,12 +1311,15 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
   async doStream(options) {
     this.logger.debug(`[claude-code] Starting doStream request with model: ${this.modelId}`);
     this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? "none"}`);
+    const sdkOptions = this.getSanitizedSdkOptions();
+    const effectiveResume = this.getEffectiveResume(sdkOptions);
+    this.logger.debug(`[claude-code] Prompt: ${JSON.stringify(options.prompt)}`);
     const {
       messagesPrompt,
       warnings: messageWarnings,
       streamingContentParts,
       hasImageParts
-    } = convertToClaudeCodeMessages(options.prompt);
+    } = convertToClaudeCodeMessages(options.prompt, effectiveResume);
     this.logger.debug(
       `[claude-code] Converted ${options.prompt.length} messages for streaming, hasImageParts: ${hasImageParts}`
     );
@@ -1236,8 +1335,6 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
     const stderrCollector = (data) => {
       collectedStderr += data;
     };
-    const sdkOptions = this.getSanitizedSdkOptions();
-    const effectiveResume = this.getEffectiveResume(sdkOptions);
     const queryOptions = this.createQueryOptions(
       abortController,
       options.responseFormat,
@@ -1293,10 +1390,11 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
             return;
           }
           closeToolInput(toolId, state);
+          const toolName = this.normalizeToolName(state.name);
           controller.enqueue({
             type: "tool-call",
             toolCallId: toolId,
-            toolName: state.name,
+            toolName,
             input: state.lastSerializedInput ?? "",
             providerExecuted: true,
             dynamic: true,
@@ -1319,6 +1417,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
           toolStates.clear();
         };
         let usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };
+        let lastMessageRawUsage = void 0;
         let accumulatedText = "";
         let textPartId;
         let streamedTextLength = 0;
@@ -1348,6 +1447,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
             if (message.type === "stream_event") {
               const streamEvent = message;
               const event = streamEvent.event;
+              this.logger.debug(`[claude-code] Stream event: ${event.type}`);
               if (event.type === "content_block_delta" && event.delta.type === "text_delta" && "text" in event.delta && event.delta.text) {
                 const deltaText = event.delta.text;
                 hasReceivedStreamEvents = true;
@@ -1400,38 +1500,44 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                 );
                 continue;
               }
+              if ("usage" in message.message) {
+                this.logger.debug(
+                  `[claude-code] Assistant message usage: ${JSON.stringify(message.message.usage)}`
+                );
+                lastMessageRawUsage = message.message.usage;
+              }
               const content = message.message.content;
-              for (const tool3 of this.extractToolUses(content)) {
-                const toolId = tool3.id;
+              for (const tool4 of this.extractToolUses(content)) {
+                const toolId = tool4.id;
                 let state = toolStates.get(toolId);
                 if (!state) {
                   state = {
-                    name: tool3.name,
+                    name: tool4.name,
                     inputStarted: false,
                     inputClosed: false,
                     callEmitted: false
                   };
                   toolStates.set(toolId, state);
                   this.logger.debug(
-                    `[claude-code] New tool use detected - Tool: ${tool3.name}, ID: ${toolId}`
+                    `[claude-code] New tool use detected - Tool: ${tool4.name}, ID: ${toolId}`
                   );
                 }
-                state.name = tool3.name;
+                state.name = tool4.name;
                 if (!state.inputStarted) {
                   this.logger.debug(
-                    `[claude-code] Tool input started - Tool: ${tool3.name}, ID: ${toolId}`
+                    `[claude-code] Tool input started - Tool: ${tool4.name}, ID: ${toolId}`
                   );
                   controller.enqueue({
                     type: "tool-input-start",
                     id: toolId,
-                    toolName: tool3.name,
+                    toolName: this.normalizeToolName(tool4.name),
                     providerExecuted: true,
                     dynamic: true
                     // V3 field: indicates tool is provider-defined
                   });
                   state.inputStarted = true;
                 }
-                const serializedInput = this.serializeToolInput(tool3.input);
+                const serializedInput = this.serializeToolInput(tool4.input);
                 if (serializedInput) {
                   let deltaPayload = "";
                   if (state.lastSerializedInput === void 0) {
@@ -1492,6 +1598,15 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                   }
                 }
               }
+              if (textPartId) {
+                controller.enqueue({
+                  type: "text-end",
+                  id: textPartId
+                });
+                textPartId = void 0;
+                accumulatedText = "";
+                streamedTextLength = 0;
+              }
             } else if (message.type === "user") {
               if (!message.message?.content) {
                 this.logger.warn(
@@ -1499,10 +1614,26 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                 );
                 continue;
               }
+              if (textPartId) {
+                controller.enqueue({
+                  type: "text-end",
+                  id: textPartId
+                });
+                textPartId = void 0;
+                accumulatedText = "";
+                streamedTextLength = 0;
+                this.logger.debug("[claude-code] Closed text part due to user message with tool results");
+              }
+              this.logger.debug(`[claude-code] Received user message: ${JSON.stringify(message.message)}`);
+              if ("usage" in message.message) {
+                this.logger.debug(`[claude-code] User message usage: ${JSON.stringify(message.message.usage)}`);
+                lastMessageRawUsage = message.message.usage;
+              }
               const content = message.message.content;
               for (const result of this.extractToolResults(content)) {
                 let state = toolStates.get(result.id);
-                const toolName = result.name ?? state?.name ?? _ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;
+                const rawToolName = result.name ?? state?.name ?? _ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;
+                const toolName = this.normalizeToolName(rawToolName);
                 this.logger.debug(
                   `[claude-code] Tool result received - Tool: ${toolName}, ID: ${result.id}`
                 );
@@ -1537,7 +1668,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                   }
                 }
                 state.name = toolName;
-                const normalizedResult = this.normalizeToolResult(result.result);
+                const normalizedResult = this.normalizeToolResult(rawToolName, result.result);
                 const rawResult = typeof result.result === "string" ? result.result : (() => {
                   try {
                     return JSON.stringify(result.result);
@@ -1567,7 +1698,8 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
               }
               for (const error of this.extractToolErrors(content)) {
                 let state = toolStates.get(error.id);
-                const toolName = error.name ?? state?.name ?? _ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;
+                const rawToolName = error.name ?? state?.name ?? _ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;
+                const toolName = this.normalizeToolName(rawToolName);
                 this.logger.debug(
                   `[claude-code] Tool error received - Tool: ${toolName}, ID: ${error.id}`
                 );
@@ -1616,6 +1748,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
               this.logger.info(
                 `[claude-code] Stream completed - Session: ${message.session_id}, Cost: $${message.total_cost_usd?.toFixed(4) ?? "N/A"}, Duration: ${message.duration_ms ?? "N/A"}ms`
               );
+              this.logger.debug(`[claude-code] ModelUsage: ${JSON.stringify(message.modelUsage)}`);
               let rawUsage;
               if ("usage" in message) {
                 rawUsage = message.usage;
@@ -1691,6 +1824,7 @@ var ClaudeCodeLanguageModel = class _ClaudeCodeLanguageModel {
                     },
                     ...message.duration_ms !== void 0 && { durationMs: message.duration_ms },
                     ...rawUsage !== void 0 && { rawUsage },
+                    ...lastMessageRawUsage !== void 0 && { lastMessageRawUsage },
                     // JSON validation warnings are collected during streaming and included
                     // in providerMetadata since the AI SDK's finish event doesn't support
                     // a top-level warnings field (unlike stream-start which was already emitted)
@@ -1872,21 +2006,21 @@ function createClaudeCode(options = {}) {
 var claudeCode = createClaudeCode();
 
 // src/index.ts
-import { createSdkMcpServer as createSdkMcpServer2, tool as tool2 } from "@anthropic-ai/claude-agent-sdk";
+import { createSdkMcpServer as createSdkMcpServer3, tool as tool3 } from "@anthropic-ai/claude-agent-sdk";
 
 // src/mcp-helpers.ts
-import { createSdkMcpServer, tool } from "@anthropic-ai/claude-agent-sdk";
+import { createSdkMcpServer as createSdkMcpServer2, tool as tool2 } from "@anthropic-ai/claude-agent-sdk";
 import "zod";
 function createCustomMcpServer(config) {
   const defs = Object.entries(config.tools).map(
-    ([name, def]) => tool(
+    ([name, def]) => tool2(
       name,
       def.description,
       def.inputSchema.shape,
       (args, extra) => def.handler(args, extra)
     )
   );
-  return createSdkMcpServer({ name: config.name, version: config.version, tools: defs });
+  return createSdkMcpServer2({ name: config.name, version: config.version, tools: defs });
 }
 export {
   ClaudeCodeLanguageModel,
@@ -1895,11 +2029,11 @@ export {
   createAuthenticationError,
   createClaudeCode,
   createCustomMcpServer,
-  createSdkMcpServer2 as createSdkMcpServer,
+  createSdkMcpServer3 as createSdkMcpServer,
   createTimeoutError,
   getErrorMetadata,
   isAuthenticationError,
   isTimeoutError,
-  tool2 as tool
+  tool3 as tool
 };
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ai-sdk-provider-claude-code/dist/index.js.map b/node_modules/ai-sdk-provider-claude-code/dist/index.js.map
index a92344a..a90d9ea 100644
--- a/node_modules/ai-sdk-provider-claude-code/dist/index.js.map
+++ b/node_modules/ai-sdk-provider-claude-code/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/claude-code-provider.ts","../src/claude-code-language-model.ts","../src/convert-to-claude-code-messages.ts","../src/errors.ts","../src/map-claude-code-finish-reason.ts","../src/validation.ts","../src/logger.ts","../src/index.ts","../src/mcp-helpers.ts"],"sourcesContent":["import type { LanguageModelV2, ProviderV2 } from '@ai-sdk/provider';\nimport { NoSuchModelError } from '@ai-sdk/provider';\nimport { ClaudeCodeLanguageModel, type ClaudeCodeModelId } from './claude-code-language-model.js';\nimport type { ClaudeCodeSettings } from './types.js';\nimport { validateSettings } from './validation.js';\nimport { getLogger } from './logger.js';\n\n/**\n * Claude Code provider interface that extends the AI SDK's ProviderV1.\n * Provides methods to create language models for interacting with Claude via the CLI.\n *\n * @example\n * ```typescript\n * import { claudeCode } from 'ai-sdk-provider-claude-code';\n *\n * // Create a model instance\n * const model = claudeCode('opus');\n *\n * // Or use the explicit methods\n * const chatModel = claudeCode.chat('sonnet');\n * const languageModel = claudeCode.languageModel('opus', { maxTurns: 10 });\n * ```\n */\nexport interface ClaudeCodeProvider extends ProviderV2 {\n  /**\n   * Creates a language model instance for the specified model ID.\n   * This is a shorthand for calling `languageModel()`.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  (modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  /**\n   * Creates a language model instance for text generation.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  languageModel(modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  /**\n   * Alias for `languageModel()` to maintain compatibility with AI SDK patterns.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  chat(modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  imageModel(modelId: string): never;\n}\n\n/**\n * Configuration options for creating a Claude Code provider instance.\n * These settings will be applied as defaults to all models created by the provider.\n *\n * @example\n * ```typescript\n * const provider = createClaudeCode({\n *   defaultSettings: {\n *     maxTurns: 5,\n *     cwd: '/path/to/project'\n *   }\n * });\n * ```\n */\nexport interface ClaudeCodeProviderSettings {\n  /**\n   * Default settings to use for all models created by this provider.\n   * Individual model settings will override these defaults.\n   */\n  defaultSettings?: ClaudeCodeSettings;\n}\n\n/**\n * Creates a Claude Code provider instance with the specified configuration.\n * The provider can be used to create language models for interacting with Claude 4 models.\n *\n * @param options - Provider configuration options\n * @returns Claude Code provider instance\n *\n * @example\n * ```typescript\n * const provider = createClaudeCode({\n *   defaultSettings: {\n *     permissionMode: 'bypassPermissions',\n *     maxTurns: 10\n *   }\n * });\n *\n * const model = provider('opus');\n * ```\n */\nexport function createClaudeCode(options: ClaudeCodeProviderSettings = {}): ClaudeCodeProvider {\n  // Get logger from default settings if provided\n  const logger = getLogger(options.defaultSettings?.logger);\n\n  // Validate default settings if provided\n  if (options.defaultSettings) {\n    const validation = validateSettings(options.defaultSettings);\n    if (!validation.valid) {\n      throw new Error(`Invalid default settings: ${validation.errors.join(', ')}`);\n    }\n    if (validation.warnings.length > 0) {\n      validation.warnings.forEach((warning) => logger.warn(`Claude Code Provider: ${warning}`));\n    }\n  }\n\n  const createModel = (\n    modelId: ClaudeCodeModelId,\n    settings: ClaudeCodeSettings = {}\n  ): LanguageModelV2 => {\n    const mergedSettings = {\n      ...options.defaultSettings,\n      ...settings,\n    };\n\n    // Validate merged settings\n    const validation = validateSettings(mergedSettings);\n    if (!validation.valid) {\n      throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);\n    }\n\n    return new ClaudeCodeLanguageModel({\n      id: modelId,\n      settings: mergedSettings,\n      settingsValidationWarnings: validation.warnings,\n    });\n  };\n\n  const provider = function (modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings) {\n    if (new.target) {\n      throw new Error('The Claude Code model function cannot be called with the new keyword.');\n    }\n\n    return createModel(modelId, settings);\n  };\n\n  provider.languageModel = createModel;\n  provider.chat = createModel; // Alias for languageModel\n\n  // Add textEmbeddingModel method that throws NoSuchModelError\n  provider.textEmbeddingModel = (modelId: string) => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: 'textEmbeddingModel',\n    });\n  };\n\n  provider.imageModel = (modelId: string) => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: 'imageModel',\n    });\n  };\n\n  return provider as ClaudeCodeProvider;\n}\n\n/**\n * Default Claude Code provider instance.\n * Pre-configured provider for quick usage without custom settings.\n *\n * @example\n * ```typescript\n * import { claudeCode } from 'ai-sdk-provider-claude-code';\n * import { generateText } from 'ai';\n *\n * const { text } = await generateText({\n *   model: claudeCode('sonnet'),\n *   prompt: 'Hello, Claude!'\n * });\n * ```\n */\nexport const claudeCode = createClaudeCode();\n","import type {\n  LanguageModelV2,\n  LanguageModelV2CallWarning,\n  LanguageModelV2FinishReason,\n  LanguageModelV2StreamPart,\n  LanguageModelV2Usage,\n  JSONValue,\n} from '@ai-sdk/provider';\nimport { NoSuchModelError, APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/provider-utils';\nimport type { ClaudeCodeSettings, Logger } from './types.js';\nimport { convertToClaudeCodeMessages } from './convert-to-claude-code-messages.js';\nimport { createAPICallError, createAuthenticationError, createTimeoutError } from './errors.js';\nimport { mapClaudeCodeFinishReason } from './map-claude-code-finish-reason.js';\nimport { validateModelId, validatePrompt, validateSessionId } from './validation.js';\nimport { getLogger, createVerboseLogger } from './logger.js';\n\nimport { query, type Options } from '@anthropic-ai/claude-agent-sdk';\nimport type { SDKUserMessage, SDKPartialAssistantMessage } from '@anthropic-ai/claude-agent-sdk';\n\nconst CLAUDE_CODE_TRUNCATION_WARNING =\n  'Claude Code SDK output ended unexpectedly; returning truncated response from buffered text. Await upstream fix to avoid data loss.';\n\nconst MIN_TRUNCATION_LENGTH = 512;\n\n/**\n * Detects if an error represents a truncated SDK JSON stream.\n *\n * The Claude Code SDK can truncate JSON responses mid-stream, producing a SyntaxError.\n * This function distinguishes genuine truncation from normal JSON syntax errors by:\n * 1. Verifying the error is a SyntaxError with truncation-specific messages\n * 2. Ensuring we received meaningful content (>= MIN_TRUNCATION_LENGTH characters)\n * 3. Avoiding false positives from unrelated parse errors\n *\n * Note: We compare against `bufferedText` (assistant text content) rather than the raw\n * JSON buffer length, since the SDK layer doesn't expose buffer positions. The position\n * reported in SyntaxError messages measures the full JSON payload (metadata + content),\n * which is typically much larger than extracted text. Therefore, we cannot reliably use\n * position proximity checks and instead rely on message patterns and content length.\n *\n * @param error - The caught error (expected to be SyntaxError for truncation)\n * @param bufferedText - Accumulated assistant text content (measured in UTF-16 code units)\n * @returns true if error indicates SDK truncation; false otherwise\n */\nfunction isClaudeCodeTruncationError(error: unknown, bufferedText: string): boolean {\n  // Check for SyntaxError by instanceof or by name (for cross-realm errors)\n  const isSyntaxError =\n    error instanceof SyntaxError ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (typeof (error as any)?.name === 'string' &&\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (error as any).name.toLowerCase() === 'syntaxerror');\n\n  if (!isSyntaxError) {\n    return false;\n  }\n\n  if (!bufferedText) {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const rawMessage = typeof (error as any)?.message === 'string' ? (error as any).message : '';\n  const message = rawMessage.toLowerCase();\n\n  // Only match actual truncation patterns, not normal JSON parsing errors.\n  // Real truncation: \"Unexpected end of JSON input\" or \"Unterminated string in JSON...\"\n  // Normal errors: \"Unexpected token X in JSON at position N\" (should be surfaced as errors)\n  const truncationIndicators = [\n    'unexpected end of json input',\n    'unexpected end of input',\n    'unexpected end of string',\n    'unexpected eof',\n    'end of file',\n    'unterminated string',\n    'unterminated string constant',\n  ];\n\n  if (!truncationIndicators.some((indicator) => message.includes(indicator))) {\n    return false;\n  }\n\n  // Require meaningful content before treating as truncation.\n  // Short responses with \"end of input\" errors are likely genuine syntax errors.\n  // Note: bufferedText.length measures UTF-16 code units, not byte length.\n  if (bufferedText.length < MIN_TRUNCATION_LENGTH) {\n    return false;\n  }\n\n  // If we have a truncation indicator AND meaningful content, treat as truncation.\n  return true;\n}\n\nfunction isAbortError(err: unknown): boolean {\n  if (err && typeof err === 'object') {\n    const e = err as { name?: unknown; code?: unknown };\n    if (typeof e.name === 'string' && e.name === 'AbortError') return true;\n    if (typeof e.code === 'string' && e.code.toUpperCase() === 'ABORT_ERR') return true;\n  }\n  return false;\n}\n\nconst STREAMING_FEATURE_WARNING =\n  \"Claude Agent SDK features (hooks/MCP/images) require streaming input. Set `streamingInput: 'always'` or provide `canUseTool` (auto streams only when canUseTool is set).\";\n\nconst SDK_OPTIONS_BLOCKLIST = new Set(['model', 'abortController', 'prompt', 'outputFormat']);\n\ntype ClaudeToolUse = {\n  id: string;\n  name: string;\n  input: unknown;\n};\n\ntype ClaudeToolResult = {\n  id: string;\n  name?: string;\n  result: unknown;\n  isError: boolean;\n};\n\n// Provider extension for tool-error stream parts.\ntype ToolErrorPart = {\n  type: 'tool-error';\n  toolCallId: string;\n  toolName: string;\n  error: string;\n  providerExecuted: true;\n  providerMetadata?: Record<string, JSONValue>;\n};\n\n// Local extension of the AI SDK stream part union to include tool-error.\ntype ExtendedStreamPart = LanguageModelV2StreamPart | ToolErrorPart;\n\n/**\n * Tracks the streaming lifecycle state for a single tool invocation.\n *\n * The tool streaming lifecycle follows this sequence:\n * 1. Tool use detected → state created with all flags false\n * 2. First input seen → `inputStarted` = true, emit `tool-input-start`\n * 3. Input deltas streamed → emit `tool-input-delta` (may be skipped for large/non-prefix updates)\n * 4. Input finalized → `inputClosed` = true, emit `tool-input-end`\n * 5. Tool call formed → `callEmitted` = true, emit `tool-call`\n * 6. Tool results/errors arrive → emit `tool-result` or `tool-error` (may occur multiple times)\n * 7. Stream ends → state cleaned up by `finalizeToolCalls()`\n *\n * @property name - Tool name from SDK (e.g., \"Bash\", \"Read\")\n * @property lastSerializedInput - Most recent serialized input, used for delta calculation\n * @property inputStarted - True after `tool-input-start` emitted; prevents duplicate start events\n * @property inputClosed - True after `tool-input-end` emitted; ensures proper event ordering\n * @property callEmitted - True after `tool-call` emitted; prevents duplicate call events when\n *                         multiple result/error chunks arrive for the same tool invocation\n */\ntype ToolStreamState = {\n  name: string;\n  lastSerializedInput?: string;\n  inputStarted: boolean;\n  inputClosed: boolean;\n  callEmitted: boolean;\n};\n\nfunction toAsyncIterablePrompt(\n  messagesPrompt: string,\n  outputStreamEnded: Promise<unknown>,\n  sessionId?: string,\n  contentParts?: SDKUserMessage['message']['content']\n): AsyncIterable<SDKUserMessage> {\n  const content = (\n    contentParts && contentParts.length > 0\n      ? contentParts\n      : [{ type: 'text', text: messagesPrompt }]\n  ) as SDKUserMessage['message']['content'];\n\n  const msg: SDKUserMessage = {\n    type: 'user',\n    message: {\n      role: 'user',\n      content,\n    },\n    parent_tool_use_id: null,\n    session_id: sessionId ?? '',\n  };\n  return {\n    async *[Symbol.asyncIterator]() {\n      yield msg;\n      await outputStreamEnded;\n    },\n  };\n}\n\n/**\n * Options for creating a Claude Code language model instance.\n *\n * @example\n * ```typescript\n * const model = new ClaudeCodeLanguageModel({\n *   id: 'opus',\n *   settings: {\n *     maxTurns: 10,\n *     permissionMode: 'auto'\n *   }\n * });\n * ```\n */\nexport interface ClaudeCodeLanguageModelOptions {\n  /**\n   * The model identifier to use.\n   * Can be 'opus', 'sonnet', 'haiku', or a custom model string.\n   */\n  id: ClaudeCodeModelId;\n\n  /**\n   * Optional settings to configure the model behavior.\n   */\n  settings?: ClaudeCodeSettings;\n\n  /**\n   * Validation warnings from settings validation.\n   * Used internally to pass warnings from provider.\n   */\n  settingsValidationWarnings?: string[];\n}\n\n/**\n * Supported Claude model identifiers.\n * - 'opus': Claude Opus (most capable)\n * - 'sonnet': Claude Sonnet (balanced performance)\n * - 'haiku': Claude Haiku (fastest, most cost-effective)\n * - Custom string: Any full model identifier (e.g., 'claude-opus-4-5', 'claude-sonnet-4-5-20250514')\n *\n * @example\n * ```typescript\n * const opusModel = claudeCode('opus');\n * const sonnetModel = claudeCode('sonnet');\n * const haikuModel = claudeCode('haiku');\n * const customModel = claudeCode('claude-opus-4-5');\n * ```\n */\nexport type ClaudeCodeModelId = 'opus' | 'sonnet' | 'haiku' | (string & {});\n\nconst modelMap: Record<string, string> = {\n  opus: 'opus',\n  sonnet: 'sonnet',\n  haiku: 'haiku',\n};\n\n/**\n * Language model implementation for Claude Code SDK.\n * This class implements the AI SDK's LanguageModelV2 interface to provide\n * integration with Claude models through the Claude Agent SDK.\n *\n * Features:\n * - Supports streaming and non-streaming generation\n * - Native structured outputs via SDK's outputFormat (guaranteed schema compliance)\n * - Manages CLI sessions for conversation continuity\n * - Provides detailed error handling and retry logic\n *\n * Limitations:\n * - Image inputs require streaming mode\n * - Some parameters like temperature and max tokens are not supported by the CLI\n *\n * @example\n * ```typescript\n * const model = new ClaudeCodeLanguageModel({\n *   id: 'opus',\n *   settings: { maxTurns: 5 }\n * });\n *\n * const result = await model.doGenerate({\n *   prompt: [{ role: 'user', content: 'Hello!' }],\n *   mode: { type: 'regular' }\n * });\n * ```\n */\nexport class ClaudeCodeLanguageModel implements LanguageModelV2 {\n  readonly specificationVersion = 'v2' as const;\n  readonly defaultObjectGenerationMode = 'json' as const;\n  readonly supportsImageUrls = false;\n  readonly supportedUrls = {};\n  readonly supportsStructuredOutputs = true;\n\n  // Fallback/magic string constants\n  static readonly UNKNOWN_TOOL_NAME = 'unknown-tool';\n\n  // Tool input safety limits\n  private static readonly MAX_TOOL_INPUT_SIZE = 1_048_576; // 1MB hard limit\n  private static readonly MAX_TOOL_INPUT_WARN = 102_400; // 100KB warning threshold\n  private static readonly MAX_DELTA_CALC_SIZE = 10_000; // 10KB delta computation threshold\n\n  readonly modelId: ClaudeCodeModelId;\n  readonly settings: ClaudeCodeSettings;\n\n  private sessionId?: string;\n  private modelValidationWarning?: string;\n  private settingsValidationWarnings: string[];\n  private logger: Logger;\n\n  constructor(options: ClaudeCodeLanguageModelOptions) {\n    this.modelId = options.id;\n    this.settings = options.settings ?? {};\n    this.settingsValidationWarnings = options.settingsValidationWarnings ?? [];\n\n    // Create logger that respects verbose setting\n    const baseLogger = getLogger(this.settings.logger);\n    this.logger = createVerboseLogger(baseLogger, this.settings.verbose ?? false);\n\n    // Validate model ID format\n    if (!this.modelId || typeof this.modelId !== 'string' || this.modelId.trim() === '') {\n      throw new NoSuchModelError({\n        modelId: this.modelId,\n        modelType: 'languageModel',\n      });\n    }\n\n    // Additional model ID validation\n    this.modelValidationWarning = validateModelId(this.modelId);\n    if (this.modelValidationWarning) {\n      this.logger.warn(`Claude Code Model: ${this.modelValidationWarning}`);\n    }\n  }\n\n  get provider(): string {\n    return 'claude-code';\n  }\n\n  private getModel(): string {\n    const mapped = modelMap[this.modelId];\n    return mapped ?? this.modelId;\n  }\n\n  private getSanitizedSdkOptions(): Partial<Options> | undefined {\n    if (!this.settings.sdkOptions || typeof this.settings.sdkOptions !== 'object') {\n      return undefined;\n    }\n\n    const sanitized = { ...(this.settings.sdkOptions as Record<string, unknown>) };\n    const blockedKeys = Array.from(SDK_OPTIONS_BLOCKLIST).filter((key) => key in sanitized);\n\n    if (blockedKeys.length > 0) {\n      this.logger.warn(\n        `[claude-code] sdkOptions includes provider-managed fields (${blockedKeys.join(\n          ', '\n        )}); these will be ignored.`\n      );\n      blockedKeys.forEach((key) => delete sanitized[key]);\n    }\n\n    return sanitized as Partial<Options>;\n  }\n\n  private getEffectiveResume(sdkOptions?: Partial<Options>): string | undefined {\n    return sdkOptions?.resume ?? this.settings.resume ?? this.sessionId;\n  }\n\n  private extractToolUses(content: unknown): ClaudeToolUse[] {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (item): item is { type: string; id?: unknown; name?: unknown; input?: unknown } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_use'\n      )\n      .map((item) => {\n        const { id, name, input } = item as { id?: unknown; name?: unknown; input?: unknown };\n        return {\n          id: typeof id === 'string' && id.length > 0 ? id : generateId(),\n          name:\n            typeof name === 'string' && name.length > 0\n              ? name\n              : ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME,\n          input,\n        } satisfies ClaudeToolUse;\n      });\n  }\n\n  private extractToolResults(content: unknown): ClaudeToolResult[] {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (\n          item\n        ): item is {\n          type: string;\n          tool_use_id?: unknown;\n          content?: unknown;\n          is_error?: unknown;\n          name?: unknown;\n        } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_result'\n      )\n      .map((item) => {\n        const { tool_use_id, content, is_error, name } = item;\n        return {\n          id:\n            typeof tool_use_id === 'string' && tool_use_id.length > 0 ? tool_use_id : generateId(),\n          name: typeof name === 'string' && name.length > 0 ? name : undefined,\n          result: content,\n          isError: Boolean(is_error),\n        } satisfies ClaudeToolResult;\n      });\n  }\n\n  private extractToolErrors(content: unknown): Array<{\n    id: string;\n    name?: string;\n    error: unknown;\n  }> {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (\n          item\n        ): item is {\n          type: string;\n          tool_use_id?: unknown;\n          error?: unknown;\n          name?: unknown;\n        } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_error'\n      )\n      .map((item) => {\n        const { tool_use_id, error, name } = item as {\n          tool_use_id?: unknown;\n          error?: unknown;\n          name?: unknown;\n        };\n        return {\n          id:\n            typeof tool_use_id === 'string' && tool_use_id.length > 0 ? tool_use_id : generateId(),\n          name: typeof name === 'string' && name.length > 0 ? name : undefined,\n          error,\n        };\n      });\n  }\n\n  private serializeToolInput(input: unknown): string {\n    if (typeof input === 'string') {\n      return this.checkInputSize(input);\n    }\n\n    if (input === undefined) {\n      return '';\n    }\n\n    try {\n      const serialized = JSON.stringify(input);\n      return this.checkInputSize(serialized);\n    } catch {\n      const fallback = String(input);\n      return this.checkInputSize(fallback);\n    }\n  }\n\n  private checkInputSize(str: string): string {\n    const length = str.length;\n\n    if (length > ClaudeCodeLanguageModel.MAX_TOOL_INPUT_SIZE) {\n      throw new Error(\n        `Tool input exceeds maximum size of ${ClaudeCodeLanguageModel.MAX_TOOL_INPUT_SIZE} bytes (got ${length} bytes). This may indicate a malformed request or an attempt to process excessively large data.`\n      );\n    }\n\n    if (length > ClaudeCodeLanguageModel.MAX_TOOL_INPUT_WARN) {\n      this.logger.warn(\n        `[claude-code] Large tool input detected: ${length} bytes. Performance may be impacted. Consider chunking or reducing input size.`\n      );\n    }\n\n    return str;\n  }\n\n  private normalizeToolResult(result: unknown): unknown {\n    if (typeof result === 'string') {\n      try {\n        return JSON.parse(result);\n      } catch {\n        return result;\n      }\n    }\n\n    return result;\n  }\n\n  private generateAllWarnings(\n    options:\n      | Parameters<LanguageModelV2['doGenerate']>[0]\n      | Parameters<LanguageModelV2['doStream']>[0],\n    prompt: string\n  ): LanguageModelV2CallWarning[] {\n    const warnings: LanguageModelV2CallWarning[] = [];\n    const unsupportedParams: string[] = [];\n\n    // Check for unsupported parameters\n    if (options.temperature !== undefined) unsupportedParams.push('temperature');\n    if (options.topP !== undefined) unsupportedParams.push('topP');\n    if (options.topK !== undefined) unsupportedParams.push('topK');\n    if (options.presencePenalty !== undefined) unsupportedParams.push('presencePenalty');\n    if (options.frequencyPenalty !== undefined) unsupportedParams.push('frequencyPenalty');\n    if (options.stopSequences !== undefined && options.stopSequences.length > 0)\n      unsupportedParams.push('stopSequences');\n    if (options.seed !== undefined) unsupportedParams.push('seed');\n\n    if (unsupportedParams.length > 0) {\n      // Add a warning for each unsupported parameter\n      for (const param of unsupportedParams) {\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: param as\n            | 'temperature'\n            | 'maxTokens'\n            | 'topP'\n            | 'topK'\n            | 'presencePenalty'\n            | 'frequencyPenalty'\n            | 'stopSequences'\n            | 'seed',\n          details: `Claude Code SDK does not support the ${param} parameter. It will be ignored.`,\n        });\n      }\n    }\n\n    // Add model validation warning if present\n    if (this.modelValidationWarning) {\n      warnings.push({\n        type: 'other',\n        message: this.modelValidationWarning,\n      });\n    }\n\n    // Add settings validation warnings\n    this.settingsValidationWarnings.forEach((warning) => {\n      warnings.push({\n        type: 'other',\n        message: warning,\n      });\n    });\n\n    // Warn if JSON response format is requested without a schema\n    // Claude Code only supports structured outputs with schemas (like Anthropic's API)\n    if (options.responseFormat?.type === 'json' && !options.responseFormat.schema) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details:\n          'JSON response format requires a schema for the Claude Code provider. The JSON responseFormat is ignored and the call is treated as plain text.',\n      });\n    }\n\n    // Validate prompt\n    const promptWarning = validatePrompt(prompt);\n    if (promptWarning) {\n      warnings.push({\n        type: 'other',\n        message: promptWarning,\n      });\n    }\n\n    return warnings;\n  }\n\n  private createQueryOptions(\n    abortController: AbortController,\n    responseFormat?: Parameters<LanguageModelV2['doGenerate']>[0]['responseFormat'],\n    stderrCollector?: (data: string) => void,\n    sdkOptions?: Partial<Options>,\n    effectiveResume?: string\n  ): Options {\n    const opts: Partial<Options> & Record<string, unknown> = {\n      model: this.getModel(),\n      abortController,\n      resume: effectiveResume ?? this.settings.resume ?? this.sessionId,\n      pathToClaudeCodeExecutable: this.settings.pathToClaudeCodeExecutable,\n      maxTurns: this.settings.maxTurns,\n      maxThinkingTokens: this.settings.maxThinkingTokens,\n      cwd: this.settings.cwd,\n      executable: this.settings.executable,\n      executableArgs: this.settings.executableArgs,\n      permissionMode: this.settings.permissionMode,\n      permissionPromptToolName: this.settings.permissionPromptToolName,\n      continue: this.settings.continue,\n      allowedTools: this.settings.allowedTools,\n      disallowedTools: this.settings.disallowedTools,\n      betas: this.settings.betas,\n      allowDangerouslySkipPermissions: this.settings.allowDangerouslySkipPermissions,\n      enableFileCheckpointing: this.settings.enableFileCheckpointing,\n      maxBudgetUsd: this.settings.maxBudgetUsd,\n      plugins: this.settings.plugins,\n      resumeSessionAt: this.settings.resumeSessionAt,\n      sandbox: this.settings.sandbox,\n      tools: this.settings.tools,\n      mcpServers: this.settings.mcpServers,\n      canUseTool: this.settings.canUseTool,\n    };\n    // NEW: Agent SDK options with legacy mapping\n    if (this.settings.systemPrompt !== undefined) {\n      opts.systemPrompt = this.settings.systemPrompt;\n    } else if (this.settings.customSystemPrompt !== undefined) {\n      // Deprecation warning for legacy field\n      this.logger.warn(\n        \"[claude-code] 'customSystemPrompt' is deprecated and will be removed in a future major release. Please use 'systemPrompt' instead (string or { type: 'preset', preset: 'claude_code', append? }).\"\n      );\n      opts.systemPrompt = this.settings.customSystemPrompt;\n    } else if (this.settings.appendSystemPrompt !== undefined) {\n      // Deprecation warning for legacy field\n      this.logger.warn(\n        \"[claude-code] 'appendSystemPrompt' is deprecated and will be removed in a future major release. Please use 'systemPrompt: { type: 'preset', preset: 'claude_code', append: <text> }' instead.\"\n      );\n      opts.systemPrompt = {\n        type: 'preset',\n        preset: 'claude_code',\n        append: this.settings.appendSystemPrompt,\n      } as const;\n    }\n    if (this.settings.settingSources !== undefined) {\n      opts.settingSources = this.settings.settingSources;\n    }\n    if (this.settings.additionalDirectories !== undefined) {\n      opts.additionalDirectories = this.settings.additionalDirectories;\n    }\n    if (this.settings.agents !== undefined) {\n      opts.agents = this.settings.agents;\n    }\n    if (this.settings.includePartialMessages !== undefined) {\n      opts.includePartialMessages = this.settings.includePartialMessages;\n    }\n    if (this.settings.fallbackModel !== undefined) {\n      opts.fallbackModel = this.settings.fallbackModel;\n    }\n    if (this.settings.forkSession !== undefined) {\n      opts.forkSession = this.settings.forkSession;\n    }\n    if (this.settings.strictMcpConfig !== undefined) {\n      opts.strictMcpConfig = this.settings.strictMcpConfig;\n    }\n    if (this.settings.extraArgs !== undefined) {\n      opts.extraArgs = this.settings.extraArgs;\n    }\n    // hooks is supported in newer SDKs; include it if provided\n    if (this.settings.hooks) {\n      opts.hooks = this.settings.hooks;\n    }\n\n    const sdkOverrides = sdkOptions\n      ? (sdkOptions as Partial<Options> & Record<string, unknown>)\n      : undefined;\n    const sdkEnv =\n      sdkOverrides && typeof sdkOverrides.env === 'object' && sdkOverrides.env !== null\n        ? (sdkOverrides.env as Record<string, string | undefined>)\n        : undefined;\n    const sdkStderr =\n      sdkOverrides && typeof sdkOverrides.stderr === 'function'\n        ? (sdkOverrides.stderr as (data: string) => void)\n        : undefined;\n    if (sdkOverrides) {\n      const rest = { ...sdkOverrides };\n      delete rest.env;\n      delete rest.stderr;\n      Object.assign(opts, rest);\n    }\n\n    // Wrap stderr callback to also collect data for error reporting\n    const userStderrCallback = sdkStderr ?? this.settings.stderr;\n    if (stderrCollector || userStderrCallback) {\n      opts.stderr = (data: string) => {\n        if (stderrCollector) stderrCollector(data);\n        if (userStderrCallback) userStderrCallback(data);\n      };\n    }\n\n    if (this.settings.env !== undefined || sdkEnv !== undefined) {\n      opts.env = { ...process.env, ...this.settings.env, ...sdkEnv };\n    }\n\n    // Native structured outputs (SDK 0.1.45+)\n    if (responseFormat?.type === 'json' && responseFormat.schema) {\n      opts.outputFormat = {\n        type: 'json_schema',\n        schema: responseFormat.schema as Record<string, unknown>,\n      };\n    }\n\n    return opts as Options;\n  }\n\n  private handleClaudeCodeError(\n    error: unknown,\n    messagesPrompt: string,\n    collectedStderr?: string\n  ): APICallError | LoadAPIKeyError {\n    // Handle AbortError from the SDK\n    if (isAbortError(error)) {\n      // Return the abort reason if available, otherwise the error itself\n      throw error;\n    }\n\n    // Type guard for error with properties\n    const isErrorWithMessage = (err: unknown): err is { message?: string } => {\n      return typeof err === 'object' && err !== null && 'message' in err;\n    };\n\n    const isErrorWithCode = (\n      err: unknown\n    ): err is { code?: string; exitCode?: number; stderr?: string } => {\n      return typeof err === 'object' && err !== null;\n    };\n\n    // Check for authentication errors with improved detection\n    const authErrorPatterns = [\n      'not logged in',\n      'authentication',\n      'unauthorized',\n      'auth failed',\n      'please login',\n      'claude login',\n    ];\n\n    const errorMessage =\n      isErrorWithMessage(error) && error.message ? error.message.toLowerCase() : '';\n\n    const exitCode =\n      isErrorWithCode(error) && typeof error.exitCode === 'number' ? error.exitCode : undefined;\n\n    const isAuthError =\n      authErrorPatterns.some((pattern) => errorMessage.includes(pattern)) || exitCode === 401;\n\n    if (isAuthError) {\n      return createAuthenticationError({\n        message:\n          isErrorWithMessage(error) && error.message\n            ? error.message\n            : 'Authentication failed. Please ensure Claude Code SDK is properly authenticated.',\n      });\n    }\n\n    // Check for timeout errors\n    const errorCode = isErrorWithCode(error) && typeof error.code === 'string' ? error.code : '';\n\n    if (errorCode === 'ETIMEDOUT' || errorMessage.includes('timeout')) {\n      return createTimeoutError({\n        message: isErrorWithMessage(error) && error.message ? error.message : 'Request timed out',\n        promptExcerpt: messagesPrompt.substring(0, 200),\n        // Don't specify timeoutMs since we don't know the actual timeout value\n        // It's controlled by the consumer via AbortSignal\n      });\n    }\n\n    // Create general API call error with appropriate retry flag\n    const isRetryable =\n      errorCode === 'ENOENT' ||\n      errorCode === 'ECONNREFUSED' ||\n      errorCode === 'ETIMEDOUT' ||\n      errorCode === 'ECONNRESET';\n\n    // Use error.stderr if available from SDK, otherwise use collected stderr\n    const stderrFromError =\n      isErrorWithCode(error) && typeof error.stderr === 'string' ? error.stderr : undefined;\n    const stderr = stderrFromError || collectedStderr || undefined;\n\n    return createAPICallError({\n      message: isErrorWithMessage(error) && error.message ? error.message : 'Claude Code SDK error',\n      code: errorCode || undefined,\n      exitCode: exitCode,\n      stderr,\n      promptExcerpt: messagesPrompt.substring(0, 200),\n      isRetryable,\n    });\n  }\n\n  private setSessionId(sessionId: string): void {\n    this.sessionId = sessionId;\n    const warning = validateSessionId(sessionId);\n    if (warning) {\n      this.logger.warn(`Claude Code Session: ${warning}`);\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV2['doGenerate']>[0]\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>> {\n    this.logger.debug(`[claude-code] Starting doGenerate request with model: ${this.modelId}`);\n    this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? 'none'}`);\n\n    const {\n      messagesPrompt,\n      warnings: messageWarnings,\n      streamingContentParts,\n      hasImageParts,\n    } = convertToClaudeCodeMessages(options.prompt);\n\n    this.logger.debug(\n      `[claude-code] Converted ${options.prompt.length} messages, hasImageParts: ${hasImageParts}`\n    );\n\n    const abortController = new AbortController();\n    let abortListener: (() => void) | undefined;\n    if (options.abortSignal?.aborted) {\n      // Propagate already-aborted state immediately with original reason\n      abortController.abort(options.abortSignal.reason);\n    } else if (options.abortSignal) {\n      abortListener = () => abortController.abort(options.abortSignal?.reason);\n      options.abortSignal.addEventListener('abort', abortListener, { once: true });\n    }\n\n    // Collect stderr for error reporting (SDK may not include it in errors)\n    let collectedStderr = '';\n    const stderrCollector = (data: string) => {\n      collectedStderr += data;\n    };\n\n    const sdkOptions = this.getSanitizedSdkOptions();\n    const effectiveResume = this.getEffectiveResume(sdkOptions);\n    const queryOptions = this.createQueryOptions(\n      abortController,\n      options.responseFormat,\n      stderrCollector,\n      sdkOptions,\n      effectiveResume\n    );\n\n    let text = '';\n    let structuredOutput: unknown | undefined;\n    let usage: LanguageModelV2Usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n    let finishReason: LanguageModelV2FinishReason = 'stop';\n    let wasTruncated = false;\n    let costUsd: number | undefined;\n    let durationMs: number | undefined;\n    let rawUsage: unknown | undefined;\n    const warnings: LanguageModelV2CallWarning[] = this.generateAllWarnings(\n      options,\n      messagesPrompt\n    );\n\n    // Add warnings from message conversion\n    if (messageWarnings) {\n      messageWarnings.forEach((warning) => {\n        warnings.push({\n          type: 'other',\n          message: warning,\n        });\n      });\n    }\n\n    const modeSetting = this.settings.streamingInput ?? 'auto';\n    const effectiveCanUseTool = sdkOptions?.canUseTool ?? this.settings.canUseTool;\n    const effectivePermissionPromptToolName =\n      sdkOptions?.permissionPromptToolName ?? this.settings.permissionPromptToolName;\n    const wantsStreamInput =\n      modeSetting === 'always' || (modeSetting === 'auto' && !!effectiveCanUseTool);\n\n    if (!wantsStreamInput && hasImageParts) {\n      warnings.push({\n        type: 'other',\n        message: STREAMING_FEATURE_WARNING,\n      });\n    }\n\n    let done = () => {};\n    const outputStreamEnded = new Promise((resolve) => {\n      done = () => resolve(undefined);\n    });\n    try {\n      if (effectiveCanUseTool && effectivePermissionPromptToolName) {\n        throw new Error(\n          \"canUseTool requires streamingInput mode ('auto' or 'always') and cannot be used with permissionPromptToolName (SDK constraint). Set streamingInput: 'auto' (or 'always') and remove permissionPromptToolName, or remove canUseTool.\"\n        );\n      }\n      // hold input stream open until results\n      // see: https://github.com/anthropics/claude-code/issues/4775\n      const sdkPrompt = wantsStreamInput\n        ? toAsyncIterablePrompt(\n            messagesPrompt,\n            outputStreamEnded,\n            effectiveResume,\n            streamingContentParts\n          )\n        : messagesPrompt;\n\n      this.logger.debug(\n        `[claude-code] Executing query with streamingInput: ${wantsStreamInput}, session: ${effectiveResume ?? 'new'}`\n      );\n\n      const response = query({\n        prompt: sdkPrompt,\n        options: queryOptions,\n      });\n\n      for await (const message of response) {\n        this.logger.debug(`[claude-code] Received message type: ${message.type}`);\n        if (message.type === 'assistant') {\n          text += message.message.content\n            .map((c: { type: string; text?: string }) => (c.type === 'text' ? c.text : ''))\n            .join('');\n        } else if (message.type === 'result') {\n          done();\n          this.setSessionId(message.session_id);\n          costUsd = message.total_cost_usd;\n          durationMs = message.duration_ms;\n\n          // Handle structured output errors (SDK 0.1.45+)\n          // Use string comparison to support new SDK subtypes not yet in TypeScript definitions\n          if ((message.subtype as string) === 'error_max_structured_output_retries') {\n            throw new Error(\n              'Failed to generate valid structured output after maximum retries. The model could not produce a response matching the required schema.'\n            );\n          }\n\n          // Capture structured output if available (SDK 0.1.45+)\n          if ('structured_output' in message && message.structured_output !== undefined) {\n            structuredOutput = message.structured_output;\n            this.logger.debug('[claude-code] Received structured output from SDK');\n          }\n\n          this.logger.info(\n            `[claude-code] Request completed - Session: ${message.session_id}, Cost: $${costUsd?.toFixed(4) ?? 'N/A'}, Duration: ${durationMs ?? 'N/A'}ms`\n          );\n\n          if ('usage' in message) {\n            rawUsage = message.usage;\n            usage = {\n              inputTokens:\n                (message.usage.cache_creation_input_tokens ?? 0) +\n                (message.usage.cache_read_input_tokens ?? 0) +\n                (message.usage.input_tokens ?? 0),\n              outputTokens: message.usage.output_tokens ?? 0,\n              totalTokens:\n                (message.usage.cache_creation_input_tokens ?? 0) +\n                (message.usage.cache_read_input_tokens ?? 0) +\n                (message.usage.input_tokens ?? 0) +\n                (message.usage.output_tokens ?? 0),\n            };\n\n            this.logger.debug(\n              `[claude-code] Token usage - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`\n            );\n          }\n\n          finishReason = mapClaudeCodeFinishReason(message.subtype);\n          this.logger.debug(`[claude-code] Finish reason: ${finishReason}`);\n        } else if (message.type === 'system' && message.subtype === 'init') {\n          this.setSessionId(message.session_id);\n          this.logger.info(`[claude-code] Session initialized: ${message.session_id}`);\n        }\n      }\n    } catch (error: unknown) {\n      done();\n      this.logger.debug(\n        `[claude-code] Error during doGenerate: ${error instanceof Error ? error.message : String(error)}`\n      );\n\n      // Special handling for AbortError to preserve abort signal reason\n      if (isAbortError(error)) {\n        this.logger.debug('[claude-code] Request aborted by user');\n        throw options.abortSignal?.aborted ? options.abortSignal.reason : error;\n      }\n\n      if (isClaudeCodeTruncationError(error, text)) {\n        this.logger.warn(\n          `[claude-code] Detected truncated response, returning ${text.length} characters of buffered text`\n        );\n        wasTruncated = true;\n        finishReason = 'length';\n        warnings.push({\n          type: 'other',\n          message: CLAUDE_CODE_TRUNCATION_WARNING,\n        });\n      } else {\n        // Use unified error handler\n        throw this.handleClaudeCodeError(error, messagesPrompt, collectedStderr);\n      }\n    } finally {\n      if (options.abortSignal && abortListener) {\n        options.abortSignal.removeEventListener('abort', abortListener);\n      }\n    }\n\n    // Use structured output from SDK if available (native JSON schema support)\n    // Otherwise fall back to accumulated text\n    const finalText = structuredOutput !== undefined ? JSON.stringify(structuredOutput) : text;\n\n    return {\n      content: [{ type: 'text', text: finalText }],\n      usage,\n      finishReason,\n      warnings,\n      response: {\n        id: generateId(),\n        timestamp: new Date(),\n        modelId: this.modelId,\n      },\n      request: {\n        body: messagesPrompt,\n      },\n      providerMetadata: {\n        'claude-code': {\n          ...(this.sessionId !== undefined && { sessionId: this.sessionId }),\n          ...(costUsd !== undefined && { costUsd }),\n          ...(durationMs !== undefined && { durationMs }),\n          ...(rawUsage !== undefined && { rawUsage: rawUsage as JSONValue }),\n          ...(wasTruncated && { truncated: true }),\n        },\n      },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV2['doStream']>[0]\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>> {\n    this.logger.debug(`[claude-code] Starting doStream request with model: ${this.modelId}`);\n    this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? 'none'}`);\n\n    const {\n      messagesPrompt,\n      warnings: messageWarnings,\n      streamingContentParts,\n      hasImageParts,\n    } = convertToClaudeCodeMessages(options.prompt);\n\n    this.logger.debug(\n      `[claude-code] Converted ${options.prompt.length} messages for streaming, hasImageParts: ${hasImageParts}`\n    );\n\n    const abortController = new AbortController();\n    let abortListener: (() => void) | undefined;\n    if (options.abortSignal?.aborted) {\n      // Propagate already-aborted state immediately with original reason\n      abortController.abort(options.abortSignal.reason);\n    } else if (options.abortSignal) {\n      abortListener = () => abortController.abort(options.abortSignal?.reason);\n      options.abortSignal.addEventListener('abort', abortListener, { once: true });\n    }\n\n    // Collect stderr for error reporting (SDK may not include it in errors)\n    let collectedStderr = '';\n    const stderrCollector = (data: string) => {\n      collectedStderr += data;\n    };\n\n    const sdkOptions = this.getSanitizedSdkOptions();\n    const effectiveResume = this.getEffectiveResume(sdkOptions);\n    const queryOptions = this.createQueryOptions(\n      abortController,\n      options.responseFormat,\n      stderrCollector,\n      sdkOptions,\n      effectiveResume\n    );\n\n    // Enable partial messages for true streaming (token-by-token delivery)\n    // This can be overridden by user settings, but we default to true for doStream\n    if (queryOptions.includePartialMessages === undefined) {\n      queryOptions.includePartialMessages = true;\n    }\n\n    const warnings: LanguageModelV2CallWarning[] = this.generateAllWarnings(\n      options,\n      messagesPrompt\n    );\n\n    // Add warnings from message conversion\n    if (messageWarnings) {\n      messageWarnings.forEach((warning) => {\n        warnings.push({\n          type: 'other',\n          message: warning,\n        });\n      });\n    }\n\n    const modeSetting = this.settings.streamingInput ?? 'auto';\n    const effectiveCanUseTool = sdkOptions?.canUseTool ?? this.settings.canUseTool;\n    const effectivePermissionPromptToolName =\n      sdkOptions?.permissionPromptToolName ?? this.settings.permissionPromptToolName;\n    const wantsStreamInput =\n      modeSetting === 'always' || (modeSetting === 'auto' && !!effectiveCanUseTool);\n\n    if (!wantsStreamInput && hasImageParts) {\n      warnings.push({\n        type: 'other',\n        message: STREAMING_FEATURE_WARNING,\n      });\n    }\n\n    const stream = new ReadableStream<ExtendedStreamPart>({\n      start: async (controller) => {\n        let done = () => {};\n        const outputStreamEnded = new Promise((resolve) => {\n          done = () => resolve(undefined);\n        });\n        const toolStates = new Map<string, ToolStreamState>();\n        const streamWarnings: LanguageModelV2CallWarning[] = [];\n\n        const closeToolInput = (toolId: string, state: ToolStreamState) => {\n          if (!state.inputClosed && state.inputStarted) {\n            controller.enqueue({\n              type: 'tool-input-end',\n              id: toolId,\n            });\n            state.inputClosed = true;\n          }\n        };\n\n        const emitToolCall = (toolId: string, state: ToolStreamState) => {\n          if (state.callEmitted) {\n            return;\n          }\n\n          closeToolInput(toolId, state);\n\n          controller.enqueue({\n            type: 'tool-call',\n            toolCallId: toolId,\n            toolName: state.name,\n            input: state.lastSerializedInput ?? '',\n            providerExecuted: true,\n            dynamic: true, // V3 field: indicates tool is provider-defined (not in user's tools map)\n            providerMetadata: {\n              'claude-code': {\n                // rawInput preserves the original serialized format before AI SDK normalization.\n                // Use this if you need the exact string sent to the Claude CLI, which may differ\n                // from the `input` field after AI SDK processing.\n                rawInput: state.lastSerializedInput ?? '',\n              },\n            },\n          } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n          state.callEmitted = true;\n        };\n\n        const finalizeToolCalls = () => {\n          for (const [toolId, state] of toolStates) {\n            emitToolCall(toolId, state);\n          }\n          toolStates.clear();\n        };\n\n        let usage: LanguageModelV2Usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n        let accumulatedText = '';\n        let textPartId: string | undefined;\n        let streamedTextLength = 0; // Track text already emitted via stream_events to avoid duplication\n        let hasReceivedStreamEvents = false; // Track if we've received any stream_events\n\n        try {\n          // Emit stream-start with warnings\n          controller.enqueue({ type: 'stream-start', warnings });\n\n          if (effectiveCanUseTool && effectivePermissionPromptToolName) {\n            throw new Error(\n              \"canUseTool requires streamingInput mode ('auto' or 'always') and cannot be used with permissionPromptToolName (SDK constraint). Set streamingInput: 'auto' (or 'always') and remove permissionPromptToolName, or remove canUseTool.\"\n            );\n          }\n          // hold input stream open until results\n          // see: https://github.com/anthropics/claude-code/issues/4775\n          const sdkPrompt = wantsStreamInput\n            ? toAsyncIterablePrompt(\n                messagesPrompt,\n                outputStreamEnded,\n                effectiveResume,\n                streamingContentParts\n              )\n            : messagesPrompt;\n\n          this.logger.debug(\n            `[claude-code] Starting stream query with streamingInput: ${wantsStreamInput}, session: ${effectiveResume ?? 'new'}`\n          );\n\n          const response = query({\n            prompt: sdkPrompt,\n            options: queryOptions,\n          });\n\n          for await (const message of response) {\n            this.logger.debug(`[claude-code] Stream received message type: ${message.type}`);\n\n            // Handle streaming events (token-by-token delivery via includePartialMessages)\n            if (message.type === 'stream_event') {\n              const streamEvent = message as SDKPartialAssistantMessage;\n              const event = streamEvent.event;\n\n              // Check for text_delta events within content_block_delta\n              if (\n                event.type === 'content_block_delta' &&\n                event.delta.type === 'text_delta' &&\n                'text' in event.delta &&\n                event.delta.text\n              ) {\n                const deltaText = event.delta.text;\n                hasReceivedStreamEvents = true;\n\n                // Don't emit text deltas in JSON mode - accumulate instead\n                if (options.responseFormat?.type === 'json') {\n                  accumulatedText += deltaText;\n                  streamedTextLength += deltaText.length;\n                  continue;\n                }\n\n                // Emit text-start if this is the first text\n                if (!textPartId) {\n                  textPartId = generateId();\n                  controller.enqueue({\n                    type: 'text-start',\n                    id: textPartId,\n                  });\n                }\n\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: textPartId,\n                  delta: deltaText,\n                });\n                accumulatedText += deltaText;\n                streamedTextLength += deltaText.length;\n              }\n              // Handle input_json_delta events for structured output streaming\n              // The SDK uses a StructuredOutput tool internally, and JSON is streamed via input_json_delta\n              if (\n                event.type === 'content_block_delta' &&\n                event.delta.type === 'input_json_delta' &&\n                'partial_json' in event.delta &&\n                event.delta.partial_json\n              ) {\n                const jsonDelta = event.delta.partial_json;\n                hasReceivedStreamEvents = true;\n\n                // Only emit in JSON mode - this enables streamObject() to receive partial updates\n                if (options.responseFormat?.type === 'json') {\n                  // Emit text-start if this is the first JSON delta\n                  if (!textPartId) {\n                    textPartId = generateId();\n                    controller.enqueue({\n                      type: 'text-start',\n                      id: textPartId,\n                    });\n                  }\n\n                  controller.enqueue({\n                    type: 'text-delta',\n                    id: textPartId,\n                    delta: jsonDelta,\n                  });\n                  accumulatedText += jsonDelta;\n                  streamedTextLength += jsonDelta.length;\n                }\n                // In non-JSON mode, input_json_delta is ignored (it's internal tool use)\n              }\n\n              // Other stream_event types (content_block_start, content_block_stop, etc.)\n              // are informational and don't need to be forwarded to the AI SDK stream\n              continue;\n            }\n\n            if (message.type === 'assistant') {\n              if (!message.message?.content) {\n                this.logger.warn(\n                  `[claude-code] Unexpected assistant message structure: missing content field. Message type: ${message.type}. This may indicate an SDK protocol violation.`\n                );\n                continue;\n              }\n\n              const content = message.message.content;\n\n              for (const tool of this.extractToolUses(content)) {\n                const toolId = tool.id;\n                let state = toolStates.get(toolId);\n                if (!state) {\n                  state = {\n                    name: tool.name,\n                    inputStarted: false,\n                    inputClosed: false,\n                    callEmitted: false,\n                  };\n                  toolStates.set(toolId, state);\n                  this.logger.debug(\n                    `[claude-code] New tool use detected - Tool: ${tool.name}, ID: ${toolId}`\n                  );\n                }\n\n                state.name = tool.name;\n\n                if (!state.inputStarted) {\n                  this.logger.debug(\n                    `[claude-code] Tool input started - Tool: ${tool.name}, ID: ${toolId}`\n                  );\n                  controller.enqueue({\n                    type: 'tool-input-start',\n                    id: toolId,\n                    toolName: tool.name,\n                    providerExecuted: true,\n                    dynamic: true, // V3 field: indicates tool is provider-defined\n                  } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n                  state.inputStarted = true;\n                }\n\n                const serializedInput = this.serializeToolInput(tool.input);\n                if (serializedInput) {\n                  let deltaPayload = '';\n\n                  // First input: emit full delta only if small enough\n                  if (state.lastSerializedInput === undefined) {\n                    if (serializedInput.length <= ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE) {\n                      deltaPayload = serializedInput;\n                    }\n                  } else if (\n                    serializedInput.length <= ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE &&\n                    state.lastSerializedInput.length <=\n                      ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE &&\n                    serializedInput.startsWith(state.lastSerializedInput)\n                  ) {\n                    deltaPayload = serializedInput.slice(state.lastSerializedInput.length);\n                  } else if (serializedInput !== state.lastSerializedInput) {\n                    // Non-prefix updates or large inputs - defer to the final tool-call payload\n                    deltaPayload = '';\n                  }\n\n                  if (deltaPayload) {\n                    controller.enqueue({\n                      type: 'tool-input-delta',\n                      id: toolId,\n                      delta: deltaPayload,\n                    });\n                  }\n                  state.lastSerializedInput = serializedInput;\n                }\n              }\n\n              const text = content\n                .map((c: { type: string; text?: string }) => (c.type === 'text' ? c.text : ''))\n                .join('');\n\n              if (text) {\n                // When we've received stream_events, assistant messages contain cumulative text\n                // that we've already emitted via stream_event deltas - skip duplicates\n                // When no stream_events received, assistant messages contain incremental text\n                if (hasReceivedStreamEvents) {\n                  // Calculate delta: only emit text that wasn't already streamed via stream_events\n                  const newTextStart = streamedTextLength;\n                  const deltaText = text.length > newTextStart ? text.slice(newTextStart) : '';\n\n                  // Always accumulate for final result tracking\n                  accumulatedText = text; // Replace with full text (assistant msg contains full content)\n\n                  // In JSON mode, we accumulate the text and extract JSON at the end\n                  // Otherwise, stream any new text\n                  if (options.responseFormat?.type !== 'json' && deltaText) {\n                    // Emit text-start if this is the first text\n                    if (!textPartId) {\n                      textPartId = generateId();\n                      controller.enqueue({\n                        type: 'text-start',\n                        id: textPartId,\n                      });\n                    }\n\n                    controller.enqueue({\n                      type: 'text-delta',\n                      id: textPartId,\n                      delta: deltaText,\n                    });\n                  }\n\n                  // Update streamedTextLength to match what we now know is the full text\n                  streamedTextLength = text.length;\n                } else {\n                  // No stream_events - assistant messages contain incremental text chunks\n                  accumulatedText += text;\n\n                  // In JSON mode, we accumulate the text and extract JSON at the end\n                  // Otherwise, stream the text as it comes\n                  if (options.responseFormat?.type !== 'json') {\n                    // Emit text-start if this is the first text\n                    if (!textPartId) {\n                      textPartId = generateId();\n                      controller.enqueue({\n                        type: 'text-start',\n                        id: textPartId,\n                      });\n                    }\n\n                    controller.enqueue({\n                      type: 'text-delta',\n                      id: textPartId,\n                      delta: text,\n                    });\n                  }\n                }\n              }\n            } else if (message.type === 'user') {\n              if (!message.message?.content) {\n                this.logger.warn(\n                  `[claude-code] Unexpected user message structure: missing content field. Message type: ${message.type}. This may indicate an SDK protocol violation.`\n                );\n                continue;\n              }\n              const content = message.message.content;\n              for (const result of this.extractToolResults(content)) {\n                let state = toolStates.get(result.id);\n                const toolName =\n                  result.name ?? state?.name ?? ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;\n\n                this.logger.debug(\n                  `[claude-code] Tool result received - Tool: ${toolName}, ID: ${result.id}`\n                );\n\n                if (!state) {\n                  this.logger.warn(\n                    `[claude-code] Received tool result for unknown tool ID: ${result.id}`\n                  );\n                  state = {\n                    name: toolName,\n                    inputStarted: false,\n                    inputClosed: false,\n                    callEmitted: false,\n                  };\n                  toolStates.set(result.id, state);\n                  // Synthesize input lifecycle to preserve ordering when no prior tool_use was seen\n                  if (!state.inputStarted) {\n                    controller.enqueue({\n                      type: 'tool-input-start',\n                      id: result.id,\n                      toolName,\n                      providerExecuted: true,\n                      dynamic: true, // V3 field: indicates tool is provider-defined\n                    } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n                    state.inputStarted = true;\n                  }\n                  if (!state.inputClosed) {\n                    controller.enqueue({\n                      type: 'tool-input-end',\n                      id: result.id,\n                    });\n                    state.inputClosed = true;\n                  }\n                }\n                state.name = toolName;\n                const normalizedResult = this.normalizeToolResult(result.result);\n                const rawResult =\n                  typeof result.result === 'string'\n                    ? result.result\n                    : (() => {\n                        try {\n                          return JSON.stringify(result.result);\n                        } catch {\n                          return String(result.result);\n                        }\n                      })();\n\n                emitToolCall(result.id, state);\n\n                controller.enqueue({\n                  type: 'tool-result',\n                  toolCallId: result.id,\n                  toolName,\n                  result: normalizedResult,\n                  isError: result.isError,\n                  providerExecuted: true,\n                  dynamic: true, // V3 field: indicates tool is provider-defined\n                  providerMetadata: {\n                    'claude-code': {\n                      // rawResult preserves the original CLI output string before JSON parsing.\n                      // Use this when you need the exact string returned by the tool, especially\n                      // if the `result` field has been parsed/normalized and you need the original format.\n                      rawResult,\n                    },\n                  },\n                } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n              }\n              // Handle tool errors\n              for (const error of this.extractToolErrors(content)) {\n                let state = toolStates.get(error.id);\n                const toolName =\n                  error.name ?? state?.name ?? ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;\n\n                this.logger.debug(\n                  `[claude-code] Tool error received - Tool: ${toolName}, ID: ${error.id}`\n                );\n\n                if (!state) {\n                  this.logger.warn(\n                    `[claude-code] Received tool error for unknown tool ID: ${error.id}`\n                  );\n                  state = {\n                    name: toolName,\n                    inputStarted: true,\n                    inputClosed: true,\n                    callEmitted: false,\n                  };\n                  toolStates.set(error.id, state);\n                }\n\n                // Ensure tool-call is emitted before tool-error\n                emitToolCall(error.id, state);\n\n                const rawError =\n                  typeof error.error === 'string'\n                    ? error.error\n                    : typeof error.error === 'object' && error.error !== null\n                      ? (() => {\n                          try {\n                            return JSON.stringify(error.error);\n                          } catch {\n                            return String(error.error);\n                          }\n                        })()\n                      : String(error.error);\n\n                controller.enqueue({\n                  type: 'tool-error',\n                  toolCallId: error.id,\n                  toolName,\n                  error: rawError,\n                  providerExecuted: true,\n                  dynamic: true, // V3 field: indicates tool is provider-defined\n                  providerMetadata: {\n                    'claude-code': {\n                      rawError,\n                    },\n                  },\n                } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n              }\n            } else if (message.type === 'result') {\n              done();\n\n              // Handle structured output errors (SDK 0.1.45+)\n              // Use string comparison to support new SDK subtypes not yet in TypeScript definitions\n              if ((message.subtype as string) === 'error_max_structured_output_retries') {\n                throw new Error(\n                  'Failed to generate valid structured output after maximum retries. The model could not produce a response matching the required schema.'\n                );\n              }\n\n              this.logger.info(\n                `[claude-code] Stream completed - Session: ${message.session_id}, Cost: $${message.total_cost_usd?.toFixed(4) ?? 'N/A'}, Duration: ${message.duration_ms ?? 'N/A'}ms`\n              );\n\n              let rawUsage: unknown | undefined;\n              if ('usage' in message) {\n                rawUsage = message.usage;\n                usage = {\n                  inputTokens:\n                    (message.usage.cache_creation_input_tokens ?? 0) +\n                    (message.usage.cache_read_input_tokens ?? 0) +\n                    (message.usage.input_tokens ?? 0),\n                  outputTokens: message.usage.output_tokens ?? 0,\n                  totalTokens:\n                    (message.usage.cache_creation_input_tokens ?? 0) +\n                    (message.usage.cache_read_input_tokens ?? 0) +\n                    (message.usage.input_tokens ?? 0) +\n                    (message.usage.output_tokens ?? 0),\n                };\n\n                this.logger.debug(\n                  `[claude-code] Stream token usage - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`\n                );\n              }\n\n              const finishReason: LanguageModelV2FinishReason = mapClaudeCodeFinishReason(\n                message.subtype\n              );\n\n              this.logger.debug(`[claude-code] Stream finish reason: ${finishReason}`);\n\n              // Store session ID in the model instance\n              this.setSessionId(message.session_id);\n\n              // Use structured output from SDK if available (native JSON schema support)\n              const structuredOutput =\n                'structured_output' in message ? message.structured_output : undefined;\n\n              // Check if we've already streamed JSON via input_json_delta\n              const alreadyStreamedJson =\n                textPartId && options.responseFormat?.type === 'json' && hasReceivedStreamEvents;\n\n              if (alreadyStreamedJson && textPartId) {\n                // We've already streamed JSON deltas, just close the text part\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n              } else if (structuredOutput !== undefined) {\n                // Emit structured output as text (fallback when streaming didn't occur)\n                const jsonTextId = generateId();\n                const jsonText = JSON.stringify(structuredOutput);\n                controller.enqueue({\n                  type: 'text-start',\n                  id: jsonTextId,\n                });\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: jsonTextId,\n                  delta: jsonText,\n                });\n                controller.enqueue({\n                  type: 'text-end',\n                  id: jsonTextId,\n                });\n              } else if (textPartId) {\n                // Close the text part if it was opened (non-JSON mode)\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n              } else if (accumulatedText) {\n                // Fallback for JSON mode without schema: emit accumulated text\n                // This handles the case where responseFormat.type === 'json' but no schema\n                // was provided, so the SDK returns plain text instead of structured_output\n                const fallbackTextId = generateId();\n                controller.enqueue({\n                  type: 'text-start',\n                  id: fallbackTextId,\n                });\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: fallbackTextId,\n                  delta: accumulatedText,\n                });\n                controller.enqueue({\n                  type: 'text-end',\n                  id: fallbackTextId,\n                });\n              }\n\n              finalizeToolCalls();\n\n              // Prepare JSON-safe warnings for provider metadata\n              const warningsJson = this.serializeWarningsForMetadata(streamWarnings);\n\n              controller.enqueue({\n                type: 'finish',\n                finishReason,\n                usage,\n                providerMetadata: {\n                  'claude-code': {\n                    sessionId: message.session_id,\n                    ...(message.total_cost_usd !== undefined && {\n                      costUsd: message.total_cost_usd,\n                    }),\n                    ...(message.duration_ms !== undefined && { durationMs: message.duration_ms }),\n                    ...(rawUsage !== undefined && { rawUsage: rawUsage as JSONValue }),\n                    // JSON validation warnings are collected during streaming and included\n                    // in providerMetadata since the AI SDK's finish event doesn't support\n                    // a top-level warnings field (unlike stream-start which was already emitted)\n                    ...(streamWarnings.length > 0 && {\n                      warnings: warningsJson as unknown as JSONValue,\n                    }),\n                  },\n                },\n              });\n            } else if (message.type === 'system' && message.subtype === 'init') {\n              // Store session ID for future use\n              this.setSessionId(message.session_id);\n\n              this.logger.info(`[claude-code] Stream session initialized: ${message.session_id}`);\n\n              // Emit response metadata when session is initialized\n              controller.enqueue({\n                type: 'response-metadata',\n                id: message.session_id,\n                timestamp: new Date(),\n                modelId: this.modelId,\n              });\n            }\n          }\n\n          finalizeToolCalls();\n          this.logger.debug('[claude-code] Stream finalized, closing stream');\n          controller.close();\n        } catch (error: unknown) {\n          done();\n\n          this.logger.debug(\n            `[claude-code] Error during doStream: ${error instanceof Error ? error.message : String(error)}`\n          );\n\n          if (isClaudeCodeTruncationError(error, accumulatedText)) {\n            this.logger.warn(\n              `[claude-code] Detected truncated stream response, returning ${accumulatedText.length} characters of buffered text`\n            );\n            const truncationWarning: LanguageModelV2CallWarning = {\n              type: 'other',\n              message: CLAUDE_CODE_TRUNCATION_WARNING,\n            };\n            streamWarnings.push(truncationWarning);\n\n            if (textPartId) {\n              controller.enqueue({\n                type: 'text-end',\n                id: textPartId,\n              });\n            } else if (accumulatedText) {\n              const fallbackTextId = generateId();\n              controller.enqueue({\n                type: 'text-start',\n                id: fallbackTextId,\n              });\n              controller.enqueue({\n                type: 'text-delta',\n                id: fallbackTextId,\n                delta: accumulatedText,\n              });\n              controller.enqueue({\n                type: 'text-end',\n                id: fallbackTextId,\n              });\n            }\n\n            finalizeToolCalls();\n\n            const warningsJson = this.serializeWarningsForMetadata(streamWarnings);\n\n            controller.enqueue({\n              type: 'finish',\n              finishReason: 'length',\n              usage,\n              providerMetadata: {\n                'claude-code': {\n                  ...(this.sessionId !== undefined && { sessionId: this.sessionId }),\n                  truncated: true,\n                  ...(streamWarnings.length > 0 && {\n                    warnings: warningsJson as unknown as JSONValue,\n                  }),\n                },\n              },\n            });\n\n            controller.close();\n            return;\n          }\n\n          finalizeToolCalls();\n          let errorToEmit: unknown;\n\n          // Special handling for AbortError to preserve abort signal reason\n          if (isAbortError(error)) {\n            errorToEmit = options.abortSignal?.aborted ? options.abortSignal.reason : error;\n          } else {\n            // Use unified error handler\n            errorToEmit = this.handleClaudeCodeError(error, messagesPrompt, collectedStderr);\n          }\n\n          // Emit error as a stream part\n          controller.enqueue({\n            type: 'error',\n            error: errorToEmit,\n          });\n\n          controller.close();\n        } finally {\n          if (options.abortSignal && abortListener) {\n            options.abortSignal.removeEventListener('abort', abortListener);\n          }\n        }\n      },\n      cancel: () => {\n        if (options.abortSignal && abortListener) {\n          options.abortSignal.removeEventListener('abort', abortListener);\n        }\n      },\n    });\n\n    return {\n      stream: stream as unknown as ReadableStream<LanguageModelV2StreamPart>,\n      request: {\n        body: messagesPrompt,\n      },\n    };\n  }\n\n  private serializeWarningsForMetadata(warnings: LanguageModelV2CallWarning[]): JSONValue {\n    const result = warnings.map((w) => {\n      const base: Record<string, string> = { type: w.type };\n      if ('message' in w) {\n        const m = (w as { message?: unknown }).message;\n        if (m !== undefined) base.message = String(m);\n      }\n      if (w.type === 'unsupported-setting') {\n        const setting = (w as { setting: unknown }).setting;\n        if (setting !== undefined) base.setting = String(setting);\n        if ('details' in w) {\n          const d = (w as { details?: unknown }).details;\n          if (d !== undefined) base.details = String(d);\n        }\n      }\n      return base;\n    });\n    return result as unknown as JSONValue;\n  }\n}\n","import type { ModelMessage } from 'ai';\nimport type { SDKUserMessage } from '@anthropic-ai/claude-agent-sdk';\n\ntype SDKUserContentPart = SDKUserMessage['message']['content'][number];\n\ninterface StreamingSegment {\n  formatted: string;\n}\n\nconst IMAGE_URL_WARNING = 'Image URLs are not supported by this provider; supply base64/data URLs.';\nconst IMAGE_CONVERSION_WARNING = 'Unable to convert image content; supply base64/data URLs.';\n\nfunction normalizeBase64(base64: string): string {\n  return base64.replace(/\\s+/g, '');\n}\n\nfunction isImageMimeType(mimeType?: string): boolean {\n  return typeof mimeType === 'string' && mimeType.trim().toLowerCase().startsWith('image/');\n}\n\nfunction createImageContent(mediaType: string, data: string): SDKUserContentPart | undefined {\n  const trimmedType = mediaType.trim();\n  const trimmedData = normalizeBase64(data.trim());\n\n  if (!trimmedType || !trimmedData) {\n    return undefined;\n  }\n\n  return {\n    type: 'image',\n    source: {\n      type: 'base64',\n      media_type: trimmedType,\n      data: trimmedData,\n    },\n  } as SDKUserContentPart;\n}\n\nfunction extractMimeType(candidate: unknown): string | undefined {\n  if (typeof candidate === 'string' && candidate.trim()) {\n    return candidate.trim();\n  }\n  return undefined;\n}\n\nfunction parseObjectImage(\n  imageObj: Record<string, unknown>,\n  fallbackMimeType?: string\n): SDKUserContentPart | undefined {\n  const data = typeof imageObj.data === 'string' ? imageObj.data : undefined;\n  const mimeType = extractMimeType(\n    imageObj.mimeType ?? imageObj.mediaType ?? imageObj.media_type ?? fallbackMimeType\n  );\n  if (!data || !mimeType) {\n    return undefined;\n  }\n  return createImageContent(mimeType, data);\n}\n\nfunction parseStringImage(\n  value: string,\n  fallbackMimeType?: string\n): { content?: SDKUserContentPart; warning?: string } {\n  const trimmed = value.trim();\n\n  if (/^https?:\\/\\//i.test(trimmed)) {\n    return { warning: IMAGE_URL_WARNING };\n  }\n\n  const dataUrlMatch = trimmed.match(/^data:([^;]+);base64,(.+)$/i);\n  if (dataUrlMatch) {\n    const [, mediaType, data] = dataUrlMatch;\n    const content = createImageContent(mediaType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  const base64Match = trimmed.match(/^base64:([^,]+),(.+)$/i);\n  if (base64Match) {\n    const [, explicitMimeType, data] = base64Match;\n    const content = createImageContent(explicitMimeType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  if (fallbackMimeType) {\n    const content = createImageContent(fallbackMimeType, trimmed);\n    if (content) {\n      return { content };\n    }\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\nfunction parseImagePart(part: unknown): { content?: SDKUserContentPart; warning?: string } {\n  if (!part || typeof part !== 'object') {\n    return { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  const imageValue = (part as { image?: unknown }).image;\n  const mimeType = extractMimeType((part as { mimeType?: unknown }).mimeType);\n\n  if (typeof imageValue === 'string') {\n    return parseStringImage(imageValue, mimeType);\n  }\n\n  if (imageValue && typeof imageValue === 'object') {\n    const content = parseObjectImage(imageValue as Record<string, unknown>, mimeType);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\nfunction convertBinaryToBase64(data: Uint8Array | ArrayBuffer): string | undefined {\n  if (typeof Buffer !== 'undefined') {\n    const buffer =\n      data instanceof Uint8Array ? Buffer.from(data) : Buffer.from(new Uint8Array(data));\n    return buffer.toString('base64');\n  }\n\n  if (typeof btoa === 'function') {\n    const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n    let binary = '';\n    const chunkSize = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunkSize) {\n      const chunk = bytes.subarray(i, i + chunkSize);\n      binary += String.fromCharCode(...chunk);\n    }\n    return btoa(binary);\n  }\n\n  return undefined;\n}\n\ntype FileLikePart = {\n  mediaType?: unknown;\n  mimeType?: unknown;\n  data?: unknown;\n};\n\nfunction parseFilePart(part: FileLikePart): { content?: SDKUserContentPart; warning?: string } {\n  const mimeType = extractMimeType(part.mediaType ?? part.mimeType);\n  if (!mimeType || !isImageMimeType(mimeType)) {\n    return {};\n  }\n\n  const data = part.data;\n  if (typeof data === 'string') {\n    const content = createImageContent(mimeType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  if (\n    data instanceof Uint8Array ||\n    (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer)\n  ) {\n    const base64 = convertBinaryToBase64(data);\n    if (!base64) {\n      return { warning: IMAGE_CONVERSION_WARNING };\n    }\n    const content = createImageContent(mimeType, base64);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\n/**\n * Converts AI SDK prompt format to Claude Code SDK message format.\n * Handles system prompts, user messages, assistant responses, and tool interactions.\n *\n * @param prompt - The AI SDK prompt containing messages\n * @returns An object containing the formatted message prompt and optional system prompt\n *\n * @example\n * ```typescript\n * const { messagesPrompt } = convertToClaudeCodeMessages(\n *   [{ role: 'user', content: 'Hello!' }]\n * );\n * ```\n *\n * @remarks\n * - Image parts are collected for streaming input; unsupported variants produce warnings\n * - Tool calls are simplified to \"[Tool calls made]\" notation\n * - JSON schema enforcement is handled natively by the SDK's outputFormat option (v0.1.45+)\n */\nexport function convertToClaudeCodeMessages(prompt: readonly ModelMessage[]): {\n  messagesPrompt: string;\n  systemPrompt?: string;\n  warnings?: string[];\n  streamingContentParts: SDKUserMessage['message']['content'];\n  hasImageParts: boolean;\n} {\n  const messages: string[] = [];\n  const warnings: string[] = [];\n  let systemPrompt: string | undefined;\n  const streamingSegments: StreamingSegment[] = [];\n  const imageMap = new Map<number, SDKUserContentPart[]>();\n  let hasImageParts = false;\n\n  const addSegment = (formatted: string): number => {\n    streamingSegments.push({ formatted });\n    return streamingSegments.length - 1;\n  };\n\n  const addImageForSegment = (segmentIndex: number, content: SDKUserContentPart): void => {\n    hasImageParts = true;\n    if (!imageMap.has(segmentIndex)) {\n      imageMap.set(segmentIndex, []);\n    }\n    imageMap.get(segmentIndex)?.push(content);\n  };\n\n  for (const message of prompt) {\n    switch (message.role) {\n      case 'system':\n        systemPrompt = message.content;\n        if (typeof message.content === 'string' && message.content.trim().length > 0) {\n          addSegment(message.content);\n        } else {\n          addSegment('');\n        }\n        break;\n\n      case 'user':\n        if (typeof message.content === 'string') {\n          messages.push(message.content);\n          addSegment(`Human: ${message.content}`);\n        } else {\n          // Handle multi-part content\n          const textParts = message.content\n            .filter((part) => part.type === 'text')\n            .map((part) => part.text)\n            .join('\\n');\n\n          const segmentIndex = addSegment(textParts ? `Human: ${textParts}` : '');\n\n          if (textParts) {\n            messages.push(textParts);\n          }\n\n          for (const part of message.content) {\n            if (part.type === 'image') {\n              const { content, warning } = parseImagePart(part);\n              if (content) {\n                addImageForSegment(segmentIndex, content);\n              } else if (warning) {\n                warnings.push(warning);\n              }\n            } else if (part.type === 'file') {\n              const { content, warning } = parseFilePart(part);\n              if (content) {\n                addImageForSegment(segmentIndex, content);\n              } else if (warning) {\n                warnings.push(warning);\n              }\n            }\n          }\n        }\n        break;\n\n      case 'assistant': {\n        let assistantContent = '';\n        if (typeof message.content === 'string') {\n          assistantContent = message.content;\n        } else {\n          const textParts = message.content\n            .filter((part) => part.type === 'text')\n            .map((part) => part.text)\n            .join('\\n');\n\n          if (textParts) {\n            assistantContent = textParts;\n          }\n\n          // Handle tool calls if present\n          const toolCalls = message.content.filter((part) => part.type === 'tool-call');\n          if (toolCalls.length > 0) {\n            // For now, we'll just note that tool calls were made\n            assistantContent += `\\n[Tool calls made]`;\n          }\n        }\n        const formattedAssistant = `Assistant: ${assistantContent}`;\n        messages.push(formattedAssistant);\n        addSegment(formattedAssistant);\n        break;\n      }\n\n      case 'tool':\n        // Tool results could be included in the conversation\n        for (const tool of message.content) {\n          const resultText =\n            tool.output.type === 'text' ? tool.output.value : JSON.stringify(tool.output.value);\n          const formattedToolResult = `Tool Result (${tool.toolName}): ${resultText}`;\n          messages.push(formattedToolResult);\n          addSegment(formattedToolResult);\n        }\n        break;\n    }\n  }\n\n  // For the SDK, we need to provide a single prompt string\n  // Format the conversation history properly\n\n  // Combine system prompt with messages\n  let finalPrompt = '';\n\n  // Add system prompt at the beginning if present\n  if (systemPrompt) {\n    finalPrompt = systemPrompt;\n  }\n\n  if (messages.length > 0) {\n    // Format messages\n    const formattedMessages = [];\n    for (let i = 0; i < messages.length; i++) {\n      const msg = messages[i];\n      // Check if this is a user or assistant message based on content\n      if (msg.startsWith('Assistant:') || msg.startsWith('Tool Result')) {\n        formattedMessages.push(msg);\n      } else {\n        // User messages\n        formattedMessages.push(`Human: ${msg}`);\n      }\n    }\n\n    // Combine system prompt with messages\n    if (finalPrompt) {\n      const joinedMessages = formattedMessages.join('\\n\\n');\n      finalPrompt = joinedMessages ? `${finalPrompt}\\n\\n${joinedMessages}` : finalPrompt;\n    } else {\n      finalPrompt = formattedMessages.join('\\n\\n');\n    }\n  }\n\n  // Build streaming parts including text and images\n  const streamingParts: SDKUserContentPart[] = [];\n  const imagePartsInOrder: SDKUserContentPart[] = [];\n\n  const appendImagesForIndex = (index: number) => {\n    const images = imageMap.get(index);\n    if (!images) {\n      return;\n    }\n    images.forEach((image) => {\n      streamingParts.push(image);\n      imagePartsInOrder.push(image);\n    });\n  };\n\n  if (streamingSegments.length > 0) {\n    let accumulatedText = '';\n    let emittedText = false;\n\n    const flushText = () => {\n      if (!accumulatedText) {\n        return;\n      }\n      streamingParts.push({ type: 'text', text: accumulatedText });\n      accumulatedText = '';\n      emittedText = true;\n    };\n\n    streamingSegments.forEach((segment, index) => {\n      const segmentText = segment.formatted;\n      if (segmentText) {\n        if (!accumulatedText) {\n          accumulatedText = emittedText ? `\\n\\n${segmentText}` : segmentText;\n        } else {\n          accumulatedText += `\\n\\n${segmentText}`;\n        }\n      }\n\n      if (imageMap.has(index)) {\n        flushText();\n        appendImagesForIndex(index);\n      }\n    });\n\n    flushText();\n  }\n\n  // Note: JSON schema enforcement is now handled natively by the SDK's outputFormat option (v0.1.45+)\n  // No prompt injection needed - structured outputs are guaranteed by the SDK\n\n  return {\n    messagesPrompt: finalPrompt,\n    systemPrompt,\n    ...(warnings.length > 0 && { warnings }),\n    streamingContentParts:\n      streamingParts.length > 0\n        ? (streamingParts as SDKUserMessage['message']['content'])\n        : ([\n            { type: 'text', text: finalPrompt },\n            ...imagePartsInOrder,\n          ] as SDKUserMessage['message']['content']),\n    hasImageParts,\n  };\n}\n","import { APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\n\n/**\n * Metadata associated with Claude Code SDK errors.\n * Provides additional context about command execution failures.\n */\nexport interface ClaudeCodeErrorMetadata {\n  /**\n   * Error code from the CLI process (e.g., 'ENOENT', 'ETIMEDOUT').\n   */\n  code?: string;\n\n  /**\n   * Exit code from the Claude Code SDK process.\n   * Common codes:\n   * - 401: Authentication error\n   * - 1: General error\n   */\n  exitCode?: number;\n\n  /**\n   * Standard error output from the CLI process.\n   */\n  stderr?: string;\n\n  /**\n   * Excerpt from the prompt that caused the error.\n   * Limited to first 200 characters for debugging.\n   */\n  promptExcerpt?: string;\n}\n\n/**\n * Creates an APICallError with Claude Code specific metadata.\n * Used for general CLI execution errors.\n *\n * @param options - Error details and metadata\n * @param options.message - Human-readable error message\n * @param options.code - Error code from the CLI process\n * @param options.exitCode - Exit code from the CLI\n * @param options.stderr - Standard error output\n * @param options.promptExcerpt - Excerpt of the prompt that caused the error\n * @param options.isRetryable - Whether the error is potentially retryable\n * @returns An APICallError instance with Claude Code metadata\n *\n * @example\n * ```typescript\n * throw createAPICallError({\n *   message: 'Claude Code SDK failed',\n *   code: 'ENOENT',\n *   isRetryable: true\n * });\n * ```\n */\nexport function createAPICallError({\n  message,\n  code,\n  exitCode,\n  stderr,\n  promptExcerpt,\n  isRetryable = false,\n}: ClaudeCodeErrorMetadata & {\n  message: string;\n  isRetryable?: boolean;\n}): APICallError {\n  const metadata: ClaudeCodeErrorMetadata = {\n    code,\n    exitCode,\n    stderr,\n    promptExcerpt,\n  };\n\n  return new APICallError({\n    message,\n    isRetryable,\n    url: 'claude-code-cli://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : undefined,\n    data: metadata,\n  });\n}\n\n/**\n * Creates an authentication error for Claude Code SDK login failures.\n *\n * @param options - Error configuration\n * @param options.message - Error message describing the authentication failure\n * @returns A LoadAPIKeyError instance\n *\n * @example\n * ```typescript\n * throw createAuthenticationError({\n *   message: 'Please run \"claude login\" to authenticate'\n * });\n * ```\n */\nexport function createAuthenticationError({ message }: { message: string }): LoadAPIKeyError {\n  return new LoadAPIKeyError({\n    message:\n      message || 'Authentication failed. Please ensure Claude Code SDK is properly authenticated.',\n  });\n}\n\n/**\n * Creates a timeout error for Claude Code SDK operations.\n *\n * @param options - Timeout error details\n * @param options.message - Error message describing the timeout\n * @param options.promptExcerpt - Excerpt of the prompt that timed out\n * @param options.timeoutMs - Timeout duration in milliseconds\n * @returns An APICallError instance configured as a timeout error\n *\n * @example\n * ```typescript\n * throw createTimeoutError({\n *   message: 'Request timed out after 2 minutes',\n *   timeoutMs: 120000\n * });\n * ```\n */\nexport function createTimeoutError({\n  message,\n  promptExcerpt,\n  timeoutMs,\n}: {\n  message: string;\n  promptExcerpt?: string;\n  timeoutMs?: number;\n}): APICallError {\n  // Store timeoutMs in metadata for potential use by error handlers\n  const metadata: ClaudeCodeErrorMetadata = {\n    code: 'TIMEOUT',\n    promptExcerpt,\n  };\n\n  return new APICallError({\n    message,\n    isRetryable: true,\n    url: 'claude-code-cli://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : undefined,\n    data: timeoutMs !== undefined ? { ...metadata, timeoutMs } : metadata,\n  });\n}\n\n/**\n * Checks if an error is an authentication error.\n * Returns true for LoadAPIKeyError instances or APICallError with exit code 401.\n *\n * @param error - The error to check\n * @returns True if the error is an authentication error\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   if (isAuthenticationError(error)) {\n *     console.log('Please authenticate with Claude Code SDK');\n *   }\n * }\n * ```\n */\nexport function isAuthenticationError(error: unknown): boolean {\n  if (error instanceof LoadAPIKeyError) return true;\n  if (error instanceof APICallError && (error.data as ClaudeCodeErrorMetadata)?.exitCode === 401)\n    return true;\n  return false;\n}\n\n/**\n * Checks if an error is a timeout error.\n * Returns true for APICallError instances with code 'TIMEOUT'.\n *\n * @param error - The error to check\n * @returns True if the error is a timeout error\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   if (isTimeoutError(error)) {\n *     console.log('Request timed out, consider retrying');\n *   }\n * }\n * ```\n */\nexport function isTimeoutError(error: unknown): boolean {\n  if (error instanceof APICallError && (error.data as ClaudeCodeErrorMetadata)?.code === 'TIMEOUT')\n    return true;\n  return false;\n}\n\n/**\n * Extracts Claude Code error metadata from an error object.\n *\n * @param error - The error to extract metadata from\n * @returns The error metadata if available, undefined otherwise\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   const metadata = getErrorMetadata(error);\n *   if (metadata?.exitCode === 401) {\n *     console.log('Authentication required');\n *   }\n * }\n * ```\n */\nexport function getErrorMetadata(error: unknown): ClaudeCodeErrorMetadata | undefined {\n  if (error instanceof APICallError && error.data) {\n    return error.data as ClaudeCodeErrorMetadata;\n  }\n  return undefined;\n}\n","import type { LanguageModelV2FinishReason } from '@ai-sdk/provider';\n\n/**\n * Maps Claude Code SDK result subtypes to AI SDK finish reasons.\n *\n * @param subtype - The result subtype from Claude Code SDK\n * @returns The corresponding AI SDK finish reason\n *\n * @example\n * ```typescript\n * const finishReason = mapClaudeCodeFinishReason('error_max_turns');\n * // Returns: 'length'\n * ```\n *\n * @remarks\n * Mappings:\n * - 'success' -> 'stop' (normal completion)\n * - 'error_max_turns' -> 'length' (hit turn limit)\n * - 'error_during_execution' -> 'error' (execution error)\n * - default -> 'stop' (unknown subtypes treated as normal completion)\n */\nexport function mapClaudeCodeFinishReason(subtype?: string): LanguageModelV2FinishReason {\n  switch (subtype) {\n    case 'success':\n      return 'stop';\n    case 'error_max_turns':\n      return 'length';\n    case 'error_during_execution':\n      return 'error';\n    default:\n      return 'stop';\n  }\n}\n","import { z } from 'zod';\nimport { existsSync } from 'fs';\n\n/**\n * Validation schemas and utilities for Claude Code provider inputs.\n * Uses Zod for type-safe validation following AI SDK patterns.\n */\n\n// Helper for Zod v3/v4 compatibility\n// Use a simple z.any() for functions to work with both versions\nconst loggerFunctionSchema = z.object({\n  debug: z.any().refine((val) => typeof val === 'function', {\n    message: 'debug must be a function',\n  }),\n  info: z.any().refine((val) => typeof val === 'function', {\n    message: 'info must be a function',\n  }),\n  warn: z.any().refine((val) => typeof val === 'function', {\n    message: 'warn must be a function',\n  }),\n  error: z.any().refine((val) => typeof val === 'function', {\n    message: 'error must be a function',\n  }),\n});\n\n/**\n * Schema for validating Claude Code settings.\n * Ensures all settings are within acceptable ranges and formats.\n */\nexport const claudeCodeSettingsSchema = z\n  .object({\n    pathToClaudeCodeExecutable: z.string().optional(),\n    customSystemPrompt: z.string().optional(),\n    appendSystemPrompt: z.string().optional(),\n    systemPrompt: z\n      .union([\n        z.string(),\n        z.object({\n          type: z.literal('preset'),\n          preset: z.literal('claude_code'),\n          append: z.string().optional(),\n        }),\n      ])\n      .optional(),\n    maxTurns: z.number().int().min(1).max(100).optional(),\n    maxThinkingTokens: z.number().int().positive().max(100000).optional(),\n    cwd: z\n      .string()\n      .refine(\n        (val) => {\n          // Skip directory validation in non-Node environments\n          if (typeof process === 'undefined' || !process.versions?.node) {\n            return true;\n          }\n          return !val || existsSync(val);\n        },\n        { message: 'Working directory must exist' }\n      )\n      .optional(),\n    executable: z.enum(['bun', 'deno', 'node']).optional(),\n    executableArgs: z.array(z.string()).optional(),\n    permissionMode: z.enum(['default', 'acceptEdits', 'bypassPermissions', 'plan']).optional(),\n    permissionPromptToolName: z.string().optional(),\n    continue: z.boolean().optional(),\n    resume: z.string().optional(),\n    allowedTools: z.array(z.string()).optional(),\n    disallowedTools: z.array(z.string()).optional(),\n    betas: z.array(z.string()).optional(),\n    allowDangerouslySkipPermissions: z.boolean().optional(),\n    enableFileCheckpointing: z.boolean().optional(),\n    maxBudgetUsd: z.number().min(0).optional(),\n    plugins: z\n      .array(\n        z\n          .object({\n            type: z.string(),\n            path: z.string(),\n          })\n          .passthrough()\n      )\n      .optional(),\n    resumeSessionAt: z.string().optional(),\n    sandbox: z\n      .any()\n      .refine((val) => val === undefined || typeof val === 'object', {\n        message: 'sandbox must be an object',\n      })\n      .optional(),\n    tools: z\n      .union([\n        z.array(z.string()),\n        z.object({\n          type: z.literal('preset'),\n          preset: z.literal('claude_code'),\n        }),\n      ])\n      .optional(),\n    settingSources: z.array(z.enum(['user', 'project', 'local'])).optional(),\n    streamingInput: z.enum(['auto', 'always', 'off']).optional(),\n    // Hooks and tool-permission callback (permissive validation of shapes)\n    canUseTool: z\n      .any()\n      .refine((v) => v === undefined || typeof v === 'function', {\n        message: 'canUseTool must be a function',\n      })\n      .optional(),\n    hooks: z\n      .record(\n        z.string(),\n        z.array(\n          z.object({\n            matcher: z.string().optional(),\n            hooks: z.array(z.any()).nonempty(),\n          })\n        )\n      )\n      .optional(),\n    mcpServers: z\n      .record(\n        z.string(),\n        z.union([\n          // McpStdioServerConfig\n          z.object({\n            type: z.literal('stdio').optional(),\n            command: z.string(),\n            args: z.array(z.string()).optional(),\n            env: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpSSEServerConfig\n          z.object({\n            type: z.literal('sse'),\n            url: z.string(),\n            headers: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpHttpServerConfig\n          z.object({\n            type: z.literal('http'),\n            url: z.string(),\n            headers: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpSdkServerConfig (in-process custom tools)\n          z.object({\n            type: z.literal('sdk'),\n            name: z.string(),\n            instance: z.any(),\n          }),\n        ])\n      )\n      .optional(),\n    verbose: z.boolean().optional(),\n    logger: z.union([z.literal(false), loggerFunctionSchema]).optional(),\n    env: z.record(z.string(), z.string().optional()).optional(),\n    additionalDirectories: z.array(z.string()).optional(),\n    agents: z\n      .record(\n        z.string(),\n        z.object({\n          description: z.string(),\n          tools: z.array(z.string()).optional(),\n          prompt: z.string(),\n          model: z.enum(['sonnet', 'opus', 'haiku', 'inherit']).optional(),\n        })\n      )\n      .optional(),\n    includePartialMessages: z.boolean().optional(),\n    fallbackModel: z.string().optional(),\n    forkSession: z.boolean().optional(),\n    stderr: z\n      .any()\n      .refine((val) => val === undefined || typeof val === 'function', {\n        message: 'stderr must be a function',\n      })\n      .optional(),\n    strictMcpConfig: z.boolean().optional(),\n    extraArgs: z.record(z.string(), z.union([z.string(), z.null()])).optional(),\n    sdkOptions: z.record(z.string(), z.any()).optional(),\n  })\n  .strict();\n\n/**\n * Validates a model ID and returns warnings if needed.\n *\n * @param modelId - The model ID to validate\n * @returns Warning message if model is unknown, undefined otherwise\n */\nexport function validateModelId(modelId: string): string | undefined {\n  const knownModels = ['opus', 'sonnet', 'haiku'];\n\n  // Check for empty or whitespace-only\n  if (!modelId || modelId.trim() === '') {\n    throw new Error('Model ID cannot be empty');\n  }\n\n  // Warn about unknown models but allow them\n  if (!knownModels.includes(modelId)) {\n    return `Unknown model ID: '${modelId}'. Proceeding with custom model. Known models are: ${knownModels.join(', ')}`;\n  }\n\n  return undefined;\n}\n\n/**\n * Validates Claude Code settings and returns validation results.\n *\n * @param settings - The settings object to validate\n * @returns Object with validation results and any warnings\n */\nexport function validateSettings(settings: unknown): {\n  valid: boolean;\n  warnings: string[];\n  errors: string[];\n} {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  try {\n    // Parse with Zod schema\n    const result = claudeCodeSettingsSchema.safeParse(settings);\n\n    if (!result.success) {\n      // Extract user-friendly error messages\n      // Support both Zod v3 (errors) and v4 (issues)\n      const errorObject = result.error as {\n        errors?: Array<{ path: string[]; message: string }>;\n        issues?: Array<{ path: string[]; message: string }>;\n      };\n      const issues = errorObject.errors || errorObject.issues || [];\n      issues.forEach((err: { path: string[]; message: string }) => {\n        const path = err.path.join('.');\n        errors.push(`${path ? `${path}: ` : ''}${err.message}`);\n      });\n      return { valid: false, warnings, errors };\n    }\n\n    // Additional validation warnings\n    const validSettings = result.data;\n\n    // Warn about high turn limits\n    if (validSettings.maxTurns && validSettings.maxTurns > 20) {\n      warnings.push(\n        `High maxTurns value (${validSettings.maxTurns}) may lead to long-running conversations`\n      );\n    }\n\n    // Warn about very high thinking tokens\n    if (validSettings.maxThinkingTokens && validSettings.maxThinkingTokens > 50000) {\n      warnings.push(\n        `Very high maxThinkingTokens (${validSettings.maxThinkingTokens}) may increase response time`\n      );\n    }\n\n    // Check if both allowedTools and disallowedTools are specified\n    if (validSettings.allowedTools && validSettings.disallowedTools) {\n      warnings.push(\n        'Both allowedTools and disallowedTools are specified. Only allowedTools will be used.'\n      );\n    }\n\n    // Validate tool name format\n    const validateToolNames = (tools: string[], type: string) => {\n      tools.forEach((tool) => {\n        // Basic validation - tool names should be alphanumeric with optional specifiers\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\\([^)]*\\))?$/.test(tool) && !tool.startsWith('mcp__')) {\n          warnings.push(`Unusual ${type} tool name format: '${tool}'`);\n        }\n      });\n    };\n\n    if (validSettings.allowedTools) {\n      validateToolNames(validSettings.allowedTools, 'allowed');\n    }\n\n    if (validSettings.disallowedTools) {\n      validateToolNames(validSettings.disallowedTools, 'disallowed');\n    }\n\n    return { valid: true, warnings, errors };\n  } catch (error) {\n    errors.push(`Validation error: ${error instanceof Error ? error.message : String(error)}`);\n    return { valid: false, warnings, errors };\n  }\n}\n\n/**\n * Validates prompt length and format.\n *\n * @param prompt - The prompt to validate\n * @returns Warning message if prompt might cause issues\n */\nexport function validatePrompt(prompt: string): string | undefined {\n  // Very long prompts might cause issues\n  const MAX_PROMPT_LENGTH = 100000; // ~25k tokens\n\n  if (prompt.length > MAX_PROMPT_LENGTH) {\n    return `Very long prompt (${prompt.length} characters) may cause performance issues or timeouts`;\n  }\n\n  return undefined;\n}\n\n/**\n * Validates session ID format.\n *\n * @param sessionId - The session ID to validate\n * @returns Warning message if format is unusual\n */\nexport function validateSessionId(sessionId: string): string | undefined {\n  // Session IDs from Claude Code are typically UUID-like\n  // But we don't want to be too strict as format might change\n  if (sessionId && !/^[a-zA-Z0-9-_]+$/.test(sessionId)) {\n    return `Unusual session ID format. This may cause issues with session resumption.`;\n  }\n\n  return undefined;\n}\n","import type { Logger } from './types.js';\n\n/**\n * Default logger that uses console with level tags.\n */\nconst defaultLogger: Logger = {\n  // eslint-disable-next-line no-console\n  debug: (message: string) => console.debug(`[DEBUG] ${message}`),\n  // eslint-disable-next-line no-console\n  info: (message: string) => console.info(`[INFO] ${message}`),\n  warn: (message: string) => console.warn(`[WARN] ${message}`),\n  error: (message: string) => console.error(`[ERROR] ${message}`),\n};\n\n/**\n * No-op logger that discards all messages.\n */\nconst noopLogger: Logger = {\n  debug: () => {},\n  info: () => {},\n  warn: () => {},\n  error: () => {},\n};\n\n/**\n * Gets the appropriate logger based on configuration.\n *\n * @param logger - Logger configuration from settings\n * @returns The logger to use\n */\nexport function getLogger(logger: Logger | false | undefined): Logger {\n  if (logger === false) {\n    return noopLogger;\n  }\n\n  if (logger === undefined) {\n    return defaultLogger;\n  }\n\n  return logger;\n}\n\n/**\n * Creates a verbose-aware logger that only logs debug/info when verbose is enabled.\n * Warn and error are always logged regardless of verbose setting.\n *\n * @param logger - Base logger to wrap\n * @param verbose - Whether to enable verbose (debug/info) logging\n * @returns Logger with verbose-aware behavior\n */\nexport function createVerboseLogger(logger: Logger, verbose: boolean = false): Logger {\n  if (verbose) {\n    // When verbose is enabled, use all log levels\n    return logger;\n  }\n\n  // When verbose is disabled, only allow warn/error\n  // Bind methods to preserve 'this' context for custom loggers\n  return {\n    debug: () => {}, // No-op when not verbose\n    info: () => {}, // No-op when not verbose\n    warn: logger.warn.bind(logger),\n    error: logger.error.bind(logger),\n  };\n}\n","/**\n * Provider exports for creating and configuring Claude Code instances.\n * @module claude-code\n */\n\n/**\n * Creates a new Claude Code provider instance and the default provider instance.\n * @see {@link createClaudeCode} for creating custom provider instances\n * @see {@link claudeCode} for the default provider instance\n */\nexport { createClaudeCode, claudeCode } from './claude-code-provider.js';\n\n/**\n * Type definitions for the Claude Code provider.\n * @see {@link ClaudeCodeProvider} for the provider interface\n * @see {@link ClaudeCodeProviderSettings} for provider configuration options\n */\nexport type { ClaudeCodeProvider, ClaudeCodeProviderSettings } from './claude-code-provider.js';\n\n/**\n * Language model implementation for Claude Code.\n * This class implements the AI SDK's LanguageModelV2 interface.\n */\nexport { ClaudeCodeLanguageModel } from './claude-code-language-model.js';\n\n/**\n * Type definitions for Claude Code language models.\n * @see {@link ClaudeCodeModelId} for supported model identifiers\n * @see {@link ClaudeCodeLanguageModelOptions} for model configuration options\n */\nexport type {\n  ClaudeCodeModelId,\n  ClaudeCodeLanguageModelOptions,\n} from './claude-code-language-model.js';\n\n/**\n * Settings for configuring Claude Code behavior.\n * Includes options for customizing the CLI execution, permissions, and tool usage.\n */\nexport type { ClaudeCodeSettings, Logger } from './types.js';\n\n// Convenience re-exports from the SDK for custom tools and hooks\nexport { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';\nexport { createCustomMcpServer } from './mcp-helpers.js';\nexport type {\n  HookEvent,\n  HookCallback,\n  HookCallbackMatcher,\n  HookInput,\n  HookJSONOutput,\n  PreToolUseHookInput,\n  PostToolUseHookInput,\n  UserPromptSubmitHookInput,\n  SessionStartHookInput,\n  SessionEndHookInput,\n  CanUseTool,\n  PermissionResult,\n  PermissionUpdate,\n  PermissionBehavior,\n  PermissionRuleValue,\n  McpServerConfig,\n  McpSdkServerConfigWithInstance,\n  OutputFormat,\n} from '@anthropic-ai/claude-agent-sdk';\n\n/**\n * Error handling utilities for Claude Code.\n * These functions help create and identify specific error types.\n *\n * @see {@link isAuthenticationError} to check for authentication failures\n * @see {@link isTimeoutError} to check for timeout errors\n * @see {@link getErrorMetadata} to extract error metadata\n * @see {@link createAPICallError} to create general API errors\n * @see {@link createAuthenticationError} to create authentication errors\n * @see {@link createTimeoutError} to create timeout errors\n */\nexport {\n  isAuthenticationError,\n  isTimeoutError,\n  getErrorMetadata,\n  createAPICallError,\n  createAuthenticationError,\n  createTimeoutError,\n} from './errors.js';\n\n/**\n * Metadata associated with Claude Code errors.\n * Contains additional context about CLI execution failures.\n */\nexport type { ClaudeCodeErrorMetadata } from './errors.js';\n","import { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';\nimport type { McpSdkServerConfigWithInstance } from '@anthropic-ai/claude-agent-sdk';\nimport { type ZodRawShape, type ZodObject } from 'zod';\n\n/**\n * Optional annotations for content items, per MCP specification.\n * Validated against MCP SDK schema version 2025-06-18.\n */\ntype ContentAnnotations = {\n  /** Intended audience(s) for this content */\n  audience?: ('user' | 'assistant')[];\n  /** Priority hint (0 = least important, 1 = most important) */\n  priority?: number;\n  /** ISO 8601 timestamp of last modification */\n  lastModified?: string;\n};\n\n/**\n * Convenience helper to create an SDK MCP server from a simple tool map.\n * Each tool provides a description, a Zod object schema, and a handler.\n *\n * Type definition validated against MCP SDK specification version 2025-06-18.\n * See: https://modelcontextprotocol.io/specification/2025-06-18/server/tools\n */\nexport type MinimalCallToolResult = {\n  content: Array<\n    | {\n        /** Text content */\n        type: 'text';\n        /** The text content (plain text or structured format like JSON) */\n        text: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Image content (base64-encoded) */\n        type: 'image';\n        /** Base64-encoded image data */\n        data: string;\n        /** MIME type of the image (e.g., image/png, image/jpeg) */\n        mimeType: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Audio content (base64-encoded) */\n        type: 'audio';\n        /** Base64-encoded audio data */\n        data: string;\n        /** MIME type of the audio (e.g., audio/wav, audio/mp3) */\n        mimeType: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Embedded resource with full content (text or blob) */\n        type: 'resource';\n        /** Resource contents - either text or blob variant */\n        resource: { uri: string; _meta?: Record<string, unknown>; [key: string]: unknown } & (\n          | { text: string; mimeType?: string }\n          | { blob: string; mimeType: string }\n        );\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Resource link (reference only - no embedded content) */\n        type: 'resource_link';\n        /** URI of the resource */\n        uri: string;\n        /** Human-readable name (required per MCP spec) */\n        name: string;\n        /** Optional description of what this resource represents */\n        description?: string;\n        /** MIME type of the resource, if known */\n        mimeType?: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n  >;\n  isError?: boolean;\n  structuredContent?: Record<string, unknown>;\n  _meta?: Record<string, unknown>;\n  [key: string]: unknown;\n};\n\nexport function createCustomMcpServer<\n  Tools extends Record<\n    string,\n    {\n      description: string;\n      inputSchema: ZodObject<ZodRawShape>;\n      handler: (args: Record<string, unknown>, extra: unknown) => Promise<MinimalCallToolResult>;\n    }\n  >,\n>(config: { name: string; version?: string; tools: Tools }): McpSdkServerConfigWithInstance {\n  const defs = Object.entries(config.tools).map(([name, def]) =>\n    tool(\n      name,\n      def.description,\n      def.inputSchema.shape as ZodRawShape,\n      (args: Record<string, unknown>, extra: unknown) => def.handler(args, extra)\n    )\n  );\n  return createSdkMcpServer({ name: config.name, version: config.version, tools: defs });\n}\n"],"mappings":"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","names":["NoSuchModelError","tool","tool","content","tool","NoSuchModelError","createSdkMcpServer","tool"]}
\ No newline at end of file
+{"version":3,"sources":["../src/claude-code-provider.ts","../src/claude-code-language-model.ts","../src/convert-to-claude-code-messages.ts","../src/errors.ts","../src/map-claude-code-finish-reason.ts","../src/validation.ts","../src/logger.ts","../src/index.ts","../src/mcp-helpers.ts"],"sourcesContent":["import type { LanguageModelV2, ProviderV2 } from '@ai-sdk/provider';\nimport { NoSuchModelError } from '@ai-sdk/provider';\nimport { ClaudeCodeLanguageModel, type ClaudeCodeModelId } from './claude-code-language-model.js';\nimport type { ClaudeCodeSettings } from './types.js';\nimport { validateSettings } from './validation.js';\nimport { getLogger } from './logger.js';\n\n/**\n * Claude Code provider interface that extends the AI SDK's ProviderV1.\n * Provides methods to create language models for interacting with Claude via the CLI.\n *\n * @example\n * ```typescript\n * import { claudeCode } from 'ai-sdk-provider-claude-code';\n *\n * // Create a model instance\n * const model = claudeCode('opus');\n *\n * // Or use the explicit methods\n * const chatModel = claudeCode.chat('sonnet');\n * const languageModel = claudeCode.languageModel('opus', { maxTurns: 10 });\n * ```\n */\nexport interface ClaudeCodeProvider extends ProviderV2 {\n  /**\n   * Creates a language model instance for the specified model ID.\n   * This is a shorthand for calling `languageModel()`.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  (modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  /**\n   * Creates a language model instance for text generation.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  languageModel(modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  /**\n   * Alias for `languageModel()` to maintain compatibility with AI SDK patterns.\n   *\n   * @param modelId - The Claude model to use ('opus' or 'sonnet')\n   * @param settings - Optional settings to configure the model\n   * @returns A language model instance\n   */\n  chat(modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings): LanguageModelV2;\n\n  imageModel(modelId: string): never;\n}\n\n/**\n * Configuration options for creating a Claude Code provider instance.\n * These settings will be applied as defaults to all models created by the provider.\n *\n * @example\n * ```typescript\n * const provider = createClaudeCode({\n *   defaultSettings: {\n *     maxTurns: 5,\n *     cwd: '/path/to/project'\n *   }\n * });\n * ```\n */\nexport interface ClaudeCodeProviderSettings {\n  /**\n   * Default settings to use for all models created by this provider.\n   * Individual model settings will override these defaults.\n   */\n  defaultSettings?: ClaudeCodeSettings;\n}\n\n/**\n * Creates a Claude Code provider instance with the specified configuration.\n * The provider can be used to create language models for interacting with Claude 4 models.\n *\n * @param options - Provider configuration options\n * @returns Claude Code provider instance\n *\n * @example\n * ```typescript\n * const provider = createClaudeCode({\n *   defaultSettings: {\n *     permissionMode: 'bypassPermissions',\n *     maxTurns: 10\n *   }\n * });\n *\n * const model = provider('opus');\n * ```\n */\nexport function createClaudeCode(options: ClaudeCodeProviderSettings = {}): ClaudeCodeProvider {\n  // Get logger from default settings if provided\n  const logger = getLogger(options.defaultSettings?.logger);\n\n  // Validate default settings if provided\n  if (options.defaultSettings) {\n    const validation = validateSettings(options.defaultSettings);\n    if (!validation.valid) {\n      throw new Error(`Invalid default settings: ${validation.errors.join(', ')}`);\n    }\n    if (validation.warnings.length > 0) {\n      validation.warnings.forEach((warning) => logger.warn(`Claude Code Provider: ${warning}`));\n    }\n  }\n\n  const createModel = (\n    modelId: ClaudeCodeModelId,\n    settings: ClaudeCodeSettings = {}\n  ): LanguageModelV2 => {\n    const mergedSettings = {\n      ...options.defaultSettings,\n      ...settings,\n    };\n\n    // Validate merged settings\n    const validation = validateSettings(mergedSettings);\n    if (!validation.valid) {\n      throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);\n    }\n\n    return new ClaudeCodeLanguageModel({\n      id: modelId,\n      settings: mergedSettings,\n      settingsValidationWarnings: validation.warnings,\n    });\n  };\n\n  const provider = function (modelId: ClaudeCodeModelId, settings?: ClaudeCodeSettings) {\n    if (new.target) {\n      throw new Error('The Claude Code model function cannot be called with the new keyword.');\n    }\n\n    return createModel(modelId, settings);\n  };\n\n  provider.languageModel = createModel;\n  provider.chat = createModel; // Alias for languageModel\n\n  // Add textEmbeddingModel method that throws NoSuchModelError\n  provider.textEmbeddingModel = (modelId: string) => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: 'textEmbeddingModel',\n    });\n  };\n\n  provider.imageModel = (modelId: string) => {\n    throw new NoSuchModelError({\n      modelId,\n      modelType: 'imageModel',\n    });\n  };\n\n  return provider as ClaudeCodeProvider;\n}\n\n/**\n * Default Claude Code provider instance.\n * Pre-configured provider for quick usage without custom settings.\n *\n * @example\n * ```typescript\n * import { claudeCode } from 'ai-sdk-provider-claude-code';\n * import { generateText } from 'ai';\n *\n * const { text } = await generateText({\n *   model: claudeCode('sonnet'),\n *   prompt: 'Hello, Claude!'\n * });\n * ```\n */\nexport const claudeCode = createClaudeCode();\n","import type {\n  LanguageModelV2,\n  LanguageModelV2CallWarning,\n  LanguageModelV2FinishReason,\n  LanguageModelV2StreamPart,\n  LanguageModelV2Usage,\n  JSONValue,\n} from '@ai-sdk/provider';\nimport { NoSuchModelError, APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/provider-utils';\nimport type { ToolSet } from 'ai';\nimport type { ClaudeCodeSettings, Logger } from './types.js';\n\nimport { convertToClaudeCodeMessages } from './convert-to-claude-code-messages.js';\nimport { createAPICallError, createAuthenticationError, createTimeoutError } from './errors.js';\nimport { mapClaudeCodeFinishReason } from './map-claude-code-finish-reason.js';\nimport { validateModelId, validatePrompt, validateSessionId } from './validation.js';\nimport { getLogger, createVerboseLogger } from './logger.js';\n\nimport {\n  query,\n  type Options,\n  createSdkMcpServer,\n  tool,\n  type McpServerConfig,\n} from '@anthropic-ai/claude-agent-sdk';\nimport type { SDKUserMessage, SDKPartialAssistantMessage } from '@anthropic-ai/claude-agent-sdk';\nimport { type ZodRawShape } from 'zod';\nimport type { MinimalCallToolResult } from './mcp-helpers.js';\n\nconst CLAUDE_CODE_TRUNCATION_WARNING =\n  'Claude Code SDK output ended unexpectedly; returning truncated response from buffered text. Await upstream fix to avoid data loss.';\n\nconst MIN_TRUNCATION_LENGTH = 512;\n\n/**\n * Detects if an error represents a truncated SDK JSON stream.\n *\n * The Claude Code SDK can truncate JSON responses mid-stream, producing a SyntaxError.\n * This function distinguishes genuine truncation from normal JSON syntax errors by:\n * 1. Verifying the error is a SyntaxError with truncation-specific messages\n * 2. Ensuring we received meaningful content (>= MIN_TRUNCATION_LENGTH characters)\n * 3. Avoiding false positives from unrelated parse errors\n *\n * Note: We compare against `bufferedText` (assistant text content) rather than the raw\n * JSON buffer length, since the SDK layer doesn't expose buffer positions. The position\n * reported in SyntaxError messages measures the full JSON payload (metadata + content),\n * which is typically much larger than extracted text. Therefore, we cannot reliably use\n * position proximity checks and instead rely on message patterns and content length.\n *\n * @param error - The caught error (expected to be SyntaxError for truncation)\n * @param bufferedText - Accumulated assistant text content (measured in UTF-16 code units)\n * @returns true if error indicates SDK truncation; false otherwise\n */\nfunction isClaudeCodeTruncationError(error: unknown, bufferedText: string): boolean {\n  // Check for SyntaxError by instanceof or by name (for cross-realm errors)\n  const isSyntaxError =\n    error instanceof SyntaxError ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (typeof (error as any)?.name === 'string' &&\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (error as any).name.toLowerCase() === 'syntaxerror');\n\n  if (!isSyntaxError) {\n    return false;\n  }\n\n  if (!bufferedText) {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const rawMessage = typeof (error as any)?.message === 'string' ? (error as any).message : '';\n  const message = rawMessage.toLowerCase();\n\n  // Only match actual truncation patterns, not normal JSON parsing errors.\n  // Real truncation: \"Unexpected end of JSON input\" or \"Unterminated string in JSON...\"\n  // Normal errors: \"Unexpected token X in JSON at position N\" (should be surfaced as errors)\n  const truncationIndicators = [\n    'unexpected end of json input',\n    'unexpected end of input',\n    'unexpected end of string',\n    'unexpected eof',\n    'end of file',\n    'unterminated string',\n    'unterminated string constant',\n  ];\n\n  if (!truncationIndicators.some((indicator) => message.includes(indicator))) {\n    return false;\n  }\n\n  // Require meaningful content before treating as truncation.\n  // Short responses with \"end of input\" errors are likely genuine syntax errors.\n  // Note: bufferedText.length measures UTF-16 code units, not byte length.\n  if (bufferedText.length < MIN_TRUNCATION_LENGTH) {\n    return false;\n  }\n\n  // If we have a truncation indicator AND meaningful content, treat as truncation.\n  return true;\n}\n\nfunction isAbortError(err: unknown): boolean {\n  if (err && typeof err === 'object') {\n    const e = err as { name?: unknown; code?: unknown };\n    if (typeof e.name === 'string' && e.name === 'AbortError') return true;\n    if (typeof e.code === 'string' && e.code.toUpperCase() === 'ABORT_ERR') return true;\n  }\n  return false;\n}\n\nconst STREAMING_FEATURE_WARNING =\n  \"Claude Agent SDK features (hooks/MCP/images) require streaming input. Set `streamingInput: 'always'` or provide `canUseTool` (auto streams only when canUseTool is set).\";\n\nconst SDK_OPTIONS_BLOCKLIST = new Set(['model', 'abortController', 'prompt', 'outputFormat']);\n\ntype ClaudeToolUse = {\n  id: string;\n  name: string;\n  input: unknown;\n};\n\ntype ClaudeToolResult = {\n  id: string;\n  name?: string;\n  result: unknown;\n  isError: boolean;\n};\n\n// Provider extension for tool-error stream parts.\ntype ToolErrorPart = {\n  type: 'tool-error';\n  toolCallId: string;\n  toolName: string;\n  error: string;\n  providerExecuted: true;\n  providerMetadata?: Record<string, JSONValue>;\n};\n\n// Local extension of the AI SDK stream part union to include tool-error.\ntype ExtendedStreamPart = LanguageModelV2StreamPart | ToolErrorPart;\n\n/**\n * Tracks the streaming lifecycle state for a single tool invocation.\n *\n * The tool streaming lifecycle follows this sequence:\n * 1. Tool use detected → state created with all flags false\n * 2. First input seen → `inputStarted` = true, emit `tool-input-start`\n * 3. Input deltas streamed → emit `tool-input-delta` (may be skipped for large/non-prefix updates)\n * 4. Input finalized → `inputClosed` = true, emit `tool-input-end`\n * 5. Tool call formed → `callEmitted` = true, emit `tool-call`\n * 6. Tool results/errors arrive → emit `tool-result` or `tool-error` (may occur multiple times)\n * 7. Stream ends → state cleaned up by `finalizeToolCalls()`\n *\n * @property name - Tool name from SDK (e.g., \"Bash\", \"Read\")\n * @property lastSerializedInput - Most recent serialized input, used for delta calculation\n * @property inputStarted - True after `tool-input-start` emitted; prevents duplicate start events\n * @property inputClosed - True after `tool-input-end` emitted; ensures proper event ordering\n * @property callEmitted - True after `tool-call` emitted; prevents duplicate call events when\n *                         multiple result/error chunks arrive for the same tool invocation\n */\ntype ToolStreamState = {\n  name: string;\n  lastSerializedInput?: string;\n  inputStarted: boolean;\n  inputClosed: boolean;\n  callEmitted: boolean;\n};\n\nfunction toAsyncIterablePrompt(\n  messagesPrompt: string,\n  outputStreamEnded: Promise<unknown>,\n  sessionId?: string,\n  contentParts?: SDKUserMessage['message']['content']\n): AsyncIterable<SDKUserMessage> {\n  const content = (\n    contentParts && contentParts.length > 0\n      ? contentParts\n      : [{ type: 'text', text: messagesPrompt }]\n  ) as SDKUserMessage['message']['content'];\n\n  const msg: SDKUserMessage = {\n    type: 'user',\n    message: {\n      role: 'user',\n      content,\n    },\n    parent_tool_use_id: null,\n    session_id: sessionId ?? '',\n  };\n  return {\n    async *[Symbol.asyncIterator]() {\n      yield msg;\n      await outputStreamEnded;\n    },\n  };\n}\n\n/**\n * Options for creating a Claude Code language model instance.\n *\n * @example\n * ```typescript\n * const model = new ClaudeCodeLanguageModel({\n *   id: 'opus',\n *   settings: {\n *     maxTurns: 10,\n *     permissionMode: 'auto'\n *   }\n * });\n * ```\n */\nexport interface ClaudeCodeLanguageModelOptions {\n  /**\n   * The model identifier to use.\n   * Can be 'opus', 'sonnet', 'haiku', or a custom model string.\n   */\n  id: ClaudeCodeModelId;\n\n  /**\n   * Optional settings to configure the model behavior.\n   */\n  settings?: ClaudeCodeSettings;\n\n  /**\n   * Validation warnings from settings validation.\n   * Used internally to pass warnings from provider.\n   */\n  settingsValidationWarnings?: string[];\n}\n\n/**\n * Supported Claude model identifiers.\n * - 'opus': Claude Opus (most capable)\n * - 'sonnet': Claude Sonnet (balanced performance)\n * - 'haiku': Claude Haiku (fastest, most cost-effective)\n * - Custom string: Any full model identifier (e.g., 'claude-opus-4-5', 'claude-sonnet-4-5-20250514')\n *\n * @example\n * ```typescript\n * const opusModel = claudeCode('opus');\n * const sonnetModel = claudeCode('sonnet');\n * const haikuModel = claudeCode('haiku');\n * const customModel = claudeCode('claude-opus-4-5');\n * ```\n */\nexport type ClaudeCodeModelId = 'opus' | 'sonnet' | 'haiku' | (string & {});\n\nconst modelMap: Record<string, string> = {\n  opus: 'opus',\n  sonnet: 'sonnet',\n  haiku: 'haiku',\n};\n\n/**\n * Language model implementation for Claude Code SDK.\n * This class implements the AI SDK's LanguageModelV2 interface to provide\n * integration with Claude models through the Claude Agent SDK.\n *\n * Features:\n * - Supports streaming and non-streaming generation\n * - Native structured outputs via SDK's outputFormat (guaranteed schema compliance)\n * - Manages CLI sessions for conversation continuity\n * - Provides detailed error handling and retry logic\n *\n * Limitations:\n * - Image inputs require streaming mode\n * - Some parameters like temperature and max tokens are not supported by the CLI\n *\n * @example\n * ```typescript\n * const model = new ClaudeCodeLanguageModel({\n *   id: 'opus',\n *   settings: { maxTurns: 5 }\n * });\n *\n * const result = await model.doGenerate({\n *   prompt: [{ role: 'user', content: 'Hello!' }],\n *   mode: { type: 'regular' }\n * });\n * ```\n */\nexport class ClaudeCodeLanguageModel implements LanguageModelV2 {\n  readonly specificationVersion = 'v2' as const;\n  readonly defaultObjectGenerationMode = 'json' as const;\n  readonly supportsImageUrls = false;\n  readonly supportedUrls = {};\n  readonly supportsStructuredOutputs = true;\n\n  // Fallback/magic string constants\n  static readonly UNKNOWN_TOOL_NAME = 'unknown-tool';\n\n  // Tool input safety limits\n  private static readonly MAX_TOOL_INPUT_SIZE = 1_048_576; // 1MB hard limit\n  private static readonly MAX_TOOL_INPUT_WARN = 102_400; // 100KB warning threshold\n  private static readonly MAX_DELTA_CALC_SIZE = 10_000; // 10KB delta computation threshold\n\n  readonly modelId: ClaudeCodeModelId;\n  readonly settings: ClaudeCodeSettings;\n\n  private sessionId?: string;\n  private modelValidationWarning?: string;\n  private settingsValidationWarnings: string[];\n  private logger: Logger;\n\n  constructor(options: ClaudeCodeLanguageModelOptions) {\n    this.modelId = options.id;\n    this.settings = options.settings ?? {};\n    this.settingsValidationWarnings = options.settingsValidationWarnings ?? [];\n\n    // Create logger that respects verbose setting\n    const baseLogger = getLogger(this.settings.logger);\n    this.logger = createVerboseLogger(baseLogger, this.settings.verbose ?? false);\n\n    // Validate model ID format\n    if (!this.modelId || typeof this.modelId !== 'string' || this.modelId.trim() === '') {\n      throw new NoSuchModelError({\n        modelId: this.modelId,\n        modelType: 'languageModel',\n      });\n    }\n\n    // Additional model ID validation\n    this.modelValidationWarning = validateModelId(this.modelId);\n    if (this.modelValidationWarning) {\n      this.logger.warn(`Claude Code Model: ${this.modelValidationWarning}`);\n    }\n  }\n\n  get provider(): string {\n    return 'claude-code';\n  }\n\n  private getModel(): string {\n    const mapped = modelMap[this.modelId];\n    return mapped ?? this.modelId;\n  }\n\n  private getSanitizedSdkOptions(): Partial<Options> | undefined {\n    if (!this.settings.sdkOptions || typeof this.settings.sdkOptions !== 'object') {\n      return undefined;\n    }\n\n    const sanitized = { ...(this.settings.sdkOptions as Record<string, unknown>) };\n    const blockedKeys = Array.from(SDK_OPTIONS_BLOCKLIST).filter((key) => key in sanitized);\n\n    if (blockedKeys.length > 0) {\n      this.logger.warn(\n        `[claude-code] sdkOptions includes provider-managed fields (${blockedKeys.join(\n          ', '\n        )}); these will be ignored.`\n      );\n      blockedKeys.forEach((key) => delete sanitized[key]);\n    }\n\n    return sanitized as Partial<Options>;\n  }\n\n  private getEffectiveResume(sdkOptions?: Partial<Options>): string | undefined {\n    return sdkOptions?.resume ?? this.settings.resume ?? this.sessionId;\n  }\n\n  private extractToolUses(content: unknown): ClaudeToolUse[] {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (item): item is { type: string; id?: unknown; name?: unknown; input?: unknown } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_use'\n      )\n      .map((item) => {\n        const { id, name, input } = item as { id?: unknown; name?: unknown; input?: unknown };\n        return {\n          id: typeof id === 'string' && id.length > 0 ? id : generateId(),\n          name:\n            typeof name === 'string' && name.length > 0\n              ? name\n              : ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME,\n          input,\n        } satisfies ClaudeToolUse;\n      });\n  }\n\n  private extractToolResults(content: unknown): ClaudeToolResult[] {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (\n          item\n        ): item is {\n          type: string;\n          tool_use_id?: unknown;\n          content?: unknown;\n          is_error?: unknown;\n          name?: unknown;\n        } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_result'\n      )\n      .map((item) => {\n        const { tool_use_id, content, is_error, name } = item;\n        return {\n          id:\n            typeof tool_use_id === 'string' && tool_use_id.length > 0 ? tool_use_id : generateId(),\n          name: typeof name === 'string' && name.length > 0 ? name : undefined,\n          result: content,\n          isError: Boolean(is_error),\n        } satisfies ClaudeToolResult;\n      });\n  }\n\n  private extractToolErrors(content: unknown): Array<{\n    id: string;\n    name?: string;\n    error: unknown;\n  }> {\n    if (!Array.isArray(content)) {\n      return [];\n    }\n\n    return content\n      .filter(\n        (\n          item\n        ): item is {\n          type: string;\n          tool_use_id?: unknown;\n          error?: unknown;\n          name?: unknown;\n        } =>\n          typeof item === 'object' &&\n          item !== null &&\n          'type' in item &&\n          (item as { type: unknown }).type === 'tool_error'\n      )\n      .map((item) => {\n        const { tool_use_id, error, name } = item as {\n          tool_use_id?: unknown;\n          error?: unknown;\n          name?: unknown;\n        };\n        return {\n          id:\n            typeof tool_use_id === 'string' && tool_use_id.length > 0 ? tool_use_id : generateId(),\n          name: typeof name === 'string' && name.length > 0 ? name : undefined,\n          error,\n        };\n      });\n  }\n\n  private serializeToolInput(input: unknown): string {\n    if (typeof input === 'string') {\n      return this.checkInputSize(input);\n    }\n\n    if (input === undefined) {\n      return '';\n    }\n\n    try {\n      const serialized = JSON.stringify(input);\n      return this.checkInputSize(serialized);\n    } catch {\n      const fallback = String(input);\n      return this.checkInputSize(fallback);\n    }\n  }\n\n  private checkInputSize(str: string): string {\n    const length = str.length;\n\n    if (length > ClaudeCodeLanguageModel.MAX_TOOL_INPUT_SIZE) {\n      throw new Error(\n        `Tool input exceeds maximum size of ${ClaudeCodeLanguageModel.MAX_TOOL_INPUT_SIZE} bytes (got ${length} bytes). This may indicate a malformed request or an attempt to process excessively large data.`\n      );\n    }\n\n    if (length > ClaudeCodeLanguageModel.MAX_TOOL_INPUT_WARN) {\n      this.logger.warn(\n        `[claude-code] Large tool input detected: ${length} bytes. Performance may be impacted. Consider chunking or reducing input size.`\n      );\n    }\n\n    return str;\n  }\n\n  private normalizeToolResult(toolName: string, result: unknown): unknown {\n    if (toolName.startsWith('mcp__ai-sdk__') && Array.isArray(result) && result.length === 1 && 'text' in result[0]) {\n      return JSON.parse(result[0].text);\n    }\n\n    if (typeof result === 'string') {\n      try {\n        return JSON.parse(result);\n      } catch {\n        return result;\n      }\n    }\n\n    return result;\n  }\n\n  private generateAllWarnings(\n    options:\n      | Parameters<LanguageModelV2['doGenerate']>[0]\n      | Parameters<LanguageModelV2['doStream']>[0],\n    prompt: string\n  ): LanguageModelV2CallWarning[] {\n    const warnings: LanguageModelV2CallWarning[] = [];\n    const unsupportedParams: string[] = [];\n\n    // Check for unsupported parameters\n    if (options.temperature !== undefined) unsupportedParams.push('temperature');\n    if (options.topP !== undefined) unsupportedParams.push('topP');\n    if (options.topK !== undefined) unsupportedParams.push('topK');\n    if (options.presencePenalty !== undefined) unsupportedParams.push('presencePenalty');\n    if (options.frequencyPenalty !== undefined) unsupportedParams.push('frequencyPenalty');\n    if (options.stopSequences !== undefined && options.stopSequences.length > 0)\n      unsupportedParams.push('stopSequences');\n    if (options.seed !== undefined) unsupportedParams.push('seed');\n\n    if (unsupportedParams.length > 0) {\n      // Add a warning for each unsupported parameter\n      for (const param of unsupportedParams) {\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: param as\n            | 'temperature'\n            | 'maxTokens'\n            | 'topP'\n            | 'topK'\n            | 'presencePenalty'\n            | 'frequencyPenalty'\n            | 'stopSequences'\n            | 'seed',\n          details: `Claude Code SDK does not support the ${param} parameter. It will be ignored.`,\n        });\n      }\n    }\n\n    // Add model validation warning if present\n    if (this.modelValidationWarning) {\n      warnings.push({\n        type: 'other',\n        message: this.modelValidationWarning,\n      });\n    }\n\n    // Add settings validation warnings\n    this.settingsValidationWarnings.forEach((warning) => {\n      warnings.push({\n        type: 'other',\n        message: warning,\n      });\n    });\n\n    // Warn if JSON response format is requested without a schema\n    // Claude Code only supports structured outputs with schemas (like Anthropic's API)\n    if (options.responseFormat?.type === 'json' && !options.responseFormat.schema) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details:\n          'JSON response format requires a schema for the Claude Code provider. The JSON responseFormat is ignored and the call is treated as plain text.',\n      });\n    }\n\n    // Validate prompt\n    const promptWarning = validatePrompt(prompt);\n    if (promptWarning) {\n      warnings.push({\n        type: 'other',\n        message: promptWarning,\n      });\n    }\n\n    return warnings;\n  }\n\n  /**\n   * Converts AI SDK ToolSet to a single MCP server named 'ai-sdk'.\n   * This matches the pattern used in aider-desk where multiple tools\n   * are combined into one local MCP server.\n   *\n   * @param toolSet - ToolSet with execute functions from settings.aiSdkTools\n   * @returns MCP server configuration with all tools, or undefined if no tools\n   */\n  private convertToolSetToMcpServer(\n    toolSet?: ToolSet\n  ): Record<string, McpServerConfig> | undefined {\n    if (!toolSet || Object.keys(toolSet).length === 0) {\n      return undefined;\n    }\n\n    const sdkTools = Object.entries(toolSet).map(([name, aiTool]) => {\n      const inputSchema = aiTool.inputSchema;\n\n      // Extract Zod raw shape from input schema (handles both Zod 3 and Zod 4)\n      const inputShape =\n        'def' in inputSchema && inputSchema.def !== null && typeof inputSchema.def === 'object' && 'shape' in inputSchema.def\n          ? inputSchema.def.shape as ZodRawShape\n          : 'shape' in inputSchema\n            ? inputSchema.shape as ZodRawShape\n            : inputSchema;\n\n      // Create a tool handler that executes the AI SDK tool\n      const handler = async (\n        args: Record<string, unknown>,\n        extra: unknown\n      ): Promise<MinimalCallToolResult> => {\n        this.logger.debug(\n          `[claude-code] AI SDK tool executed: ${name} ${JSON.stringify({ args, extra })}`\n        );\n        if (!aiTool.execute) {\n          return {\n            content: [{ type: 'text', text: `Tool ${name} has no execute function` }],\n          };\n        }\n\n        try {\n          const result = await aiTool.execute(args, {\n            toolCallId: (extra as { _meta?: Record<string, unknown> })._meta?.['claudecode/toolUseId'] as string || '',\n            messages: [], // TODO: keep track of messages and pass them in\n          });\n          return {\n            content: [{ type: 'text', text: JSON.stringify(result) }],\n          };\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          return {\n            content: [{ type: 'text', text: `Error: ${errorMessage}` }],\n          };\n        }\n      };\n\n      return tool(\n        name,\n        aiTool.description || '',\n        inputShape as ZodRawShape,\n        handler\n      );\n    });\n\n    // Create a single MCP server with all tools\n    const mcpServer = createSdkMcpServer({\n      name: 'ai-sdk',\n      tools: sdkTools,\n    });\n\n    return { 'ai-sdk': mcpServer };\n  }\n\n  private createQueryOptions(\n    abortController: AbortController,\n    responseFormat?: Parameters<LanguageModelV2['doGenerate']>[0]['responseFormat'],\n    stderrCollector?: (data: string) => void,\n    sdkOptions?: Partial<Options>,\n    effectiveResume?: string\n  ): Options {\n    const combinedMcpServers = {\n      ...this.settings.mcpServers,\n      ...this.convertToolSetToMcpServer(this.settings.aiSdkTools),\n    };\n\n    const opts: Partial<Options> & Record<string, unknown> = {\n      model: this.getModel(),\n      abortController,\n      resume: effectiveResume ?? this.settings.resume ?? this.sessionId,\n      pathToClaudeCodeExecutable: this.settings.pathToClaudeCodeExecutable,\n      maxTurns: this.settings.maxTurns,\n      maxThinkingTokens: this.settings.maxThinkingTokens,\n      cwd: this.settings.cwd,\n      executable: this.settings.executable,\n      executableArgs: this.settings.executableArgs,\n      permissionMode: this.settings.permissionMode,\n      permissionPromptToolName: this.settings.permissionPromptToolName,\n      continue: this.settings.continue,\n      allowedTools: this.settings.allowedTools,\n      disallowedTools: this.settings.disallowedTools,\n      betas: this.settings.betas,\n      allowDangerouslySkipPermissions: this.settings.allowDangerouslySkipPermissions,\n      enableFileCheckpointing: this.settings.enableFileCheckpointing,\n      maxBudgetUsd: this.settings.maxBudgetUsd,\n      plugins: this.settings.plugins,\n      resumeSessionAt: this.settings.resumeSessionAt,\n      sandbox: this.settings.sandbox,\n      tools: this.settings.tools,\n      mcpServers: Object.keys(combinedMcpServers).length > 0 ? combinedMcpServers : undefined,\n      canUseTool: this.settings.canUseTool,\n    };\n    // NEW: Agent SDK options with legacy mapping\n    if (this.settings.systemPrompt !== undefined) {\n      opts.systemPrompt = this.settings.systemPrompt;\n    } else if (this.settings.customSystemPrompt !== undefined) {\n      // Deprecation warning for legacy field\n      this.logger.warn(\n        \"[claude-code] 'customSystemPrompt' is deprecated and will be removed in a future major release. Please use 'systemPrompt' instead (string or { type: 'preset', preset: 'claude_code', append? }).\"\n      );\n      opts.systemPrompt = this.settings.customSystemPrompt;\n    } else if (this.settings.appendSystemPrompt !== undefined) {\n      // Deprecation warning for legacy field\n      this.logger.warn(\n        \"[claude-code] 'appendSystemPrompt' is deprecated and will be removed in a future major release. Please use 'systemPrompt: { type: 'preset', preset: 'claude_code', append: <text> }' instead.\"\n      );\n      opts.systemPrompt = {\n        type: 'preset',\n        preset: 'claude_code',\n        append: this.settings.appendSystemPrompt,\n      } as const;\n    }\n    if (this.settings.settingSources !== undefined) {\n      opts.settingSources = this.settings.settingSources;\n    }\n    if (this.settings.additionalDirectories !== undefined) {\n      opts.additionalDirectories = this.settings.additionalDirectories;\n    }\n    if (this.settings.agents !== undefined) {\n      opts.agents = this.settings.agents;\n    }\n    if (this.settings.includePartialMessages !== undefined) {\n      opts.includePartialMessages = this.settings.includePartialMessages;\n    }\n    if (this.settings.fallbackModel !== undefined) {\n      opts.fallbackModel = this.settings.fallbackModel;\n    }\n    if (this.settings.forkSession !== undefined) {\n      opts.forkSession = this.settings.forkSession;\n    }\n    if (this.settings.strictMcpConfig !== undefined) {\n      opts.strictMcpConfig = this.settings.strictMcpConfig;\n    }\n    if (this.settings.extraArgs !== undefined) {\n      opts.extraArgs = this.settings.extraArgs;\n    }\n    // hooks is supported in newer SDKs; include it if provided\n    if (this.settings.hooks) {\n      opts.hooks = this.settings.hooks;\n    }\n\n    const sdkOverrides = sdkOptions\n      ? (sdkOptions as Partial<Options> & Record<string, unknown>)\n      : undefined;\n    const sdkEnv =\n      sdkOverrides && typeof sdkOverrides.env === 'object' && sdkOverrides.env !== null\n        ? (sdkOverrides.env as Record<string, string | undefined>)\n        : undefined;\n    const sdkStderr =\n      sdkOverrides && typeof sdkOverrides.stderr === 'function'\n        ? (sdkOverrides.stderr as (data: string) => void)\n        : undefined;\n    if (sdkOverrides) {\n      const rest = { ...sdkOverrides };\n      delete rest.env;\n      delete rest.stderr;\n      Object.assign(opts, rest);\n    }\n\n    // Wrap stderr callback to also collect data for error reporting\n    const userStderrCallback = sdkStderr ?? this.settings.stderr;\n    if (stderrCollector || userStderrCallback) {\n      opts.stderr = (data: string) => {\n        if (stderrCollector) stderrCollector(data);\n        if (userStderrCallback) userStderrCallback(data);\n      };\n    }\n\n    if (this.settings.env !== undefined || sdkEnv !== undefined) {\n      opts.env = { ...process.env, ...this.settings.env, ...sdkEnv };\n    }\n\n    // Native structured outputs (SDK 0.1.45+)\n    if (responseFormat?.type === 'json' && responseFormat.schema) {\n      opts.outputFormat = {\n        type: 'json_schema',\n        schema: responseFormat.schema as Record<string, unknown>,\n      };\n    }\n\n    return opts as Options;\n  }\n\n  private handleClaudeCodeError(\n    error: unknown,\n    messagesPrompt: string,\n    collectedStderr?: string\n  ): APICallError | LoadAPIKeyError {\n    // Handle AbortError from the SDK\n    if (isAbortError(error)) {\n      // Return the abort reason if available, otherwise the error itself\n      throw error;\n    }\n\n    // Type guard for error with properties\n    const isErrorWithMessage = (err: unknown): err is { message?: string } => {\n      return typeof err === 'object' && err !== null && 'message' in err;\n    };\n\n    const isErrorWithCode = (\n      err: unknown\n    ): err is { code?: string; exitCode?: number; stderr?: string } => {\n      return typeof err === 'object' && err !== null;\n    };\n\n    // Check for authentication errors with improved detection\n    const authErrorPatterns = [\n      'not logged in',\n      'authentication',\n      'unauthorized',\n      'auth failed',\n      'please login',\n      'claude login',\n    ];\n\n    const errorMessage =\n      isErrorWithMessage(error) && error.message ? error.message.toLowerCase() : '';\n\n    const exitCode =\n      isErrorWithCode(error) && typeof error.exitCode === 'number' ? error.exitCode : undefined;\n\n    const isAuthError =\n      authErrorPatterns.some((pattern) => errorMessage.includes(pattern)) || exitCode === 401;\n\n    if (isAuthError) {\n      return createAuthenticationError({\n        message:\n          isErrorWithMessage(error) && error.message\n            ? error.message\n            : 'Authentication failed. Please ensure Claude Code SDK is properly authenticated.',\n      });\n    }\n\n    // Check for timeout errors\n    const errorCode = isErrorWithCode(error) && typeof error.code === 'string' ? error.code : '';\n\n    if (errorCode === 'ETIMEDOUT' || errorMessage.includes('timeout')) {\n      return createTimeoutError({\n        message: isErrorWithMessage(error) && error.message ? error.message : 'Request timed out',\n        promptExcerpt: messagesPrompt.substring(0, 200),\n        // Don't specify timeoutMs since we don't know the actual timeout value\n        // It's controlled by the consumer via AbortSignal\n      });\n    }\n\n    // Create general API call error with appropriate retry flag\n    const isRetryable =\n      errorCode === 'ENOENT' ||\n      errorCode === 'ECONNREFUSED' ||\n      errorCode === 'ETIMEDOUT' ||\n      errorCode === 'ECONNRESET';\n\n    // Use error.stderr if available from SDK, otherwise use collected stderr\n    const stderrFromError =\n      isErrorWithCode(error) && typeof error.stderr === 'string' ? error.stderr : undefined;\n    const stderr = stderrFromError || collectedStderr || undefined;\n\n    return createAPICallError({\n      message: isErrorWithMessage(error) && error.message ? error.message : 'Claude Code SDK error',\n      code: errorCode || undefined,\n      exitCode: exitCode,\n      stderr,\n      promptExcerpt: messagesPrompt.substring(0, 200),\n      isRetryable,\n    });\n  }\n\n  private setSessionId(sessionId: string): void {\n    this.sessionId = sessionId;\n    const warning = validateSessionId(sessionId);\n    if (warning) {\n      this.logger.warn(`Claude Code Session: ${warning}`);\n    }\n  }\n\n  /**\n   * Strips the 'mcp__ai-sdk__' prefix from AI SDK tool names.\n   * This allows AI SDK to match tool names correctly.\n   *\n   * @param name - The tool name (may include the 'mcp__ai-sdk__' prefix)\n   * @returns The tool name with the prefix removed, or the original name if no prefix\n   */\n  private normalizeToolName(name: string): string {\n    return name.startsWith('mcp__ai-sdk__')\n      ? name.slice('mcp__ai-sdk__'.length)\n      : name;\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV2['doGenerate']>[0]\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>> {\n    this.logger.debug(`[claude-code] Starting doGenerate request with model: ${this.modelId}`);\n    this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? 'none'}`);\n\n    const sdkOptions = this.getSanitizedSdkOptions();\n    const effectiveResume = this.getEffectiveResume(sdkOptions);\n    const {\n      messagesPrompt,\n      warnings: messageWarnings,\n      streamingContentParts,\n      hasImageParts,\n    } = convertToClaudeCodeMessages(options.prompt, effectiveResume);\n\n    this.logger.debug(\n      `[claude-code] Converted ${options.prompt.length} messages, hasImageParts: ${hasImageParts}`\n    );\n\n    const abortController = new AbortController();\n    let abortListener: (() => void) | undefined;\n    if (options.abortSignal?.aborted) {\n      // Propagate already-aborted state immediately with original reason\n      abortController.abort(options.abortSignal.reason);\n    } else if (options.abortSignal) {\n      abortListener = () => abortController.abort(options.abortSignal?.reason);\n      options.abortSignal.addEventListener('abort', abortListener, { once: true });\n    }\n\n    // Collect stderr for error reporting (SDK may not include it in errors)\n    let collectedStderr = '';\n    const stderrCollector = (data: string) => {\n      collectedStderr += data;\n    };\n\n    const queryOptions = this.createQueryOptions(\n      abortController,\n      options.responseFormat,\n      stderrCollector,\n      sdkOptions,\n      effectiveResume\n    );\n\n    let text = '';\n    let structuredOutput: unknown | undefined;\n    let usage: LanguageModelV2Usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n    let finishReason: LanguageModelV2FinishReason = 'stop';\n    let wasTruncated = false;\n    let costUsd: number | undefined;\n    let durationMs: number | undefined;\n    let rawUsage: unknown | undefined;\n    const warnings: LanguageModelV2CallWarning[] = this.generateAllWarnings(\n      options,\n      messagesPrompt\n    );\n\n    // Add warnings from message conversion\n    if (messageWarnings) {\n      messageWarnings.forEach((warning) => {\n        warnings.push({\n          type: 'other',\n          message: warning,\n        });\n      });\n    }\n\n    const modeSetting = this.settings.streamingInput ?? 'auto';\n    const effectiveCanUseTool = sdkOptions?.canUseTool ?? this.settings.canUseTool;\n    const effectivePermissionPromptToolName =\n      sdkOptions?.permissionPromptToolName ?? this.settings.permissionPromptToolName;\n    const wantsStreamInput =\n      modeSetting === 'always' || (modeSetting === 'auto' && !!effectiveCanUseTool);\n\n    if (!wantsStreamInput && hasImageParts) {\n      warnings.push({\n        type: 'other',\n        message: STREAMING_FEATURE_WARNING,\n      });\n    }\n\n    let done = () => {};\n    const outputStreamEnded = new Promise((resolve) => {\n      done = () => resolve(undefined);\n    });\n    try {\n      if (effectiveCanUseTool && effectivePermissionPromptToolName) {\n        throw new Error(\n          \"canUseTool requires streamingInput mode ('auto' or 'always') and cannot be used with permissionPromptToolName (SDK constraint). Set streamingInput: 'auto' (or 'always') and remove permissionPromptToolName, or remove canUseTool.\"\n        );\n      }\n      // hold input stream open until results\n      // see: https://github.com/anthropics/claude-code/issues/4775\n      const sdkPrompt = wantsStreamInput\n        ? toAsyncIterablePrompt(\n            messagesPrompt,\n            outputStreamEnded,\n            effectiveResume,\n            streamingContentParts\n          )\n        : messagesPrompt;\n\n      this.logger.debug(\n        `[claude-code] Executing query with streamingInput: ${wantsStreamInput}, session: ${effectiveResume ?? 'new'}`\n      );\n\n      const response = query({\n        prompt: sdkPrompt,\n        options: queryOptions,\n      });\n\n      for await (const message of response) {\n        this.logger.debug(`[claude-code] Received message type: ${message.type}`);\n        if (message.type === 'assistant') {\n          text += message.message.content\n            .map((c: { type: string; text?: string }) => (c.type === 'text' ? c.text : ''))\n            .join('');\n        } else if (message.type === 'result') {\n          done();\n          this.setSessionId(message.session_id);\n          costUsd = message.total_cost_usd;\n          durationMs = message.duration_ms;\n\n          // Handle structured output errors (SDK 0.1.45+)\n          // Use string comparison to support new SDK subtypes not yet in TypeScript definitions\n          if ((message.subtype as string) === 'error_max_structured_output_retries') {\n            throw new Error(\n              'Failed to generate valid structured output after maximum retries. The model could not produce a response matching the required schema.'\n            );\n          }\n\n          // Capture structured output if available (SDK 0.1.45+)\n          if ('structured_output' in message && message.structured_output !== undefined) {\n            structuredOutput = message.structured_output;\n            this.logger.debug('[claude-code] Received structured output from SDK');\n          }\n\n          this.logger.info(\n            `[claude-code] Request completed - Session: ${message.session_id}, Cost: $${costUsd?.toFixed(4) ?? 'N/A'}, Duration: ${durationMs ?? 'N/A'}ms`\n          );\n\n          if ('usage' in message) {\n            rawUsage = message.usage;\n            usage = {\n              inputTokens:\n                (message.usage.cache_creation_input_tokens ?? 0) +\n                (message.usage.cache_read_input_tokens ?? 0) +\n                (message.usage.input_tokens ?? 0),\n              outputTokens: message.usage.output_tokens ?? 0,\n              totalTokens:\n                (message.usage.cache_creation_input_tokens ?? 0) +\n                (message.usage.cache_read_input_tokens ?? 0) +\n                (message.usage.input_tokens ?? 0) +\n                (message.usage.output_tokens ?? 0),\n            };\n\n            this.logger.debug(\n              `[claude-code] Token usage - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`\n            );\n          }\n\n          finishReason = mapClaudeCodeFinishReason(message.subtype);\n          this.logger.debug(`[claude-code] Finish reason: ${finishReason}`);\n        } else if (message.type === 'system' && message.subtype === 'init') {\n          this.setSessionId(message.session_id);\n          this.logger.info(`[claude-code] Session initialized: ${message.session_id}`);\n        }\n      }\n    } catch (error: unknown) {\n      done();\n      this.logger.debug(\n        `[claude-code] Error during doGenerate: ${error instanceof Error ? error.message : String(error)}`\n      );\n\n      // Special handling for AbortError to preserve abort signal reason\n      if (isAbortError(error)) {\n        this.logger.debug('[claude-code] Request aborted by user');\n        throw options.abortSignal?.aborted ? options.abortSignal.reason : error;\n      }\n\n      if (isClaudeCodeTruncationError(error, text)) {\n        this.logger.warn(\n          `[claude-code] Detected truncated response, returning ${text.length} characters of buffered text`\n        );\n        wasTruncated = true;\n        finishReason = 'length';\n        warnings.push({\n          type: 'other',\n          message: CLAUDE_CODE_TRUNCATION_WARNING,\n        });\n      } else {\n        // Use unified error handler\n        throw this.handleClaudeCodeError(error, messagesPrompt, collectedStderr);\n      }\n    } finally {\n      if (options.abortSignal && abortListener) {\n        options.abortSignal.removeEventListener('abort', abortListener);\n      }\n    }\n\n    // Use structured output from SDK if available (native JSON schema support)\n    // Otherwise fall back to accumulated text\n    const finalText = structuredOutput !== undefined ? JSON.stringify(structuredOutput) : text;\n\n    return {\n      content: [{ type: 'text', text: finalText }],\n      usage,\n      finishReason,\n      warnings,\n      response: {\n        id: generateId(),\n        timestamp: new Date(),\n        modelId: this.modelId,\n      },\n      request: {\n        body: messagesPrompt,\n      },\n      providerMetadata: {\n        'claude-code': {\n          ...(this.sessionId !== undefined && { sessionId: this.sessionId }),\n          ...(costUsd !== undefined && { costUsd }),\n          ...(durationMs !== undefined && { durationMs }),\n          ...(rawUsage !== undefined && { rawUsage: rawUsage as JSONValue }),\n          ...(wasTruncated && { truncated: true }),\n        },\n      },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV2['doStream']>[0]\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>> {\n    this.logger.debug(`[claude-code] Starting doStream request with model: ${this.modelId}`);\n    this.logger.debug(`[claude-code] Response format: ${options.responseFormat?.type ?? 'none'}`);\n\n    const sdkOptions = this.getSanitizedSdkOptions();\n    const effectiveResume = this.getEffectiveResume(sdkOptions);\n    this.logger.debug(`[claude-code] Prompt: ${JSON.stringify(options.prompt)}`);\n    const {\n      messagesPrompt,\n      warnings: messageWarnings,\n      streamingContentParts,\n      hasImageParts,\n    } = convertToClaudeCodeMessages(options.prompt, effectiveResume);\n\n    this.logger.debug(\n      `[claude-code] Converted ${options.prompt.length} messages for streaming, hasImageParts: ${hasImageParts}`\n    );\n\n    const abortController = new AbortController();\n    let abortListener: (() => void) | undefined;\n    if (options.abortSignal?.aborted) {\n      // Propagate already-aborted state immediately with original reason\n      abortController.abort(options.abortSignal.reason);\n    } else if (options.abortSignal) {\n      abortListener = () => abortController.abort(options.abortSignal?.reason);\n      options.abortSignal.addEventListener('abort', abortListener, { once: true });\n    }\n\n    // Collect stderr for error reporting (SDK may not include it in errors)\n    let collectedStderr = '';\n    const stderrCollector = (data: string) => {\n      collectedStderr += data;\n    };\n\n    const queryOptions = this.createQueryOptions(\n      abortController,\n      options.responseFormat,\n      stderrCollector,\n      sdkOptions,\n      effectiveResume\n    );\n\n    // Enable partial messages for true streaming (token-by-token delivery)\n    // This can be overridden by user settings, but we default to true for doStream\n    if (queryOptions.includePartialMessages === undefined) {\n      queryOptions.includePartialMessages = true;\n    }\n\n    const warnings: LanguageModelV2CallWarning[] = this.generateAllWarnings(\n      options,\n      messagesPrompt\n    );\n\n    // Add warnings from message conversion\n    if (messageWarnings) {\n      messageWarnings.forEach((warning) => {\n        warnings.push({\n          type: 'other',\n          message: warning,\n        });\n      });\n    }\n\n    const modeSetting = this.settings.streamingInput ?? 'auto';\n    const effectiveCanUseTool = sdkOptions?.canUseTool ?? this.settings.canUseTool;\n    const effectivePermissionPromptToolName =\n      sdkOptions?.permissionPromptToolName ?? this.settings.permissionPromptToolName;\n    const wantsStreamInput =\n      modeSetting === 'always' || (modeSetting === 'auto' && !!effectiveCanUseTool);\n\n    if (!wantsStreamInput && hasImageParts) {\n      warnings.push({\n        type: 'other',\n        message: STREAMING_FEATURE_WARNING,\n      });\n    }\n\n    const stream = new ReadableStream<ExtendedStreamPart>({\n      start: async (controller) => {\n        let done = () => {};\n        const outputStreamEnded = new Promise((resolve) => {\n          done = () => resolve(undefined);\n        });\n        const toolStates = new Map<string, ToolStreamState>();\n        const streamWarnings: LanguageModelV2CallWarning[] = [];\n\n        const closeToolInput = (toolId: string, state: ToolStreamState) => {\n          if (!state.inputClosed && state.inputStarted) {\n            controller.enqueue({\n              type: 'tool-input-end',\n              id: toolId,\n            });\n            state.inputClosed = true;\n          }\n        };\n\n        const emitToolCall = (toolId: string, state: ToolStreamState) => {\n          if (state.callEmitted) {\n            return;\n          }\n\n          closeToolInput(toolId, state);\n\n          const toolName = this.normalizeToolName(state.name);\n\n          controller.enqueue({\n            type: 'tool-call',\n            toolCallId: toolId,\n            toolName,\n            input: state.lastSerializedInput ?? '',\n            providerExecuted: true,\n            dynamic: true, // V3 field: indicates tool is provider-defined (not in user's tools map)\n            providerMetadata: {\n              'claude-code': {\n                // rawInput preserves the original serialized format before AI SDK normalization.\n                // Use this if you need the exact string sent to the Claude CLI, which may differ\n                // from the `input` field after AI SDK processing.\n                rawInput: state.lastSerializedInput ?? '',\n              },\n            },\n          } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n          state.callEmitted = true;\n        };\n\n        const finalizeToolCalls = () => {\n          for (const [toolId, state] of toolStates) {\n            emitToolCall(toolId, state);\n          }\n          toolStates.clear();\n        };\n\n        let usage: LanguageModelV2Usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n        let lastMessageRawUsage: unknown | undefined = undefined;\n        let accumulatedText = '';\n        let textPartId: string | undefined;\n        let streamedTextLength = 0; // Track text already emitted via stream_events to avoid duplication\n        let hasReceivedStreamEvents = false; // Track if we've received any stream_events\n\n        try {\n          // Emit stream-start with warnings\n          controller.enqueue({ type: 'stream-start', warnings });\n\n          if (effectiveCanUseTool && effectivePermissionPromptToolName) {\n            throw new Error(\n              \"canUseTool requires streamingInput mode ('auto' or 'always') and cannot be used with permissionPromptToolName (SDK constraint). Set streamingInput: 'auto' (or 'always') and remove permissionPromptToolName, or remove canUseTool.\"\n            );\n          }\n          // hold input stream open until results\n          // see: https://github.com/anthropics/claude-code/issues/4775\n          const sdkPrompt = wantsStreamInput\n            ? toAsyncIterablePrompt(\n                messagesPrompt,\n                outputStreamEnded,\n                effectiveResume,\n                streamingContentParts\n              )\n            : messagesPrompt;\n\n          this.logger.debug(\n            `[claude-code] Starting stream query with streamingInput: ${wantsStreamInput}, session: ${effectiveResume ?? 'new'}`\n          );\n\n          const response = query({\n            prompt: sdkPrompt,\n            options: queryOptions,\n          });\n\n          for await (const message of response) {\n            this.logger.debug(`[claude-code] Stream received message type: ${message.type}`);\n\n            // Handle streaming events (token-by-token delivery via includePartialMessages)\n            if (message.type === 'stream_event') {\n              const streamEvent = message as SDKPartialAssistantMessage;\n              const event = streamEvent.event;\n              this.logger.debug(`[claude-code] Stream event: ${event.type}`);\n\n              // Check for text_delta events within content_block_delta\n              if (\n                event.type === 'content_block_delta' &&\n                event.delta.type === 'text_delta' &&\n                'text' in event.delta &&\n                event.delta.text\n              ) {\n                const deltaText = event.delta.text;\n                hasReceivedStreamEvents = true;\n\n                // Don't emit text deltas in JSON mode - accumulate instead\n                if (options.responseFormat?.type === 'json') {\n                  accumulatedText += deltaText;\n                  streamedTextLength += deltaText.length;\n                  continue;\n                }\n\n                // Emit text-start if this is the first text\n                if (!textPartId) {\n                  textPartId = generateId();\n                  controller.enqueue({\n                    type: 'text-start',\n                    id: textPartId,\n                  });\n                }\n\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: textPartId,\n                  delta: deltaText,\n                });\n                accumulatedText += deltaText;\n                streamedTextLength += deltaText.length;\n              }\n              // Handle input_json_delta events for structured output streaming\n              // The SDK uses a StructuredOutput tool internally, and JSON is streamed via input_json_delta\n              if (\n                event.type === 'content_block_delta' &&\n                event.delta.type === 'input_json_delta' &&\n                'partial_json' in event.delta &&\n                event.delta.partial_json\n              ) {\n                const jsonDelta = event.delta.partial_json;\n                hasReceivedStreamEvents = true;\n\n                // Only emit in JSON mode - this enables streamObject() to receive partial updates\n                if (options.responseFormat?.type === 'json') {\n                  // Emit text-start if this is the first JSON delta\n                  if (!textPartId) {\n                    textPartId = generateId();\n                    controller.enqueue({\n                      type: 'text-start',\n                      id: textPartId,\n                    });\n                  }\n\n                  controller.enqueue({\n                    type: 'text-delta',\n                    id: textPartId,\n                    delta: jsonDelta,\n                  });\n                  accumulatedText += jsonDelta;\n                  streamedTextLength += jsonDelta.length;\n                }\n                // In non-JSON mode, input_json_delta is ignored (it's internal tool use)\n              }\n\n              // Other stream_event types (content_block_start, content_block_stop, etc.)\n              // are informational and don't need to be forwarded to the AI SDK stream\n              continue;\n            }\n\n            if (message.type === 'assistant') {\n              if (!message.message?.content) {\n                this.logger.warn(\n                  `[claude-code] Unexpected assistant message structure: missing content field. Message type: ${message.type}. This may indicate an SDK protocol violation.`\n                );\n                continue;\n              }\n\n              if ('usage' in message.message) {\n                this.logger.debug(\n                  `[claude-code] Assistant message usage: ${JSON.stringify(message.message.usage)}`\n                );\n                lastMessageRawUsage = message.message.usage;\n              }\n\n              const content = message.message.content;\n\n              for (const tool of this.extractToolUses(content)) {\n                const toolId = tool.id;\n                let state = toolStates.get(toolId);\n                if (!state) {\n                  state = {\n                    name: tool.name,\n                    inputStarted: false,\n                    inputClosed: false,\n                    callEmitted: false,\n                  };\n                  toolStates.set(toolId, state);\n                  this.logger.debug(\n                    `[claude-code] New tool use detected - Tool: ${tool.name}, ID: ${toolId}`\n                  );\n                }\n\n                state.name = tool.name;\n\n                if (!state.inputStarted) {\n                  this.logger.debug(\n                    `[claude-code] Tool input started - Tool: ${tool.name}, ID: ${toolId}`\n                  );\n                  controller.enqueue({\n                    type: 'tool-input-start',\n                    id: toolId,\n                    toolName: this.normalizeToolName(tool.name),\n                    providerExecuted: true,\n                    dynamic: true, // V3 field: indicates tool is provider-defined\n                  } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n                  state.inputStarted = true;\n                }\n\n                const serializedInput = this.serializeToolInput(tool.input);\n                if (serializedInput) {\n                  let deltaPayload = '';\n\n                  // First input: emit full delta only if small enough\n                  if (state.lastSerializedInput === undefined) {\n                    if (serializedInput.length <= ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE) {\n                      deltaPayload = serializedInput;\n                    }\n                  } else if (\n                    serializedInput.length <= ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE &&\n                    state.lastSerializedInput.length <=\n                      ClaudeCodeLanguageModel.MAX_DELTA_CALC_SIZE &&\n                    serializedInput.startsWith(state.lastSerializedInput)\n                  ) {\n                    deltaPayload = serializedInput.slice(state.lastSerializedInput.length);\n                  } else if (serializedInput !== state.lastSerializedInput) {\n                    // Non-prefix updates or large inputs - defer to the final tool-call payload\n                    deltaPayload = '';\n                  }\n\n                  if (deltaPayload) {\n                    controller.enqueue({\n                      type: 'tool-input-delta',\n                      id: toolId,\n                      delta: deltaPayload,\n                    });\n                  }\n                  state.lastSerializedInput = serializedInput;\n                }\n              }\n\n              const text = content\n                .map((c: { type: string; text?: string }) => (c.type === 'text' ? c.text : ''))\n                .join('');\n\n              if (text) {\n                // When we've received stream_events, assistant messages contain cumulative text\n                // that we've already emitted via stream_event deltas - skip duplicates\n                // When no stream_events received, assistant messages contain incremental text\n                if (hasReceivedStreamEvents) {\n                  // Calculate delta: only emit text that wasn't already streamed via stream_events\n                  const newTextStart = streamedTextLength;\n                  const deltaText = text.length > newTextStart ? text.slice(newTextStart) : '';\n\n                  // Always accumulate for final result tracking\n                  accumulatedText = text; // Replace with full text (assistant msg contains full content)\n\n                  // In JSON mode, we accumulate the text and extract JSON at the end\n                  // Otherwise, stream any new text\n                  if (options.responseFormat?.type !== 'json' && deltaText) {\n                    // Emit text-start if this is the first text\n                    if (!textPartId) {\n                      textPartId = generateId();\n                      controller.enqueue({\n                        type: 'text-start',\n                        id: textPartId,\n                      });\n                    }\n\n                    controller.enqueue({\n                      type: 'text-delta',\n                      id: textPartId,\n                      delta: deltaText,\n                    });\n                  }\n\n                  // Update streamedTextLength to match what we now know is the full text\n                  streamedTextLength = text.length;\n                } else {\n                  // No stream_events - assistant messages contain incremental text chunks\n                  accumulatedText += text;\n\n                  // In JSON mode, we accumulate the text and extract JSON at the end\n                  // Otherwise, stream the text as it comes\n                  if (options.responseFormat?.type !== 'json') {\n                    // Emit text-start if this is the first text\n                    if (!textPartId) {\n                      textPartId = generateId();\n                      controller.enqueue({\n                        type: 'text-start',\n                        id: textPartId,\n                      });\n                    }\n\n                    controller.enqueue({\n                      type: 'text-delta',\n                      id: textPartId,\n                      delta: text,\n                    });\n                  }\n                }\n              }\n\n              if (textPartId) {\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n                textPartId = undefined;\n                accumulatedText = '';\n                streamedTextLength = 0;\n              }\n            } else if (message.type === 'user') {\n              if (!message.message?.content) {\n                this.logger.warn(\n                  `[claude-code] Unexpected user message structure: missing content field. Message type: ${message.type}. This may indicate an SDK protocol violation.`\n                );\n                continue;\n              }\n\n              // A user message with tool results signals the end of the current assistant message.\n              // Reset text state to ensure the next assistant message starts with a new text part.\n              // This prevents text from different assistant messages from being merged together.\n              if (textPartId) {\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n\n                });\n                textPartId = undefined;\n                accumulatedText = '';\n                streamedTextLength = 0;\n                this.logger.debug('[claude-code] Closed text part due to user message with tool results');\n              }\n\n              this.logger.debug(`[claude-code] Received user message: ${JSON.stringify(message.message)}`);\n\n              if ('usage' in message.message) {\n                this.logger.debug(`[claude-code] User message usage: ${JSON.stringify(message.message.usage)}`);\n                lastMessageRawUsage = message.message.usage;\n              }\n\n              const content = message.message.content;\n              for (const result of this.extractToolResults(content)) {\n                let state = toolStates.get(result.id);\n                const rawToolName =\n                  result.name ?? state?.name ?? ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;\n                const toolName = this.normalizeToolName(rawToolName);\n\n                this.logger.debug(\n                  `[claude-code] Tool result received - Tool: ${toolName}, ID: ${result.id}`\n                );\n\n                if (!state) {\n                  this.logger.warn(\n                    `[claude-code] Received tool result for unknown tool ID: ${result.id}`\n                  );\n                  state = {\n                    name: toolName,\n                    inputStarted: false,\n                    inputClosed: false,\n                    callEmitted: false,\n                  };\n                  toolStates.set(result.id, state);\n                  // Synthesize input lifecycle to preserve ordering when no prior tool_use was seen\n                  if (!state.inputStarted) {\n                    controller.enqueue({\n                      type: 'tool-input-start',\n                      id: result.id,\n                      toolName,\n                      providerExecuted: true,\n                      dynamic: true, // V3 field: indicates tool is provider-defined\n                    } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n                    state.inputStarted = true;\n                  }\n                  if (!state.inputClosed) {\n                    controller.enqueue({\n                      type: 'tool-input-end',\n                      id: result.id,\n                    });\n                    state.inputClosed = true;\n                  }\n                }\n                state.name = toolName;\n                const normalizedResult = this.normalizeToolResult(rawToolName, result.result);\n                const rawResult =\n                  typeof result.result === 'string'\n                    ? result.result\n                    : (() => {\n                        try {\n                          return JSON.stringify(result.result);\n                        } catch {\n                          return String(result.result);\n                        }\n                      })();\n\n                emitToolCall(result.id, state);\n\n                controller.enqueue({\n                  type: 'tool-result',\n                  toolCallId: result.id,\n                  toolName,\n                  result: normalizedResult,\n                  isError: result.isError,\n                  providerExecuted: true,\n                  dynamic: true, // V3 field: indicates tool is provider-defined\n                  providerMetadata: {\n                    'claude-code': {\n                      // rawResult preserves the original CLI output string before JSON parsing.\n                      // Use this when you need the exact string returned by the tool, especially\n                      // if the `result` field has been parsed/normalized and you need the original format.\n                      rawResult,\n                    },\n                  },\n                } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n              }\n              // Handle tool errors\n              for (const error of this.extractToolErrors(content)) {\n                let state = toolStates.get(error.id);\n                const rawToolName =\n                  error.name ?? state?.name ?? ClaudeCodeLanguageModel.UNKNOWN_TOOL_NAME;\n                const toolName = this.normalizeToolName(rawToolName);\n\n                this.logger.debug(\n                  `[claude-code] Tool error received - Tool: ${toolName}, ID: ${error.id}`\n                );\n\n                if (!state) {\n                  this.logger.warn(\n                    `[claude-code] Received tool error for unknown tool ID: ${error.id}`\n                  );\n                  state = {\n                    name: toolName,\n                    inputStarted: true,\n                    inputClosed: true,\n                    callEmitted: false,\n                  };\n                  toolStates.set(error.id, state);\n                }\n\n                // Ensure tool-call is emitted before tool-error\n                emitToolCall(error.id, state);\n\n                const rawError =\n                  typeof error.error === 'string'\n                    ? error.error\n                    : typeof error.error === 'object' && error.error !== null\n                      ? (() => {\n                          try {\n                            return JSON.stringify(error.error);\n                          } catch {\n                            return String(error.error);\n                          }\n                        })()\n                      : String(error.error);\n\n                controller.enqueue({\n                  type: 'tool-error',\n                  toolCallId: error.id,\n                  toolName,\n                  error: rawError,\n                  providerExecuted: true,\n                  dynamic: true, // V3 field: indicates tool is provider-defined\n                  providerMetadata: {\n                    'claude-code': {\n                      rawError,\n                    },\n                  },\n                } as any); // eslint-disable-line @typescript-eslint/no-explicit-any\n              }\n            } else if (message.type === 'result') {\n              done();\n\n              // Handle structured output errors (SDK 0.1.45+)\n              // Use string comparison to support new SDK subtypes not yet in TypeScript definitions\n              if ((message.subtype as string) === 'error_max_structured_output_retries') {\n                throw new Error(\n                  'Failed to generate valid structured output after maximum retries. The model could not produce a response matching the required schema.'\n                );\n              }\n\n              this.logger.info(\n                `[claude-code] Stream completed - Session: ${message.session_id}, Cost: $${message.total_cost_usd?.toFixed(4) ?? 'N/A'}, Duration: ${message.duration_ms ?? 'N/A'}ms`\n              );\n\n              this.logger.debug(`[claude-code] ModelUsage: ${JSON.stringify(message.modelUsage)}`);\n\n              let rawUsage: unknown | undefined;\n              if ('usage' in message) {\n                rawUsage = message.usage;\n                usage = {\n                  inputTokens:\n                    (message.usage.cache_creation_input_tokens ?? 0) +\n                    (message.usage.cache_read_input_tokens ?? 0) +\n                    (message.usage.input_tokens ?? 0),\n                  outputTokens: message.usage.output_tokens ?? 0,\n                  totalTokens:\n                    (message.usage.cache_creation_input_tokens ?? 0) +\n                    (message.usage.cache_read_input_tokens ?? 0) +\n                    (message.usage.input_tokens ?? 0) +\n                    (message.usage.output_tokens ?? 0),\n                };\n\n                this.logger.debug(\n                  `[claude-code] Stream token usage - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`\n                );\n              }\n\n              const finishReason: LanguageModelV2FinishReason = mapClaudeCodeFinishReason(\n                message.subtype\n              );\n\n              this.logger.debug(`[claude-code] Stream finish reason: ${finishReason}`);\n\n              // Store session ID in the model instance\n              this.setSessionId(message.session_id);\n\n              // Use structured output from SDK if available (native JSON schema support)\n              const structuredOutput =\n                'structured_output' in message ? message.structured_output : undefined;\n\n              // Check if we've already streamed JSON via input_json_delta\n              const alreadyStreamedJson =\n                textPartId && options.responseFormat?.type === 'json' && hasReceivedStreamEvents;\n\n              if (alreadyStreamedJson && textPartId) {\n                // We've already streamed JSON deltas, just close the text part\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n              } else if (structuredOutput !== undefined) {\n                // Emit structured output as text (fallback when streaming didn't occur)\n                const jsonTextId = generateId();\n                const jsonText = JSON.stringify(structuredOutput);\n                controller.enqueue({\n                  type: 'text-start',\n                  id: jsonTextId,\n                });\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: jsonTextId,\n                  delta: jsonText,\n                });\n                controller.enqueue({\n                  type: 'text-end',\n                  id: jsonTextId,\n                });\n              } else if (textPartId) {\n                // Close the text part if it was opened (non-JSON mode)\n                controller.enqueue({\n                  type: 'text-end',\n                  id: textPartId,\n                });\n              } else if (accumulatedText) {\n                // Fallback for JSON mode without schema: emit accumulated text\n                // This handles the case where responseFormat.type === 'json' but no schema\n                // was provided, so the SDK returns plain text instead of structured_output\n                const fallbackTextId = generateId();\n                controller.enqueue({\n                  type: 'text-start',\n                  id: fallbackTextId,\n                });\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: fallbackTextId,\n                  delta: accumulatedText,\n                });\n                controller.enqueue({\n                  type: 'text-end',\n                  id: fallbackTextId,\n                });\n              }\n\n              finalizeToolCalls();\n\n              // Prepare JSON-safe warnings for provider metadata\n              const warningsJson = this.serializeWarningsForMetadata(streamWarnings);\n\n              controller.enqueue({\n                type: 'finish',\n                finishReason,\n                usage,\n                providerMetadata: {\n                  'claude-code': {\n                    sessionId: message.session_id,\n                    ...(message.total_cost_usd !== undefined && {\n                      costUsd: message.total_cost_usd,\n                    }),\n                    ...(message.duration_ms !== undefined && { durationMs: message.duration_ms }),\n                    ...(rawUsage !== undefined && { rawUsage: rawUsage as JSONValue }),\n                    ...(lastMessageRawUsage !== undefined && { lastMessageRawUsage: lastMessageRawUsage as JSONValue }),\n                    // JSON validation warnings are collected during streaming and included\n                    // in providerMetadata since the AI SDK's finish event doesn't support\n                    // a top-level warnings field (unlike stream-start which was already emitted)\n                    ...(streamWarnings.length > 0 && {\n                      warnings: warningsJson as unknown as JSONValue,\n                    }),\n                  },\n                },\n              });\n            } else if (message.type === 'system' && message.subtype === 'init') {\n              // Store session ID for future use\n              this.setSessionId(message.session_id);\n\n              this.logger.info(`[claude-code] Stream session initialized: ${message.session_id}`);\n\n              // Emit response metadata when session is initialized\n              controller.enqueue({\n                type: 'response-metadata',\n                id: message.session_id,\n                timestamp: new Date(),\n                modelId: this.modelId,\n              });\n            }\n          }\n\n          finalizeToolCalls();\n          this.logger.debug('[claude-code] Stream finalized, closing stream');\n          controller.close();\n        } catch (error: unknown) {\n          done();\n\n          this.logger.debug(\n            `[claude-code] Error during doStream: ${error instanceof Error ? error.message : String(error)}`\n          );\n\n          if (isClaudeCodeTruncationError(error, accumulatedText)) {\n            this.logger.warn(\n              `[claude-code] Detected truncated stream response, returning ${accumulatedText.length} characters of buffered text`\n            );\n            const truncationWarning: LanguageModelV2CallWarning = {\n              type: 'other',\n              message: CLAUDE_CODE_TRUNCATION_WARNING,\n            };\n            streamWarnings.push(truncationWarning);\n\n            if (textPartId) {\n              controller.enqueue({\n                type: 'text-end',\n                id: textPartId,\n              });\n            } else if (accumulatedText) {\n              const fallbackTextId = generateId();\n              controller.enqueue({\n                type: 'text-start',\n                id: fallbackTextId,\n              });\n              controller.enqueue({\n                type: 'text-delta',\n                id: fallbackTextId,\n                delta: accumulatedText,\n              });\n              controller.enqueue({\n                type: 'text-end',\n                id: fallbackTextId,\n              });\n            }\n\n            finalizeToolCalls();\n\n            const warningsJson = this.serializeWarningsForMetadata(streamWarnings);\n\n            controller.enqueue({\n              type: 'finish',\n              finishReason: 'length',\n              usage,\n              providerMetadata: {\n                'claude-code': {\n                  ...(this.sessionId !== undefined && { sessionId: this.sessionId }),\n                  truncated: true,\n                  ...(streamWarnings.length > 0 && {\n                    warnings: warningsJson as unknown as JSONValue,\n                  }),\n                },\n              },\n            });\n\n            controller.close();\n            return;\n          }\n\n          finalizeToolCalls();\n          let errorToEmit: unknown;\n\n          // Special handling for AbortError to preserve abort signal reason\n          if (isAbortError(error)) {\n            errorToEmit = options.abortSignal?.aborted ? options.abortSignal.reason : error;\n          } else {\n            // Use unified error handler\n            errorToEmit = this.handleClaudeCodeError(error, messagesPrompt, collectedStderr);\n          }\n\n          // Emit error as a stream part\n          controller.enqueue({\n            type: 'error',\n            error: errorToEmit,\n          });\n\n          controller.close();\n        } finally {\n          if (options.abortSignal && abortListener) {\n            options.abortSignal.removeEventListener('abort', abortListener);\n          }\n        }\n      },\n      cancel: () => {\n        if (options.abortSignal && abortListener) {\n          options.abortSignal.removeEventListener('abort', abortListener);\n        }\n      },\n    });\n\n    return {\n      stream: stream as unknown as ReadableStream<LanguageModelV2StreamPart>,\n      request: {\n        body: messagesPrompt,\n      },\n    };\n  }\n\n  private serializeWarningsForMetadata(warnings: LanguageModelV2CallWarning[]): JSONValue {\n    const result = warnings.map((w) => {\n      const base: Record<string, string> = { type: w.type };\n      if ('message' in w) {\n        const m = (w as { message?: unknown }).message;\n        if (m !== undefined) base.message = String(m);\n      }\n      if (w.type === 'unsupported-setting') {\n        const setting = (w as { setting: unknown }).setting;\n        if (setting !== undefined) base.setting = String(setting);\n        if ('details' in w) {\n          const d = (w as { details?: unknown }).details;\n          if (d !== undefined) base.details = String(d);\n        }\n      }\n      return base;\n    });\n    return result as unknown as JSONValue;\n  }\n}\n","import type { ModelMessage } from 'ai';\nimport type { SDKUserMessage } from '@anthropic-ai/claude-agent-sdk';\n\ntype SDKUserContentPart = SDKUserMessage['message']['content'][number];\n\ninterface StreamingSegment {\n  formatted: string;\n}\n\nconst IMAGE_URL_WARNING = 'Image URLs are not supported by this provider; supply base64/data URLs.';\nconst IMAGE_CONVERSION_WARNING = 'Unable to convert image content; supply base64/data URLs.';\n\nfunction normalizeBase64(base64: string): string {\n  return base64.replace(/\\s+/g, '');\n}\n\nfunction isImageMimeType(mimeType?: string): boolean {\n  return typeof mimeType === 'string' && mimeType.trim().toLowerCase().startsWith('image/');\n}\n\nfunction createImageContent(mediaType: string, data: string): SDKUserContentPart | undefined {\n  const trimmedType = mediaType.trim();\n  const trimmedData = normalizeBase64(data.trim());\n\n  if (!trimmedType || !trimmedData) {\n    return undefined;\n  }\n\n  return {\n    type: 'image',\n    source: {\n      type: 'base64',\n      media_type: trimmedType,\n      data: trimmedData,\n    },\n  } as SDKUserContentPart;\n}\n\nfunction extractMimeType(candidate: unknown): string | undefined {\n  if (typeof candidate === 'string' && candidate.trim()) {\n    return candidate.trim();\n  }\n  return undefined;\n}\n\nfunction parseObjectImage(\n  imageObj: Record<string, unknown>,\n  fallbackMimeType?: string\n): SDKUserContentPart | undefined {\n  const data = typeof imageObj.data === 'string' ? imageObj.data : undefined;\n  const mimeType = extractMimeType(\n    imageObj.mimeType ?? imageObj.mediaType ?? imageObj.media_type ?? fallbackMimeType\n  );\n  if (!data || !mimeType) {\n    return undefined;\n  }\n  return createImageContent(mimeType, data);\n}\n\nfunction parseStringImage(\n  value: string,\n  fallbackMimeType?: string\n): { content?: SDKUserContentPart; warning?: string } {\n  const trimmed = value.trim();\n\n  if (/^https?:\\/\\//i.test(trimmed)) {\n    return { warning: IMAGE_URL_WARNING };\n  }\n\n  const dataUrlMatch = trimmed.match(/^data:([^;]+);base64,(.+)$/i);\n  if (dataUrlMatch) {\n    const [, mediaType, data] = dataUrlMatch;\n    const content = createImageContent(mediaType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  const base64Match = trimmed.match(/^base64:([^,]+),(.+)$/i);\n  if (base64Match) {\n    const [, explicitMimeType, data] = base64Match;\n    const content = createImageContent(explicitMimeType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  if (fallbackMimeType) {\n    const content = createImageContent(fallbackMimeType, trimmed);\n    if (content) {\n      return { content };\n    }\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\nfunction parseImagePart(part: unknown): { content?: SDKUserContentPart; warning?: string } {\n  if (!part || typeof part !== 'object') {\n    return { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  const imageValue = (part as { image?: unknown }).image;\n  const mimeType = extractMimeType((part as { mimeType?: unknown }).mimeType);\n\n  if (typeof imageValue === 'string') {\n    return parseStringImage(imageValue, mimeType);\n  }\n\n  if (imageValue && typeof imageValue === 'object') {\n    const content = parseObjectImage(imageValue as Record<string, unknown>, mimeType);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\nfunction convertBinaryToBase64(data: Uint8Array | ArrayBuffer): string | undefined {\n  if (typeof Buffer !== 'undefined') {\n    const buffer =\n      data instanceof Uint8Array ? Buffer.from(data) : Buffer.from(new Uint8Array(data));\n    return buffer.toString('base64');\n  }\n\n  if (typeof btoa === 'function') {\n    const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n    let binary = '';\n    const chunkSize = 0x8000;\n    for (let i = 0; i < bytes.length; i += chunkSize) {\n      const chunk = bytes.subarray(i, i + chunkSize);\n      binary += String.fromCharCode(...chunk);\n    }\n    return btoa(binary);\n  }\n\n  return undefined;\n}\n\ntype FileLikePart = {\n  mediaType?: unknown;\n  mimeType?: unknown;\n  data?: unknown;\n};\n\nfunction parseFilePart(part: FileLikePart): { content?: SDKUserContentPart; warning?: string } {\n  const mimeType = extractMimeType(part.mediaType ?? part.mimeType);\n  if (!mimeType || !isImageMimeType(mimeType)) {\n    return {};\n  }\n\n  const data = part.data;\n  if (typeof data === 'string') {\n    const content = createImageContent(mimeType, data);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  if (\n    data instanceof Uint8Array ||\n    (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer)\n  ) {\n    const base64 = convertBinaryToBase64(data);\n    if (!base64) {\n      return { warning: IMAGE_CONVERSION_WARNING };\n    }\n    const content = createImageContent(mimeType, base64);\n    return content ? { content } : { warning: IMAGE_CONVERSION_WARNING };\n  }\n\n  return { warning: IMAGE_CONVERSION_WARNING };\n}\n\n/**\n * Converts AI SDK prompt format to Claude Code SDK message format.\n * Handles system prompts, user messages, assistant responses, and tool interactions.\n *\n * @param prompt - The AI SDK prompt containing messages\n * @param sessionId - The ID of the session to resume, if any\n * @returns An object containing the formatted message prompt and optional system prompt\n *\n * @example\n * ```typescript\n * const { messagesPrompt } = convertToClaudeCodeMessages(\n *   [{ role: 'user', content: 'Hello!' }]\n * );\n * ```\n *\n * @remarks\n * - Image parts are collected for streaming input; unsupported variants produce warnings\n * - Tool calls are simplified to \"[Tool calls made]\" notation\n * - JSON schema enforcement is handled natively by the SDK's outputFormat option (v0.1.45+)\n */\nexport function convertToClaudeCodeMessages(prompt: readonly ModelMessage[], sessionId?: string): {\n  messagesPrompt: string;\n  systemPrompt?: string;\n  warnings?: string[];\n  streamingContentParts: SDKUserMessage['message']['content'];\n  hasImageParts: boolean;\n} {\n  const messages: string[] = [];\n  const warnings: string[] = [];\n  let systemPrompt: string | undefined;\n  const streamingSegments: StreamingSegment[] = [];\n  const imageMap = new Map<number, SDKUserContentPart[]>();\n  let hasImageParts = false;\n  const lastMessage = prompt.length > 0 ? prompt[prompt.length - 1] : undefined;\n\n  const extractTextContent = (content: ModelMessage['content']): string => {\n    return typeof content === 'string'\n      ? content\n      : content.filter((part) => part.type === 'text').map((part) => part.text).join('\\n');\n  }\n\n  if (lastMessage?.role === 'user' && sessionId) {\n    // in case we are resuming a session, the last message is the one we want to continue with\n    const textContent = extractTextContent(lastMessage.content);\n    return {\n      messagesPrompt: textContent,\n      streamingContentParts: [{ type: 'text', text: textContent }],\n      hasImageParts,\n    };\n  }\n\n  const addSegment = (formatted: string): number => {\n    streamingSegments.push({ formatted });\n    return streamingSegments.length - 1;\n  };\n\n  const addImageForSegment = (segmentIndex: number, content: SDKUserContentPart): void => {\n    hasImageParts = true;\n    if (!imageMap.has(segmentIndex)) {\n      imageMap.set(segmentIndex, []);\n    }\n    imageMap.get(segmentIndex)?.push(content);\n  };\n\n  for (const message of prompt) {\n    switch (message.role) {\n      case 'system':\n        systemPrompt = message.content;\n        if (typeof message.content === 'string' && message.content.trim().length > 0) {\n          addSegment(message.content);\n        } else {\n          addSegment('');\n        }\n        break;\n\n      case 'user':\n        if (typeof message.content === 'string') {\n          messages.push(message.content);\n          addSegment(prompt.length > 1 ? `Human: ${message.content}` : message.content);\n        } else {\n          // Handle multi-part content\n          const textParts = message.content\n            .filter((part) => part.type === 'text')\n            .map((part) => part.text)\n            .join('\\n');\n\n          const segmentIndex = addSegment(textParts ? `Human: ${textParts}` : '');\n\n          if (textParts) {\n            messages.push(textParts);\n          }\n\n          for (const part of message.content) {\n            if (part.type === 'image') {\n              const { content, warning } = parseImagePart(part);\n              if (content) {\n                addImageForSegment(segmentIndex, content);\n              } else if (warning) {\n                warnings.push(warning);\n              }\n            } else if (part.type === 'file') {\n              const { content, warning } = parseFilePart(part);\n              if (content) {\n                addImageForSegment(segmentIndex, content);\n              } else if (warning) {\n                warnings.push(warning);\n              }\n            }\n          }\n        }\n        break;\n\n      case 'assistant': {\n        let assistantContent = '';\n        if (typeof message.content === 'string') {\n          assistantContent = message.content;\n        } else {\n          const textParts = message.content\n            .filter((part) => part.type === 'text')\n            .map((part) => part.text)\n            .join('\\n');\n\n          if (textParts) {\n            assistantContent = textParts;\n          }\n\n          // Handle tool calls if present\n          const toolCalls = message.content.filter((part) => part.type === 'tool-call');\n          if (toolCalls.length > 0) {\n            // For now, we'll just note that tool calls were made\n            assistantContent += `\\n[Tool calls made]`;\n          }\n        }\n        const formattedAssistant = `Assistant: ${assistantContent}`;\n        messages.push(formattedAssistant);\n        addSegment(formattedAssistant);\n        break;\n      }\n\n      case 'tool':\n        // Tool results could be included in the conversation\n        for (const tool of message.content) {\n          const resultText =\n            tool.output.type === 'text' ? tool.output.value : JSON.stringify(tool.output.value);\n          const formattedToolResult = `Tool Result (${tool.toolName}): ${resultText}`;\n          messages.push(formattedToolResult);\n          addSegment(formattedToolResult);\n        }\n        break;\n    }\n  }\n\n  // For the SDK, we need to provide a single prompt string\n  // Format the conversation history properly\n\n  // Combine system prompt with messages\n  let finalPrompt = '';\n\n  // Add system prompt at the beginning if present\n  if (systemPrompt) {\n    finalPrompt = systemPrompt;\n  }\n\n  if (messages.length > 0) {\n    // Format messages\n    const formattedMessages = [];\n    for (let i = 0; i < messages.length; i++) {\n      const msg = messages[i];\n      // Check if this is a user or assistant message based on content\n      if (msg.startsWith('Assistant:') || msg.startsWith('Tool Result')) {\n        formattedMessages.push(msg);\n      } else {\n        // User messages\n        formattedMessages.push(`Human: ${msg}`);\n      }\n    }\n\n    // Combine system prompt with messages\n    if (finalPrompt) {\n      const joinedMessages = formattedMessages.join('\\n\\n');\n      finalPrompt = joinedMessages ? `${finalPrompt}\\n\\n${joinedMessages}` : finalPrompt;\n    } else {\n      finalPrompt = formattedMessages.join('\\n\\n');\n    }\n  }\n\n  // Build streaming parts including text and images\n  const streamingParts: SDKUserContentPart[] = [];\n  const imagePartsInOrder: SDKUserContentPart[] = [];\n\n  const appendImagesForIndex = (index: number) => {\n    const images = imageMap.get(index);\n    if (!images) {\n      return;\n    }\n    images.forEach((image) => {\n      streamingParts.push(image);\n      imagePartsInOrder.push(image);\n    });\n  };\n\n  if (streamingSegments.length > 0) {\n    let accumulatedText = '';\n    let emittedText = false;\n\n    const flushText = () => {\n      if (!accumulatedText) {\n        return;\n      }\n      streamingParts.push({ type: 'text', text: accumulatedText });\n      accumulatedText = '';\n      emittedText = true;\n    };\n\n    streamingSegments.forEach((segment, index) => {\n      const segmentText = segment.formatted;\n      if (segmentText) {\n        if (!accumulatedText) {\n          accumulatedText = emittedText ? `\\n\\n${segmentText}` : segmentText;\n        } else {\n          accumulatedText += `\\n\\n${segmentText}`;\n        }\n      }\n\n      if (imageMap.has(index)) {\n        flushText();\n        appendImagesForIndex(index);\n      }\n    });\n\n    flushText();\n  }\n\n  // Note: JSON schema enforcement is now handled natively by the SDK's outputFormat option (v0.1.45+)\n  // No prompt injection needed - structured outputs are guaranteed by the SDK\n\n  return {\n    messagesPrompt: finalPrompt,\n    systemPrompt,\n    ...(warnings.length > 0 && { warnings }),\n    streamingContentParts:\n      streamingParts.length > 0\n        ? (streamingParts as SDKUserMessage['message']['content'])\n        : ([\n            { type: 'text', text: finalPrompt },\n            ...imagePartsInOrder,\n          ] as SDKUserMessage['message']['content']),\n    hasImageParts,\n  };\n}\n","import { APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\n\n/**\n * Metadata associated with Claude Code SDK errors.\n * Provides additional context about command execution failures.\n */\nexport interface ClaudeCodeErrorMetadata {\n  /**\n   * Error code from the CLI process (e.g., 'ENOENT', 'ETIMEDOUT').\n   */\n  code?: string;\n\n  /**\n   * Exit code from the Claude Code SDK process.\n   * Common codes:\n   * - 401: Authentication error\n   * - 1: General error\n   */\n  exitCode?: number;\n\n  /**\n   * Standard error output from the CLI process.\n   */\n  stderr?: string;\n\n  /**\n   * Excerpt from the prompt that caused the error.\n   * Limited to first 200 characters for debugging.\n   */\n  promptExcerpt?: string;\n}\n\n/**\n * Creates an APICallError with Claude Code specific metadata.\n * Used for general CLI execution errors.\n *\n * @param options - Error details and metadata\n * @param options.message - Human-readable error message\n * @param options.code - Error code from the CLI process\n * @param options.exitCode - Exit code from the CLI\n * @param options.stderr - Standard error output\n * @param options.promptExcerpt - Excerpt of the prompt that caused the error\n * @param options.isRetryable - Whether the error is potentially retryable\n * @returns An APICallError instance with Claude Code metadata\n *\n * @example\n * ```typescript\n * throw createAPICallError({\n *   message: 'Claude Code SDK failed',\n *   code: 'ENOENT',\n *   isRetryable: true\n * });\n * ```\n */\nexport function createAPICallError({\n  message,\n  code,\n  exitCode,\n  stderr,\n  promptExcerpt,\n  isRetryable = false,\n}: ClaudeCodeErrorMetadata & {\n  message: string;\n  isRetryable?: boolean;\n}): APICallError {\n  const metadata: ClaudeCodeErrorMetadata = {\n    code,\n    exitCode,\n    stderr,\n    promptExcerpt,\n  };\n\n  return new APICallError({\n    message,\n    isRetryable,\n    url: 'claude-code-cli://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : undefined,\n    data: metadata,\n  });\n}\n\n/**\n * Creates an authentication error for Claude Code SDK login failures.\n *\n * @param options - Error configuration\n * @param options.message - Error message describing the authentication failure\n * @returns A LoadAPIKeyError instance\n *\n * @example\n * ```typescript\n * throw createAuthenticationError({\n *   message: 'Please run \"claude login\" to authenticate'\n * });\n * ```\n */\nexport function createAuthenticationError({ message }: { message: string }): LoadAPIKeyError {\n  return new LoadAPIKeyError({\n    message:\n      message || 'Authentication failed. Please ensure Claude Code SDK is properly authenticated.',\n  });\n}\n\n/**\n * Creates a timeout error for Claude Code SDK operations.\n *\n * @param options - Timeout error details\n * @param options.message - Error message describing the timeout\n * @param options.promptExcerpt - Excerpt of the prompt that timed out\n * @param options.timeoutMs - Timeout duration in milliseconds\n * @returns An APICallError instance configured as a timeout error\n *\n * @example\n * ```typescript\n * throw createTimeoutError({\n *   message: 'Request timed out after 2 minutes',\n *   timeoutMs: 120000\n * });\n * ```\n */\nexport function createTimeoutError({\n  message,\n  promptExcerpt,\n  timeoutMs,\n}: {\n  message: string;\n  promptExcerpt?: string;\n  timeoutMs?: number;\n}): APICallError {\n  // Store timeoutMs in metadata for potential use by error handlers\n  const metadata: ClaudeCodeErrorMetadata = {\n    code: 'TIMEOUT',\n    promptExcerpt,\n  };\n\n  return new APICallError({\n    message,\n    isRetryable: true,\n    url: 'claude-code-cli://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : undefined,\n    data: timeoutMs !== undefined ? { ...metadata, timeoutMs } : metadata,\n  });\n}\n\n/**\n * Checks if an error is an authentication error.\n * Returns true for LoadAPIKeyError instances or APICallError with exit code 401.\n *\n * @param error - The error to check\n * @returns True if the error is an authentication error\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   if (isAuthenticationError(error)) {\n *     console.log('Please authenticate with Claude Code SDK');\n *   }\n * }\n * ```\n */\nexport function isAuthenticationError(error: unknown): boolean {\n  if (error instanceof LoadAPIKeyError) return true;\n  if (error instanceof APICallError && (error.data as ClaudeCodeErrorMetadata)?.exitCode === 401)\n    return true;\n  return false;\n}\n\n/**\n * Checks if an error is a timeout error.\n * Returns true for APICallError instances with code 'TIMEOUT'.\n *\n * @param error - The error to check\n * @returns True if the error is a timeout error\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   if (isTimeoutError(error)) {\n *     console.log('Request timed out, consider retrying');\n *   }\n * }\n * ```\n */\nexport function isTimeoutError(error: unknown): boolean {\n  if (error instanceof APICallError && (error.data as ClaudeCodeErrorMetadata)?.code === 'TIMEOUT')\n    return true;\n  return false;\n}\n\n/**\n * Extracts Claude Code error metadata from an error object.\n *\n * @param error - The error to extract metadata from\n * @returns The error metadata if available, undefined otherwise\n *\n * @example\n * ```typescript\n * try {\n *   await model.generate(...);\n * } catch (error) {\n *   const metadata = getErrorMetadata(error);\n *   if (metadata?.exitCode === 401) {\n *     console.log('Authentication required');\n *   }\n * }\n * ```\n */\nexport function getErrorMetadata(error: unknown): ClaudeCodeErrorMetadata | undefined {\n  if (error instanceof APICallError && error.data) {\n    return error.data as ClaudeCodeErrorMetadata;\n  }\n  return undefined;\n}\n","import type { LanguageModelV2FinishReason } from '@ai-sdk/provider';\n\n/**\n * Maps Claude Code SDK result subtypes to AI SDK finish reasons.\n *\n * @param subtype - The result subtype from Claude Code SDK\n * @returns The corresponding AI SDK finish reason\n *\n * @example\n * ```typescript\n * const finishReason = mapClaudeCodeFinishReason('error_max_turns');\n * // Returns: 'length'\n * ```\n *\n * @remarks\n * Mappings:\n * - 'success' -> 'stop' (normal completion)\n * - 'error_max_turns' -> 'length' (hit turn limit)\n * - 'error_during_execution' -> 'error' (execution error)\n * - default -> 'stop' (unknown subtypes treated as normal completion)\n */\nexport function mapClaudeCodeFinishReason(subtype?: string): LanguageModelV2FinishReason {\n  switch (subtype) {\n    case 'success':\n      return 'stop';\n    case 'error_max_turns':\n      return 'length';\n    case 'error_during_execution':\n      return 'error';\n    default:\n      return 'stop';\n  }\n}\n","import { z } from 'zod';\nimport { existsSync } from 'fs';\n\n/**\n * Validation schemas and utilities for Claude Code provider inputs.\n * Uses Zod for type-safe validation following AI SDK patterns.\n */\n\n// Helper for Zod v3/v4 compatibility\n// Use a simple z.any() for functions to work with both versions\nconst loggerFunctionSchema = z.object({\n  debug: z.any().refine((val) => typeof val === 'function', {\n    message: 'debug must be a function',\n  }),\n  info: z.any().refine((val) => typeof val === 'function', {\n    message: 'info must be a function',\n  }),\n  warn: z.any().refine((val) => typeof val === 'function', {\n    message: 'warn must be a function',\n  }),\n  error: z.any().refine((val) => typeof val === 'function', {\n    message: 'error must be a function',\n  }),\n});\n\n/**\n * Schema for validating Claude Code settings.\n * Ensures all settings are within acceptable ranges and formats.\n */\nexport const claudeCodeSettingsSchema = z\n  .object({\n    pathToClaudeCodeExecutable: z.string().optional(),\n    customSystemPrompt: z.string().optional(),\n    appendSystemPrompt: z.string().optional(),\n    systemPrompt: z\n      .union([\n        z.string(),\n        z.object({\n          type: z.literal('preset'),\n          preset: z.literal('claude_code'),\n          append: z.string().optional(),\n        }),\n      ])\n      .optional(),\n    maxTurns: z.number().int().min(1).max(100).optional(),\n    maxThinkingTokens: z.number().int().positive().max(100000).optional(),\n    cwd: z\n      .string()\n      .refine(\n        (val) => {\n          // Skip directory validation in non-Node environments\n          if (typeof process === 'undefined' || !process.versions?.node) {\n            return true;\n          }\n          return !val || existsSync(val);\n        },\n        { message: 'Working directory must exist' }\n      )\n      .optional(),\n    executable: z.enum(['bun', 'deno', 'node']).optional(),\n    executableArgs: z.array(z.string()).optional(),\n    permissionMode: z.enum(['default', 'acceptEdits', 'bypassPermissions', 'plan']).optional(),\n    permissionPromptToolName: z.string().optional(),\n    continue: z.boolean().optional(),\n    resume: z.string().optional(),\n    allowedTools: z.array(z.string()).optional(),\n    disallowedTools: z.array(z.string()).optional(),\n    betas: z.array(z.string()).optional(),\n    allowDangerouslySkipPermissions: z.boolean().optional(),\n    enableFileCheckpointing: z.boolean().optional(),\n    maxBudgetUsd: z.number().min(0).optional(),\n    plugins: z\n      .array(\n        z\n          .object({\n            type: z.string(),\n            path: z.string(),\n          })\n          .passthrough()\n      )\n      .optional(),\n    resumeSessionAt: z.string().optional(),\n    sandbox: z\n      .any()\n      .refine((val) => val === undefined || typeof val === 'object', {\n        message: 'sandbox must be an object',\n      })\n      .optional(),\n    tools: z\n      .union([\n        z.array(z.string()),\n        z.object({\n          type: z.literal('preset'),\n          preset: z.literal('claude_code'),\n        }),\n      ])\n      .optional(),\n    settingSources: z.array(z.enum(['user', 'project', 'local'])).optional(),\n    streamingInput: z.enum(['auto', 'always', 'off']).optional(),\n    // Hooks and tool-permission callback (permissive validation of shapes)\n    canUseTool: z\n      .any()\n      .refine((v) => v === undefined || typeof v === 'function', {\n        message: 'canUseTool must be a function',\n      })\n      .optional(),\n    hooks: z\n      .record(\n        z.string(),\n        z.array(\n          z.object({\n            matcher: z.string().optional(),\n            hooks: z.array(z.any()).nonempty(),\n          })\n        )\n      )\n      .optional(),\n    aiSdkTools: z\n      .record(\n        z.string(),\n        z.object({\n          description: z.string().optional(),\n          inputSchema: z.any().optional(),\n          parameters: z.any().optional(),\n          execute: z.function().optional(),\n        })\n      )\n      .optional(),\n    mcpServers: z\n      .record(\n        z.string(),\n        z.union([\n          // McpStdioServerConfig\n          z.object({\n            type: z.literal('stdio').optional(),\n            command: z.string(),\n            args: z.array(z.string()).optional(),\n            env: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpSSEServerConfig\n          z.object({\n            type: z.literal('sse'),\n            url: z.string(),\n            headers: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpHttpServerConfig\n          z.object({\n            type: z.literal('http'),\n            url: z.string(),\n            headers: z.record(z.string(), z.string()).optional(),\n          }),\n          // McpSdkServerConfig (in-process custom tools)\n          z.object({\n            type: z.literal('sdk'),\n            name: z.string(),\n            instance: z.any(),\n          }),\n        ])\n      )\n      .optional(),\n    verbose: z.boolean().optional(),\n    logger: z.union([z.literal(false), loggerFunctionSchema]).optional(),\n    env: z.record(z.string(), z.string().optional()).optional(),\n    additionalDirectories: z.array(z.string()).optional(),\n    agents: z\n      .record(\n        z.string(),\n        z.object({\n          description: z.string(),\n          tools: z.array(z.string()).optional(),\n          prompt: z.string(),\n          model: z.enum(['sonnet', 'opus', 'haiku', 'inherit']).optional(),\n        })\n      )\n      .optional(),\n    includePartialMessages: z.boolean().optional(),\n    fallbackModel: z.string().optional(),\n    forkSession: z.boolean().optional(),\n    stderr: z\n      .any()\n      .refine((val) => val === undefined || typeof val === 'function', {\n        message: 'stderr must be a function',\n      })\n      .optional(),\n    strictMcpConfig: z.boolean().optional(),\n    extraArgs: z.record(z.string(), z.union([z.string(), z.null()])).optional(),\n    sdkOptions: z.record(z.string(), z.any()).optional(),\n  })\n  .strict();\n\n/**\n * Validates a model ID and returns warnings if needed.\n *\n * @param modelId - The model ID to validate\n * @returns Warning message if model is unknown, undefined otherwise\n */\nexport function validateModelId(modelId: string): string | undefined {\n  const knownModels = ['opus', 'sonnet', 'haiku'];\n\n  // Check for empty or whitespace-only\n  if (!modelId || modelId.trim() === '') {\n    throw new Error('Model ID cannot be empty');\n  }\n\n  // Warn about unknown models but allow them\n  if (!knownModels.includes(modelId)) {\n    return `Unknown model ID: '${modelId}'. Proceeding with custom model. Known models are: ${knownModels.join(', ')}`;\n  }\n\n  return undefined;\n}\n\n/**\n * Validates Claude Code settings and returns validation results.\n *\n * @param settings - The settings object to validate\n * @returns Object with validation results and any warnings\n */\nexport function validateSettings(settings: unknown): {\n  valid: boolean;\n  warnings: string[];\n  errors: string[];\n} {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  try {\n    // Parse with Zod schema\n    const result = claudeCodeSettingsSchema.safeParse(settings);\n\n    if (!result.success) {\n      // Extract user-friendly error messages\n      // Support both Zod v3 (errors) and v4 (issues)\n      const errorObject = result.error as {\n        errors?: Array<{ path: string[]; message: string }>;\n        issues?: Array<{ path: string[]; message: string }>;\n      };\n      const issues = errorObject.errors || errorObject.issues || [];\n      issues.forEach((err: { path: string[]; message: string }) => {\n        const path = err.path.join('.');\n        errors.push(`${path ? `${path}: ` : ''}${err.message}`);\n      });\n      return { valid: false, warnings, errors };\n    }\n\n    // Additional validation warnings\n    const validSettings = result.data;\n\n    // Warn about high turn limits\n    if (validSettings.maxTurns && validSettings.maxTurns > 20) {\n      warnings.push(\n        `High maxTurns value (${validSettings.maxTurns}) may lead to long-running conversations`\n      );\n    }\n\n    // Warn about very high thinking tokens\n    if (validSettings.maxThinkingTokens && validSettings.maxThinkingTokens > 50000) {\n      warnings.push(\n        `Very high maxThinkingTokens (${validSettings.maxThinkingTokens}) may increase response time`\n      );\n    }\n\n    // Check if both allowedTools and disallowedTools are specified\n    if (validSettings.allowedTools && validSettings.disallowedTools) {\n      warnings.push(\n        'Both allowedTools and disallowedTools are specified. Only allowedTools will be used.'\n      );\n    }\n\n    // Validate tool name format\n    const validateToolNames = (tools: string[], type: string) => {\n      tools.forEach((tool) => {\n        // Basic validation - tool names should be alphanumeric with optional specifiers\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\\([^)]*\\))?$/.test(tool) && !tool.startsWith('mcp__')) {\n          warnings.push(`Unusual ${type} tool name format: '${tool}'`);\n        }\n      });\n    };\n\n    if (validSettings.allowedTools) {\n      validateToolNames(validSettings.allowedTools, 'allowed');\n    }\n\n    if (validSettings.disallowedTools) {\n      validateToolNames(validSettings.disallowedTools, 'disallowed');\n    }\n\n    return { valid: true, warnings, errors };\n  } catch (error) {\n    errors.push(`Validation error: ${error instanceof Error ? error.message : String(error)}`);\n    return { valid: false, warnings, errors };\n  }\n}\n\n/**\n * Validates prompt length and format.\n *\n * @param prompt - The prompt to validate\n * @returns Warning message if prompt might cause issues\n */\nexport function validatePrompt(prompt: string): string | undefined {\n  // Very long prompts might cause issues\n  const MAX_PROMPT_LENGTH = 100000; // ~25k tokens\n\n  if (prompt.length > MAX_PROMPT_LENGTH) {\n    return `Very long prompt (${prompt.length} characters) may cause performance issues or timeouts`;\n  }\n\n  return undefined;\n}\n\n/**\n * Validates session ID format.\n *\n * @param sessionId - The session ID to validate\n * @returns Warning message if format is unusual\n */\nexport function validateSessionId(sessionId: string): string | undefined {\n  // Session IDs from Claude Code are typically UUID-like\n  // But we don't want to be too strict as format might change\n  if (sessionId && !/^[a-zA-Z0-9-_]+$/.test(sessionId)) {\n    return `Unusual session ID format. This may cause issues with session resumption.`;\n  }\n\n  return undefined;\n}\n","import type { Logger } from './types.js';\n\n/**\n * Default logger that uses console with level tags.\n */\nconst defaultLogger: Logger = {\n  // eslint-disable-next-line no-console\n  debug: (message: string) => console.debug(`[DEBUG] ${message}`),\n  // eslint-disable-next-line no-console\n  info: (message: string) => console.info(`[INFO] ${message}`),\n  warn: (message: string) => console.warn(`[WARN] ${message}`),\n  error: (message: string) => console.error(`[ERROR] ${message}`),\n};\n\n/**\n * No-op logger that discards all messages.\n */\nconst noopLogger: Logger = {\n  debug: () => {},\n  info: () => {},\n  warn: () => {},\n  error: () => {},\n};\n\n/**\n * Gets the appropriate logger based on configuration.\n *\n * @param logger - Logger configuration from settings\n * @returns The logger to use\n */\nexport function getLogger(logger: Logger | false | undefined): Logger {\n  if (logger === false) {\n    return noopLogger;\n  }\n\n  if (logger === undefined) {\n    return defaultLogger;\n  }\n\n  return logger;\n}\n\n/**\n * Creates a verbose-aware logger that only logs debug/info when verbose is enabled.\n * Warn and error are always logged regardless of verbose setting.\n *\n * @param logger - Base logger to wrap\n * @param verbose - Whether to enable verbose (debug/info) logging\n * @returns Logger with verbose-aware behavior\n */\nexport function createVerboseLogger(logger: Logger, verbose: boolean = false): Logger {\n  if (verbose) {\n    // When verbose is enabled, use all log levels\n    return logger;\n  }\n\n  // When verbose is disabled, only allow warn/error\n  // Bind methods to preserve 'this' context for custom loggers\n  return {\n    debug: () => {}, // No-op when not verbose\n    info: () => {}, // No-op when not verbose\n    warn: logger.warn.bind(logger),\n    error: logger.error.bind(logger),\n  };\n}\n","/**\n * Provider exports for creating and configuring Claude Code instances.\n * @module claude-code\n */\n\n/**\n * Creates a new Claude Code provider instance and the default provider instance.\n * @see {@link createClaudeCode} for creating custom provider instances\n * @see {@link claudeCode} for the default provider instance\n */\nexport { createClaudeCode, claudeCode } from './claude-code-provider.js';\n\n/**\n * Type definitions for the Claude Code provider.\n * @see {@link ClaudeCodeProvider} for the provider interface\n * @see {@link ClaudeCodeProviderSettings} for provider configuration options\n */\nexport type { ClaudeCodeProvider, ClaudeCodeProviderSettings } from './claude-code-provider.js';\n\n/**\n * Language model implementation for Claude Code.\n * This class implements the AI SDK's LanguageModelV2 interface.\n */\nexport { ClaudeCodeLanguageModel } from './claude-code-language-model.js';\n\n/**\n * Type definitions for Claude Code language models.\n * @see {@link ClaudeCodeModelId} for supported model identifiers\n * @see {@link ClaudeCodeLanguageModelOptions} for model configuration options\n */\nexport type {\n  ClaudeCodeModelId,\n  ClaudeCodeLanguageModelOptions,\n} from './claude-code-language-model.js';\n\n/**\n * Settings for configuring Claude Code behavior.\n * Includes options for customizing the CLI execution, permissions, and tool usage.\n */\nexport type { ClaudeCodeSettings, Logger } from './types.js';\n\n// Convenience re-exports from the SDK for custom tools and hooks\nexport { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';\nexport { createCustomMcpServer } from './mcp-helpers.js';\nexport type {\n  HookEvent,\n  HookCallback,\n  HookCallbackMatcher,\n  HookInput,\n  HookJSONOutput,\n  PreToolUseHookInput,\n  PostToolUseHookInput,\n  UserPromptSubmitHookInput,\n  SessionStartHookInput,\n  SessionEndHookInput,\n  CanUseTool,\n  PermissionResult,\n  PermissionUpdate,\n  PermissionBehavior,\n  PermissionRuleValue,\n  McpServerConfig,\n  McpSdkServerConfigWithInstance,\n  OutputFormat,\n} from '@anthropic-ai/claude-agent-sdk';\n\n/**\n * Error handling utilities for Claude Code.\n * These functions help create and identify specific error types.\n *\n * @see {@link isAuthenticationError} to check for authentication failures\n * @see {@link isTimeoutError} to check for timeout errors\n * @see {@link getErrorMetadata} to extract error metadata\n * @see {@link createAPICallError} to create general API errors\n * @see {@link createAuthenticationError} to create authentication errors\n * @see {@link createTimeoutError} to create timeout errors\n */\nexport {\n  isAuthenticationError,\n  isTimeoutError,\n  getErrorMetadata,\n  createAPICallError,\n  createAuthenticationError,\n  createTimeoutError,\n} from './errors.js';\n\n/**\n * Metadata associated with Claude Code errors.\n * Contains additional context about CLI execution failures.\n */\nexport type { ClaudeCodeErrorMetadata } from './errors.js';\n","import { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';\nimport type { McpSdkServerConfigWithInstance } from '@anthropic-ai/claude-agent-sdk';\nimport { type ZodRawShape, type ZodObject } from 'zod';\n\n/**\n * Optional annotations for content items, per MCP specification.\n * Validated against MCP SDK schema version 2025-06-18.\n */\ntype ContentAnnotations = {\n  /** Intended audience(s) for this content */\n  audience?: ('user' | 'assistant')[];\n  /** Priority hint (0 = least important, 1 = most important) */\n  priority?: number;\n  /** ISO 8601 timestamp of last modification */\n  lastModified?: string;\n};\n\n/**\n * Convenience helper to create an SDK MCP server from a simple tool map.\n * Each tool provides a description, a Zod object schema, and a handler.\n *\n * Type definition validated against MCP SDK specification version 2025-06-18.\n * See: https://modelcontextprotocol.io/specification/2025-06-18/server/tools\n */\nexport type MinimalCallToolResult = {\n  content: Array<\n    | {\n        /** Text content */\n        type: 'text';\n        /** The text content (plain text or structured format like JSON) */\n        text: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Image content (base64-encoded) */\n        type: 'image';\n        /** Base64-encoded image data */\n        data: string;\n        /** MIME type of the image (e.g., image/png, image/jpeg) */\n        mimeType: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Audio content (base64-encoded) */\n        type: 'audio';\n        /** Base64-encoded audio data */\n        data: string;\n        /** MIME type of the audio (e.g., audio/wav, audio/mp3) */\n        mimeType: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Embedded resource with full content (text or blob) */\n        type: 'resource';\n        /** Resource contents - either text or blob variant */\n        resource: { uri: string; _meta?: Record<string, unknown>; [key: string]: unknown } & (\n          | { text: string; mimeType?: string }\n          | { blob: string; mimeType: string }\n        );\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n    | {\n        /** Resource link (reference only - no embedded content) */\n        type: 'resource_link';\n        /** URI of the resource */\n        uri: string;\n        /** Human-readable name (required per MCP spec) */\n        name: string;\n        /** Optional description of what this resource represents */\n        description?: string;\n        /** MIME type of the resource, if known */\n        mimeType?: string;\n        annotations?: ContentAnnotations;\n        _meta?: Record<string, unknown>;\n        [key: string]: unknown;\n      }\n  >;\n  isError?: boolean;\n  structuredContent?: Record<string, unknown>;\n  _meta?: Record<string, unknown>;\n  [key: string]: unknown;\n};\n\nexport function createCustomMcpServer<\n  Tools extends Record<\n    string,\n    {\n      description: string;\n      inputSchema: ZodObject<ZodRawShape>;\n      handler: (args: Record<string, unknown>, extra: unknown) => Promise<MinimalCallToolResult>;\n    }\n  >,\n>(config: { name: string; version?: string; tools: Tools }): McpSdkServerConfigWithInstance {\n  const defs = Object.entries(config.tools).map(([name, def]) =>\n    tool(\n      name,\n      def.description,\n      def.inputSchema.shape as ZodRawShape,\n      (args: Record<string, unknown>, extra: unknown) => def.handler(args, extra)\n    )\n  );\n  return createSdkMcpServer({ name: config.name, version: config.version, tools: defs });\n}\n"],"mappings":";AACA,SAAS,oBAAAA,yBAAwB;;;ACOjC,SAAS,wBAAuD;AAChE,SAAS,kBAAkB;;;ACA3B,IAAM,oBAAoB;AAC1B,IAAM,2BAA2B;AAEjC,SAAS,gBAAgB,QAAwB;AAC/C,SAAO,OAAO,QAAQ,QAAQ,EAAE;AAClC;AAEA,SAAS,gBAAgB,UAA4B;AACnD,SAAO,OAAO,aAAa,YAAY,SAAS,KAAK,EAAE,YAAY,EAAE,WAAW,QAAQ;AAC1F;AAEA,SAAS,mBAAmB,WAAmB,MAA8C;AAC3F,QAAM,cAAc,UAAU,KAAK;AACnC,QAAM,cAAc,gBAAgB,KAAK,KAAK,CAAC;AAE/C,MAAI,CAAC,eAAe,CAAC,aAAa;AAChC,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,MACN,MAAM;AAAA,MACN,YAAY;AAAA,MACZ,MAAM;AAAA,IACR;AAAA,EACF;AACF;AAEA,SAAS,gBAAgB,WAAwC;AAC/D,MAAI,OAAO,cAAc,YAAY,UAAU,KAAK,GAAG;AACrD,WAAO,UAAU,KAAK;AAAA,EACxB;AACA,SAAO;AACT;AAEA,SAAS,iBACP,UACA,kBACgC;AAChC,QAAM,OAAO,OAAO,SAAS,SAAS,WAAW,SAAS,OAAO;AACjE,QAAM,WAAW;AAAA,IACf,SAAS,YAAY,SAAS,aAAa,SAAS,cAAc;AAAA,EACpE;AACA,MAAI,CAAC,QAAQ,CAAC,UAAU;AACtB,WAAO;AAAA,EACT;AACA,SAAO,mBAAmB,UAAU,IAAI;AAC1C;AAEA,SAAS,iBACP,OACA,kBACoD;AACpD,QAAM,UAAU,MAAM,KAAK;AAE3B,MAAI,gBAAgB,KAAK,OAAO,GAAG;AACjC,WAAO,EAAE,SAAS,kBAAkB;AAAA,EACtC;AAEA,QAAM,eAAe,QAAQ,MAAM,6BAA6B;AAChE,MAAI,cAAc;AAChB,UAAM,CAAC,EAAE,WAAW,IAAI,IAAI;AAC5B,UAAM,UAAU,mBAAmB,WAAW,IAAI;AAClD,WAAO,UAAU,EAAE,QAAQ,IAAI,EAAE,SAAS,yBAAyB;AAAA,EACrE;AAEA,QAAM,cAAc,QAAQ,MAAM,wBAAwB;AAC1D,MAAI,aAAa;AACf,UAAM,CAAC,EAAE,kBAAkB,IAAI,IAAI;AACnC,UAAM,UAAU,mBAAmB,kBAAkB,IAAI;AACzD,WAAO,UAAU,EAAE,QAAQ,IAAI,EAAE,SAAS,yBAAyB;AAAA,EACrE;AAEA,MAAI,kBAAkB;AACpB,UAAM,UAAU,mBAAmB,kBAAkB,OAAO;AAC5D,QAAI,SAAS;AACX,aAAO,EAAE,QAAQ;AAAA,IACnB;AAAA,EACF;AAEA,SAAO,EAAE,SAAS,yBAAyB;AAC7C;AAEA,SAAS,eAAe,MAAmE;AACzF,MAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,WAAO,EAAE,SAAS,yBAAyB;AAAA,EAC7C;AAEA,QAAM,aAAc,KAA6B;AACjD,QAAM,WAAW,gBAAiB,KAAgC,QAAQ;AAE1E,MAAI,OAAO,eAAe,UAAU;AAClC,WAAO,iBAAiB,YAAY,QAAQ;AAAA,EAC9C;AAEA,MAAI,cAAc,OAAO,eAAe,UAAU;AAChD,UAAM,UAAU,iBAAiB,YAAuC,QAAQ;AAChF,WAAO,UAAU,EAAE,QAAQ,IAAI,EAAE,SAAS,yBAAyB;AAAA,EACrE;AAEA,SAAO,EAAE,SAAS,yBAAyB;AAC7C;AAEA,SAAS,sBAAsB,MAAoD;AACjF,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,SACJ,gBAAgB,aAAa,OAAO,KAAK,IAAI,IAAI,OAAO,KAAK,IAAI,WAAW,IAAI,CAAC;AACnF,WAAO,OAAO,SAAS,QAAQ;AAAA,EACjC;AAEA,MAAI,OAAO,SAAS,YAAY;AAC9B,UAAM,QAAQ,gBAAgB,aAAa,OAAO,IAAI,WAAW,IAAI;AACrE,QAAI,SAAS;AACb,UAAM,YAAY;AAClB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,WAAW;AAChD,YAAM,QAAQ,MAAM,SAAS,GAAG,IAAI,SAAS;AAC7C,gBAAU,OAAO,aAAa,GAAG,KAAK;AAAA,IACxC;AACA,WAAO,KAAK,MAAM;AAAA,EACpB;AAEA,SAAO;AACT;AAQA,SAAS,cAAc,MAAwE;AAC7F,QAAM,WAAW,gBAAgB,KAAK,aAAa,KAAK,QAAQ;AAChE,MAAI,CAAC,YAAY,CAAC,gBAAgB,QAAQ,GAAG;AAC3C,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,OAAO,KAAK;AAClB,MAAI,OAAO,SAAS,UAAU;AAC5B,UAAM,UAAU,mBAAmB,UAAU,IAAI;AACjD,WAAO,UAAU,EAAE,QAAQ,IAAI,EAAE,SAAS,yBAAyB;AAAA,EACrE;AAEA,MACE,gBAAgB,cACf,OAAO,gBAAgB,eAAe,gBAAgB,aACvD;AACA,UAAM,SAAS,sBAAsB,IAAI;AACzC,QAAI,CAAC,QAAQ;AACX,aAAO,EAAE,SAAS,yBAAyB;AAAA,IAC7C;AACA,UAAM,UAAU,mBAAmB,UAAU,MAAM;AACnD,WAAO,UAAU,EAAE,QAAQ,IAAI,EAAE,SAAS,yBAAyB;AAAA,EACrE;AAEA,SAAO,EAAE,SAAS,yBAAyB;AAC7C;AAsBO,SAAS,4BAA4B,QAAiC,WAM3E;AACA,QAAM,WAAqB,CAAC;AAC5B,QAAM,WAAqB,CAAC;AAC5B,MAAI;AACJ,QAAM,oBAAwC,CAAC;AAC/C,QAAM,WAAW,oBAAI,IAAkC;AACvD,MAAI,gBAAgB;AACpB,QAAM,cAAc,OAAO,SAAS,IAAI,OAAO,OAAO,SAAS,CAAC,IAAI;AAEpE,QAAM,qBAAqB,CAAC,YAA6C;AACvE,WAAO,OAAO,YAAY,WACtB,UACA,QAAQ,OAAO,CAAC,SAAS,KAAK,SAAS,MAAM,EAAE,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE,KAAK,IAAI;AAAA,EACvF;AAEA,MAAI,aAAa,SAAS,UAAU,WAAW;AAE7C,UAAM,cAAc,mBAAmB,YAAY,OAAO;AAC1D,WAAO;AAAA,MACL,gBAAgB;AAAA,MAChB,uBAAuB,CAAC,EAAE,MAAM,QAAQ,MAAM,YAAY,CAAC;AAAA,MAC3D;AAAA,IACF;AAAA,EACF;AAEA,QAAM,aAAa,CAAC,cAA8B;AAChD,sBAAkB,KAAK,EAAE,UAAU,CAAC;AACpC,WAAO,kBAAkB,SAAS;AAAA,EACpC;AAEA,QAAM,qBAAqB,CAAC,cAAsB,YAAsC;AACtF,oBAAgB;AAChB,QAAI,CAAC,SAAS,IAAI,YAAY,GAAG;AAC/B,eAAS,IAAI,cAAc,CAAC,CAAC;AAAA,IAC/B;AACA,aAAS,IAAI,YAAY,GAAG,KAAK,OAAO;AAAA,EAC1C;AAEA,aAAW,WAAW,QAAQ;AAC5B,YAAQ,QAAQ,MAAM;AAAA,MACpB,KAAK;AACH,uBAAe,QAAQ;AACvB,YAAI,OAAO,QAAQ,YAAY,YAAY,QAAQ,QAAQ,KAAK,EAAE,SAAS,GAAG;AAC5E,qBAAW,QAAQ,OAAO;AAAA,QAC5B,OAAO;AACL,qBAAW,EAAE;AAAA,QACf;AACA;AAAA,MAEF,KAAK;AACH,YAAI,OAAO,QAAQ,YAAY,UAAU;AACvC,mBAAS,KAAK,QAAQ,OAAO;AAC7B,qBAAW,OAAO,SAAS,IAAI,UAAU,QAAQ,OAAO,KAAK,QAAQ,OAAO;AAAA,QAC9E,OAAO;AAEL,gBAAM,YAAY,QAAQ,QACvB,OAAO,CAAC,SAAS,KAAK,SAAS,MAAM,EACrC,IAAI,CAAC,SAAS,KAAK,IAAI,EACvB,KAAK,IAAI;AAEZ,gBAAM,eAAe,WAAW,YAAY,UAAU,SAAS,KAAK,EAAE;AAEtE,cAAI,WAAW;AACb,qBAAS,KAAK,SAAS;AAAA,UACzB;AAEA,qBAAW,QAAQ,QAAQ,SAAS;AAClC,gBAAI,KAAK,SAAS,SAAS;AACzB,oBAAM,EAAE,SAAS,QAAQ,IAAI,eAAe,IAAI;AAChD,kBAAI,SAAS;AACX,mCAAmB,cAAc,OAAO;AAAA,cAC1C,WAAW,SAAS;AAClB,yBAAS,KAAK,OAAO;AAAA,cACvB;AAAA,YACF,WAAW,KAAK,SAAS,QAAQ;AAC/B,oBAAM,EAAE,SAAS,QAAQ,IAAI,cAAc,IAAI;AAC/C,kBAAI,SAAS;AACX,mCAAmB,cAAc,OAAO;AAAA,cAC1C,WAAW,SAAS;AAClB,yBAAS,KAAK,OAAO;AAAA,cACvB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA;AAAA,MAEF,KAAK,aAAa;AAChB,YAAI,mBAAmB;AACvB,YAAI,OAAO,QAAQ,YAAY,UAAU;AACvC,6BAAmB,QAAQ;AAAA,QAC7B,OAAO;AACL,gBAAM,YAAY,QAAQ,QACvB,OAAO,CAAC,SAAS,KAAK,SAAS,MAAM,EACrC,IAAI,CAAC,SAAS,KAAK,IAAI,EACvB,KAAK,IAAI;AAEZ,cAAI,WAAW;AACb,+BAAmB;AAAA,UACrB;AAGA,gBAAM,YAAY,QAAQ,QAAQ,OAAO,CAAC,SAAS,KAAK,SAAS,WAAW;AAC5E,cAAI,UAAU,SAAS,GAAG;AAExB,gCAAoB;AAAA;AAAA,UACtB;AAAA,QACF;AACA,cAAM,qBAAqB,cAAc,gBAAgB;AACzD,iBAAS,KAAK,kBAAkB;AAChC,mBAAW,kBAAkB;AAC7B;AAAA,MACF;AAAA,MAEA,KAAK;AAEH,mBAAWC,SAAQ,QAAQ,SAAS;AAClC,gBAAM,aACJA,MAAK,OAAO,SAAS,SAASA,MAAK,OAAO,QAAQ,KAAK,UAAUA,MAAK,OAAO,KAAK;AACpF,gBAAM,sBAAsB,gBAAgBA,MAAK,QAAQ,MAAM,UAAU;AACzE,mBAAS,KAAK,mBAAmB;AACjC,qBAAW,mBAAmB;AAAA,QAChC;AACA;AAAA,IACJ;AAAA,EACF;AAMA,MAAI,cAAc;AAGlB,MAAI,cAAc;AAChB,kBAAc;AAAA,EAChB;AAEA,MAAI,SAAS,SAAS,GAAG;AAEvB,UAAM,oBAAoB,CAAC;AAC3B,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAM,MAAM,SAAS,CAAC;AAEtB,UAAI,IAAI,WAAW,YAAY,KAAK,IAAI,WAAW,aAAa,GAAG;AACjE,0BAAkB,KAAK,GAAG;AAAA,MAC5B,OAAO;AAEL,0BAAkB,KAAK,UAAU,GAAG,EAAE;AAAA,MACxC;AAAA,IACF;AAGA,QAAI,aAAa;AACf,YAAM,iBAAiB,kBAAkB,KAAK,MAAM;AACpD,oBAAc,iBAAiB,GAAG,WAAW;AAAA;AAAA,EAAO,cAAc,KAAK;AAAA,IACzE,OAAO;AACL,oBAAc,kBAAkB,KAAK,MAAM;AAAA,IAC7C;AAAA,EACF;AAGA,QAAM,iBAAuC,CAAC;AAC9C,QAAM,oBAA0C,CAAC;AAEjD,QAAM,uBAAuB,CAAC,UAAkB;AAC9C,UAAM,SAAS,SAAS,IAAI,KAAK;AACjC,QAAI,CAAC,QAAQ;AACX;AAAA,IACF;AACA,WAAO,QAAQ,CAAC,UAAU;AACxB,qBAAe,KAAK,KAAK;AACzB,wBAAkB,KAAK,KAAK;AAAA,IAC9B,CAAC;AAAA,EACH;AAEA,MAAI,kBAAkB,SAAS,GAAG;AAChC,QAAI,kBAAkB;AACtB,QAAI,cAAc;AAElB,UAAM,YAAY,MAAM;AACtB,UAAI,CAAC,iBAAiB;AACpB;AAAA,MACF;AACA,qBAAe,KAAK,EAAE,MAAM,QAAQ,MAAM,gBAAgB,CAAC;AAC3D,wBAAkB;AAClB,oBAAc;AAAA,IAChB;AAEA,sBAAkB,QAAQ,CAAC,SAAS,UAAU;AAC5C,YAAM,cAAc,QAAQ;AAC5B,UAAI,aAAa;AACf,YAAI,CAAC,iBAAiB;AACpB,4BAAkB,cAAc;AAAA;AAAA,EAAO,WAAW,KAAK;AAAA,QACzD,OAAO;AACL,6BAAmB;AAAA;AAAA,EAAO,WAAW;AAAA,QACvC;AAAA,MACF;AAEA,UAAI,SAAS,IAAI,KAAK,GAAG;AACvB,kBAAU;AACV,6BAAqB,KAAK;AAAA,MAC5B;AAAA,IACF,CAAC;AAED,cAAU;AAAA,EACZ;AAKA,SAAO;AAAA,IACL,gBAAgB;AAAA,IAChB;AAAA,IACA,GAAI,SAAS,SAAS,KAAK,EAAE,SAAS;AAAA,IACtC,uBACE,eAAe,SAAS,IACnB,iBACA;AAAA,MACC,EAAE,MAAM,QAAQ,MAAM,YAAY;AAAA,MAClC,GAAG;AAAA,IACL;AAAA,IACN;AAAA,EACF;AACF;;;AChaA,SAAS,cAAc,uBAAuB;AAsDvC,SAAS,mBAAmB;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,cAAc;AAChB,GAGiB;AACf,QAAM,WAAoC;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO,IAAI,aAAa;AAAA,IACtB;AAAA,IACA;AAAA,IACA,KAAK;AAAA,IACL,mBAAmB,gBAAgB,EAAE,QAAQ,cAAc,IAAI;AAAA,IAC/D,MAAM;AAAA,EACR,CAAC;AACH;AAgBO,SAAS,0BAA0B,EAAE,QAAQ,GAAyC;AAC3F,SAAO,IAAI,gBAAgB;AAAA,IACzB,SACE,WAAW;AAAA,EACf,CAAC;AACH;AAmBO,SAAS,mBAAmB;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AACF,GAIiB;AAEf,QAAM,WAAoC;AAAA,IACxC,MAAM;AAAA,IACN;AAAA,EACF;AAEA,SAAO,IAAI,aAAa;AAAA,IACtB;AAAA,IACA,aAAa;AAAA,IACb,KAAK;AAAA,IACL,mBAAmB,gBAAgB,EAAE,QAAQ,cAAc,IAAI;AAAA,IAC/D,MAAM,cAAc,SAAY,EAAE,GAAG,UAAU,UAAU,IAAI;AAAA,EAC/D,CAAC;AACH;AAoBO,SAAS,sBAAsB,OAAyB;AAC7D,MAAI,iBAAiB,gBAAiB,QAAO;AAC7C,MAAI,iBAAiB,gBAAiB,MAAM,MAAkC,aAAa;AACzF,WAAO;AACT,SAAO;AACT;AAoBO,SAAS,eAAe,OAAyB;AACtD,MAAI,iBAAiB,gBAAiB,MAAM,MAAkC,SAAS;AACrF,WAAO;AACT,SAAO;AACT;AAoBO,SAAS,iBAAiB,OAAqD;AACpF,MAAI,iBAAiB,gBAAgB,MAAM,MAAM;AAC/C,WAAO,MAAM;AAAA,EACf;AACA,SAAO;AACT;;;AClMO,SAAS,0BAA0B,SAA+C;AACvF,UAAQ,SAAS;AAAA,IACf,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;;;AChCA,SAAS,SAAS;AAClB,SAAS,kBAAkB;AAS3B,IAAM,uBAAuB,EAAE,OAAO;AAAA,EACpC,OAAO,EAAE,IAAI,EAAE,OAAO,CAAC,QAAQ,OAAO,QAAQ,YAAY;AAAA,IACxD,SAAS;AAAA,EACX,CAAC;AAAA,EACD,MAAM,EAAE,IAAI,EAAE,OAAO,CAAC,QAAQ,OAAO,QAAQ,YAAY;AAAA,IACvD,SAAS;AAAA,EACX,CAAC;AAAA,EACD,MAAM,EAAE,IAAI,EAAE,OAAO,CAAC,QAAQ,OAAO,QAAQ,YAAY;AAAA,IACvD,SAAS;AAAA,EACX,CAAC;AAAA,EACD,OAAO,EAAE,IAAI,EAAE,OAAO,CAAC,QAAQ,OAAO,QAAQ,YAAY;AAAA,IACxD,SAAS;AAAA,EACX,CAAC;AACH,CAAC;AAMM,IAAM,2BAA2B,EACrC,OAAO;AAAA,EACN,4BAA4B,EAAE,OAAO,EAAE,SAAS;AAAA,EAChD,oBAAoB,EAAE,OAAO,EAAE,SAAS;AAAA,EACxC,oBAAoB,EAAE,OAAO,EAAE,SAAS;AAAA,EACxC,cAAc,EACX,MAAM;AAAA,IACL,EAAE,OAAO;AAAA,IACT,EAAE,OAAO;AAAA,MACP,MAAM,EAAE,QAAQ,QAAQ;AAAA,MACxB,QAAQ,EAAE,QAAQ,aAAa;AAAA,MAC/B,QAAQ,EAAE,OAAO,EAAE,SAAS;AAAA,IAC9B,CAAC;AAAA,EACH,CAAC,EACA,SAAS;AAAA,EACZ,UAAU,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,IAAI,GAAG,EAAE,SAAS;AAAA,EACpD,mBAAmB,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,GAAM,EAAE,SAAS;AAAA,EACpE,KAAK,EACF,OAAO,EACP;AAAA,IACC,CAAC,QAAQ;AAEP,UAAI,OAAO,YAAY,eAAe,CAAC,QAAQ,UAAU,MAAM;AAC7D,eAAO;AAAA,MACT;AACA,aAAO,CAAC,OAAO,WAAW,GAAG;AAAA,IAC/B;AAAA,IACA,EAAE,SAAS,+BAA+B;AAAA,EAC5C,EACC,SAAS;AAAA,EACZ,YAAY,EAAE,KAAK,CAAC,OAAO,QAAQ,MAAM,CAAC,EAAE,SAAS;AAAA,EACrD,gBAAgB,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC7C,gBAAgB,EAAE,KAAK,CAAC,WAAW,eAAe,qBAAqB,MAAM,CAAC,EAAE,SAAS;AAAA,EACzF,0BAA0B,EAAE,OAAO,EAAE,SAAS;AAAA,EAC9C,UAAU,EAAE,QAAQ,EAAE,SAAS;AAAA,EAC/B,QAAQ,EAAE,OAAO,EAAE,SAAS;AAAA,EAC5B,cAAc,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC3C,iBAAiB,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC9C,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACpC,iCAAiC,EAAE,QAAQ,EAAE,SAAS;AAAA,EACtD,yBAAyB,EAAE,QAAQ,EAAE,SAAS;AAAA,EAC9C,cAAc,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS;AAAA,EACzC,SAAS,EACN;AAAA,IACC,EACG,OAAO;AAAA,MACN,MAAM,EAAE,OAAO;AAAA,MACf,MAAM,EAAE,OAAO;AAAA,IACjB,CAAC,EACA,YAAY;AAAA,EACjB,EACC,SAAS;AAAA,EACZ,iBAAiB,EAAE,OAAO,EAAE,SAAS;AAAA,EACrC,SAAS,EACN,IAAI,EACJ,OAAO,CAAC,QAAQ,QAAQ,UAAa,OAAO,QAAQ,UAAU;AAAA,IAC7D,SAAS;AAAA,EACX,CAAC,EACA,SAAS;AAAA,EACZ,OAAO,EACJ,MAAM;AAAA,IACL,EAAE,MAAM,EAAE,OAAO,CAAC;AAAA,IAClB,EAAE,OAAO;AAAA,MACP,MAAM,EAAE,QAAQ,QAAQ;AAAA,MACxB,QAAQ,EAAE,QAAQ,aAAa;AAAA,IACjC,CAAC;AAAA,EACH,CAAC,EACA,SAAS;AAAA,EACZ,gBAAgB,EAAE,MAAM,EAAE,KAAK,CAAC,QAAQ,WAAW,OAAO,CAAC,CAAC,EAAE,SAAS;AAAA,EACvE,gBAAgB,EAAE,KAAK,CAAC,QAAQ,UAAU,KAAK,CAAC,EAAE,SAAS;AAAA;AAAA,EAE3D,YAAY,EACT,IAAI,EACJ,OAAO,CAAC,MAAM,MAAM,UAAa,OAAO,MAAM,YAAY;AAAA,IACzD,SAAS;AAAA,EACX,CAAC,EACA,SAAS;AAAA,EACZ,OAAO,EACJ;AAAA,IACC,EAAE,OAAO;AAAA,IACT,EAAE;AAAA,MACA,EAAE,OAAO;AAAA,QACP,SAAS,EAAE,OAAO,EAAE,SAAS;AAAA,QAC7B,OAAO,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,SAAS;AAAA,MACnC,CAAC;AAAA,IACH;AAAA,EACF,EACC,SAAS;AAAA,EACZ,YAAY,EACT;AAAA,IACC,EAAE,OAAO;AAAA,IACT,EAAE,OAAO;AAAA,MACP,aAAa,EAAE,OAAO,EAAE,SAAS;AAAA,MACjC,aAAa,EAAE,IAAI,EAAE,SAAS;AAAA,MAC9B,YAAY,EAAE,IAAI,EAAE,SAAS;AAAA,MAC7B,SAAS,EAAE,SAAS,EAAE,SAAS;AAAA,IACjC,CAAC;AAAA,EACH,EACC,SAAS;AAAA,EACZ,YAAY,EACT;AAAA,IACC,EAAE,OAAO;AAAA,IACT,EAAE,MAAM;AAAA;AAAA,MAEN,EAAE,OAAO;AAAA,QACP,MAAM,EAAE,QAAQ,OAAO,EAAE,SAAS;AAAA,QAClC,SAAS,EAAE,OAAO;AAAA,QAClB,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,QACnC,KAAK,EAAE,OAAO,EAAE,OAAO,GAAG,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,MACjD,CAAC;AAAA;AAAA,MAED,EAAE,OAAO;AAAA,QACP,MAAM,EAAE,QAAQ,KAAK;AAAA,QACrB,KAAK,EAAE,OAAO;AAAA,QACd,SAAS,EAAE,OAAO,EAAE,OAAO,GAAG,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,MACrD,CAAC;AAAA;AAAA,MAED,EAAE,OAAO;AAAA,QACP,MAAM,EAAE,QAAQ,MAAM;AAAA,QACtB,KAAK,EAAE,OAAO;AAAA,QACd,SAAS,EAAE,OAAO,EAAE,OAAO,GAAG,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,MACrD,CAAC;AAAA;AAAA,MAED,EAAE,OAAO;AAAA,QACP,MAAM,EAAE,QAAQ,KAAK;AAAA,QACrB,MAAM,EAAE,OAAO;AAAA,QACf,UAAU,EAAE,IAAI;AAAA,MAClB,CAAC;AAAA,IACH,CAAC;AAAA,EACH,EACC,SAAS;AAAA,EACZ,SAAS,EAAE,QAAQ,EAAE,SAAS;AAAA,EAC9B,QAAQ,EAAE,MAAM,CAAC,EAAE,QAAQ,KAAK,GAAG,oBAAoB,CAAC,EAAE,SAAS;AAAA,EACnE,KAAK,EAAE,OAAO,EAAE,OAAO,GAAG,EAAE,OAAO,EAAE,SAAS,CAAC,EAAE,SAAS;AAAA,EAC1D,uBAAuB,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACpD,QAAQ,EACL;AAAA,IACC,EAAE,OAAO;AAAA,IACT,EAAE,OAAO;AAAA,MACP,aAAa,EAAE,OAAO;AAAA,MACtB,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,MACpC,QAAQ,EAAE,OAAO;AAAA,MACjB,OAAO,EAAE,KAAK,CAAC,UAAU,QAAQ,SAAS,SAAS,CAAC,EAAE,SAAS;AAAA,IACjE,CAAC;AAAA,EACH,EACC,SAAS;AAAA,EACZ,wBAAwB,EAAE,QAAQ,EAAE,SAAS;AAAA,EAC7C,eAAe,EAAE,OAAO,EAAE,SAAS;AAAA,EACnC,aAAa,EAAE,QAAQ,EAAE,SAAS;AAAA,EAClC,QAAQ,EACL,IAAI,EACJ,OAAO,CAAC,QAAQ,QAAQ,UAAa,OAAO,QAAQ,YAAY;AAAA,IAC/D,SAAS;AAAA,EACX,CAAC,EACA,SAAS;AAAA,EACZ,iBAAiB,EAAE,QAAQ,EAAE,SAAS;AAAA,EACtC,WAAW,EAAE,OAAO,EAAE,OAAO,GAAG,EAAE,MAAM,CAAC,EAAE,OAAO,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,SAAS;AAAA,EAC1E,YAAY,EAAE,OAAO,EAAE,OAAO,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS;AACrD,CAAC,EACA,OAAO;AAQH,SAAS,gBAAgB,SAAqC;AACnE,QAAM,cAAc,CAAC,QAAQ,UAAU,OAAO;AAG9C,MAAI,CAAC,WAAW,QAAQ,KAAK,MAAM,IAAI;AACrC,UAAM,IAAI,MAAM,0BAA0B;AAAA,EAC5C;AAGA,MAAI,CAAC,YAAY,SAAS,OAAO,GAAG;AAClC,WAAO,sBAAsB,OAAO,sDAAsD,YAAY,KAAK,IAAI,CAAC;AAAA,EAClH;AAEA,SAAO;AACT;AAQO,SAAS,iBAAiB,UAI/B;AACA,QAAM,WAAqB,CAAC;AAC5B,QAAM,SAAmB,CAAC;AAE1B,MAAI;AAEF,UAAM,SAAS,yBAAyB,UAAU,QAAQ;AAE1D,QAAI,CAAC,OAAO,SAAS;AAGnB,YAAM,cAAc,OAAO;AAI3B,YAAM,SAAS,YAAY,UAAU,YAAY,UAAU,CAAC;AAC5D,aAAO,QAAQ,CAAC,QAA6C;AAC3D,cAAM,OAAO,IAAI,KAAK,KAAK,GAAG;AAC9B,eAAO,KAAK,GAAG,OAAO,GAAG,IAAI,OAAO,EAAE,GAAG,IAAI,OAAO,EAAE;AAAA,MACxD,CAAC;AACD,aAAO,EAAE,OAAO,OAAO,UAAU,OAAO;AAAA,IAC1C;AAGA,UAAM,gBAAgB,OAAO;AAG7B,QAAI,cAAc,YAAY,cAAc,WAAW,IAAI;AACzD,eAAS;AAAA,QACP,wBAAwB,cAAc,QAAQ;AAAA,MAChD;AAAA,IACF;AAGA,QAAI,cAAc,qBAAqB,cAAc,oBAAoB,KAAO;AAC9E,eAAS;AAAA,QACP,gCAAgC,cAAc,iBAAiB;AAAA,MACjE;AAAA,IACF;AAGA,QAAI,cAAc,gBAAgB,cAAc,iBAAiB;AAC/D,eAAS;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAGA,UAAM,oBAAoB,CAAC,OAAiB,SAAiB;AAC3D,YAAM,QAAQ,CAACC,UAAS;AAEtB,YAAI,CAAC,uCAAuC,KAAKA,KAAI,KAAK,CAACA,MAAK,WAAW,OAAO,GAAG;AACnF,mBAAS,KAAK,WAAW,IAAI,uBAAuBA,KAAI,GAAG;AAAA,QAC7D;AAAA,MACF,CAAC;AAAA,IACH;AAEA,QAAI,cAAc,cAAc;AAC9B,wBAAkB,cAAc,cAAc,SAAS;AAAA,IACzD;AAEA,QAAI,cAAc,iBAAiB;AACjC,wBAAkB,cAAc,iBAAiB,YAAY;AAAA,IAC/D;AAEA,WAAO,EAAE,OAAO,MAAM,UAAU,OAAO;AAAA,EACzC,SAAS,OAAO;AACd,WAAO,KAAK,qBAAqB,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AACzF,WAAO,EAAE,OAAO,OAAO,UAAU,OAAO;AAAA,EAC1C;AACF;AAQO,SAAS,eAAe,QAAoC;AAEjE,QAAM,oBAAoB;AAE1B,MAAI,OAAO,SAAS,mBAAmB;AACrC,WAAO,qBAAqB,OAAO,MAAM;AAAA,EAC3C;AAEA,SAAO;AACT;AAQO,SAAS,kBAAkB,WAAuC;AAGvE,MAAI,aAAa,CAAC,mBAAmB,KAAK,SAAS,GAAG;AACpD,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AChUA,IAAM,gBAAwB;AAAA;AAAA,EAE5B,OAAO,CAAC,YAAoB,QAAQ,MAAM,WAAW,OAAO,EAAE;AAAA;AAAA,EAE9D,MAAM,CAAC,YAAoB,QAAQ,KAAK,UAAU,OAAO,EAAE;AAAA,EAC3D,MAAM,CAAC,YAAoB,QAAQ,KAAK,UAAU,OAAO,EAAE;AAAA,EAC3D,OAAO,CAAC,YAAoB,QAAQ,MAAM,WAAW,OAAO,EAAE;AAChE;AAKA,IAAM,aAAqB;AAAA,EACzB,OAAO,MAAM;AAAA,EAAC;AAAA,EACd,MAAM,MAAM;AAAA,EAAC;AAAA,EACb,MAAM,MAAM;AAAA,EAAC;AAAA,EACb,OAAO,MAAM;AAAA,EAAC;AAChB;AAQO,SAAS,UAAU,QAA4C;AACpE,MAAI,WAAW,OAAO;AACpB,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,QAAW;AACxB,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAUO,SAAS,oBAAoB,QAAgB,UAAmB,OAAe;AACpF,MAAI,SAAS;AAEX,WAAO;AAAA,EACT;AAIA,SAAO;AAAA,IACL,OAAO,MAAM;AAAA,IAAC;AAAA;AAAA,IACd,MAAM,MAAM;AAAA,IAAC;AAAA;AAAA,IACb,MAAM,OAAO,KAAK,KAAK,MAAM;AAAA,IAC7B,OAAO,OAAO,MAAM,KAAK,MAAM;AAAA,EACjC;AACF;;;AL7CA;AAAA,EACE;AAAA,EAEA;AAAA,EACA;AAAA,OAEK;AAEP,OAAiC;AAGjC,IAAM,iCACJ;AAEF,IAAM,wBAAwB;AAqB9B,SAAS,4BAA4B,OAAgB,cAA+B;AAElF,QAAM,gBACJ,iBAAiB;AAAA,EAEhB,OAAQ,OAAe,SAAS;AAAA,EAE9B,MAAc,KAAK,YAAY,MAAM;AAE1C,MAAI,CAAC,eAAe;AAClB,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,cAAc;AACjB,WAAO;AAAA,EACT;AAGA,QAAM,aAAa,OAAQ,OAAe,YAAY,WAAY,MAAc,UAAU;AAC1F,QAAM,UAAU,WAAW,YAAY;AAKvC,QAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,CAAC,qBAAqB,KAAK,CAAC,cAAc,QAAQ,SAAS,SAAS,CAAC,GAAG;AAC1E,WAAO;AAAA,EACT;AAKA,MAAI,aAAa,SAAS,uBAAuB;AAC/C,WAAO;AAAA,EACT;AAGA,SAAO;AACT;AAEA,SAAS,aAAa,KAAuB;AAC3C,MAAI,OAAO,OAAO,QAAQ,UAAU;AAClC,UAAM,IAAI;AACV,QAAI,OAAO,EAAE,SAAS,YAAY,EAAE,SAAS,aAAc,QAAO;AAClE,QAAI,OAAO,EAAE,SAAS,YAAY,EAAE,KAAK,YAAY,MAAM,YAAa,QAAO;AAAA,EACjF;AACA,SAAO;AACT;AAEA,IAAM,4BACJ;AAEF,IAAM,wBAAwB,oBAAI,IAAI,CAAC,SAAS,mBAAmB,UAAU,cAAc,CAAC;AAuD5F,SAAS,sBACP,gBACA,mBACA,WACA,cAC+B;AAC/B,QAAM,UACJ,gBAAgB,aAAa,SAAS,IAClC,eACA,CAAC,EAAE,MAAM,QAAQ,MAAM,eAAe,CAAC;AAG7C,QAAM,MAAsB;AAAA,IAC1B,MAAM;AAAA,IACN,SAAS;AAAA,MACP,MAAM;AAAA,MACN;AAAA,IACF;AAAA,IACA,oBAAoB;AAAA,IACpB,YAAY,aAAa;AAAA,EAC3B;AACA,SAAO;AAAA,IACL,QAAQ,OAAO,aAAa,IAAI;AAC9B,YAAM;AACN,YAAM;AAAA,IACR;AAAA,EACF;AACF;AAoDA,IAAM,WAAmC;AAAA,EACvC,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AACT;AA8BO,IAAM,0BAAN,MAAM,yBAAmD;AAAA,EACrD,uBAAuB;AAAA,EACvB,8BAA8B;AAAA,EAC9B,oBAAoB;AAAA,EACpB,gBAAgB,CAAC;AAAA,EACjB,4BAA4B;AAAA;AAAA,EAGrC,OAAgB,oBAAoB;AAAA;AAAA,EAGpC,OAAwB,sBAAsB;AAAA;AAAA,EAC9C,OAAwB,sBAAsB;AAAA;AAAA,EAC9C,OAAwB,sBAAsB;AAAA;AAAA,EAErC;AAAA,EACA;AAAA,EAED;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,SAAyC;AACnD,SAAK,UAAU,QAAQ;AACvB,SAAK,WAAW,QAAQ,YAAY,CAAC;AACrC,SAAK,6BAA6B,QAAQ,8BAA8B,CAAC;AAGzE,UAAM,aAAa,UAAU,KAAK,SAAS,MAAM;AACjD,SAAK,SAAS,oBAAoB,YAAY,KAAK,SAAS,WAAW,KAAK;AAG5E,QAAI,CAAC,KAAK,WAAW,OAAO,KAAK,YAAY,YAAY,KAAK,QAAQ,KAAK,MAAM,IAAI;AACnF,YAAM,IAAI,iBAAiB;AAAA,QACzB,SAAS,KAAK;AAAA,QACd,WAAW;AAAA,MACb,CAAC;AAAA,IACH;AAGA,SAAK,yBAAyB,gBAAgB,KAAK,OAAO;AAC1D,QAAI,KAAK,wBAAwB;AAC/B,WAAK,OAAO,KAAK,sBAAsB,KAAK,sBAAsB,EAAE;AAAA,IACtE;AAAA,EACF;AAAA,EAEA,IAAI,WAAmB;AACrB,WAAO;AAAA,EACT;AAAA,EAEQ,WAAmB;AACzB,UAAM,SAAS,SAAS,KAAK,OAAO;AACpC,WAAO,UAAU,KAAK;AAAA,EACxB;AAAA,EAEQ,yBAAuD;AAC7D,QAAI,CAAC,KAAK,SAAS,cAAc,OAAO,KAAK,SAAS,eAAe,UAAU;AAC7E,aAAO;AAAA,IACT;AAEA,UAAM,YAAY,EAAE,GAAI,KAAK,SAAS,WAAuC;AAC7E,UAAM,cAAc,MAAM,KAAK,qBAAqB,EAAE,OAAO,CAAC,QAAQ,OAAO,SAAS;AAEtF,QAAI,YAAY,SAAS,GAAG;AAC1B,WAAK,OAAO;AAAA,QACV,8DAA8D,YAAY;AAAA,UACxE;AAAA,QACF,CAAC;AAAA,MACH;AACA,kBAAY,QAAQ,CAAC,QAAQ,OAAO,UAAU,GAAG,CAAC;AAAA,IACpD;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,mBAAmB,YAAmD;AAC5E,WAAO,YAAY,UAAU,KAAK,SAAS,UAAU,KAAK;AAAA,EAC5D;AAAA,EAEQ,gBAAgB,SAAmC;AACzD,QAAI,CAAC,MAAM,QAAQ,OAAO,GAAG;AAC3B,aAAO,CAAC;AAAA,IACV;AAEA,WAAO,QACJ;AAAA,MACC,CAAC,SACC,OAAO,SAAS,YAChB,SAAS,QACT,UAAU,QACT,KAA2B,SAAS;AAAA,IACzC,EACC,IAAI,CAAC,SAAS;AACb,YAAM,EAAE,IAAI,MAAM,MAAM,IAAI;AAC5B,aAAO;AAAA,QACL,IAAI,OAAO,OAAO,YAAY,GAAG,SAAS,IAAI,KAAK,WAAW;AAAA,QAC9D,MACE,OAAO,SAAS,YAAY,KAAK,SAAS,IACtC,OACA,yBAAwB;AAAA,QAC9B;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACL;AAAA,EAEQ,mBAAmB,SAAsC;AAC/D,QAAI,CAAC,MAAM,QAAQ,OAAO,GAAG;AAC3B,aAAO,CAAC;AAAA,IACV;AAEA,WAAO,QACJ;AAAA,MACC,CACE,SAQA,OAAO,SAAS,YAChB,SAAS,QACT,UAAU,QACT,KAA2B,SAAS;AAAA,IACzC,EACC,IAAI,CAAC,SAAS;AACb,YAAM,EAAE,aAAa,SAAAC,UAAS,UAAU,KAAK,IAAI;AACjD,aAAO;AAAA,QACL,IACE,OAAO,gBAAgB,YAAY,YAAY,SAAS,IAAI,cAAc,WAAW;AAAA,QACvF,MAAM,OAAO,SAAS,YAAY,KAAK,SAAS,IAAI,OAAO;AAAA,QAC3D,QAAQA;AAAA,QACR,SAAS,QAAQ,QAAQ;AAAA,MAC3B;AAAA,IACF,CAAC;AAAA,EACL;AAAA,EAEQ,kBAAkB,SAIvB;AACD,QAAI,CAAC,MAAM,QAAQ,OAAO,GAAG;AAC3B,aAAO,CAAC;AAAA,IACV;AAEA,WAAO,QACJ;AAAA,MACC,CACE,SAOA,OAAO,SAAS,YAChB,SAAS,QACT,UAAU,QACT,KAA2B,SAAS;AAAA,IACzC,EACC,IAAI,CAAC,SAAS;AACb,YAAM,EAAE,aAAa,OAAO,KAAK,IAAI;AAKrC,aAAO;AAAA,QACL,IACE,OAAO,gBAAgB,YAAY,YAAY,SAAS,IAAI,cAAc,WAAW;AAAA,QACvF,MAAM,OAAO,SAAS,YAAY,KAAK,SAAS,IAAI,OAAO;AAAA,QAC3D;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACL;AAAA,EAEQ,mBAAmB,OAAwB;AACjD,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO,KAAK,eAAe,KAAK;AAAA,IAClC;AAEA,QAAI,UAAU,QAAW;AACvB,aAAO;AAAA,IACT;AAEA,QAAI;AACF,YAAM,aAAa,KAAK,UAAU,KAAK;AACvC,aAAO,KAAK,eAAe,UAAU;AAAA,IACvC,QAAQ;AACN,YAAM,WAAW,OAAO,KAAK;AAC7B,aAAO,KAAK,eAAe,QAAQ;AAAA,IACrC;AAAA,EACF;AAAA,EAEQ,eAAe,KAAqB;AAC1C,UAAM,SAAS,IAAI;AAEnB,QAAI,SAAS,yBAAwB,qBAAqB;AACxD,YAAM,IAAI;AAAA,QACR,sCAAsC,yBAAwB,mBAAmB,eAAe,MAAM;AAAA,MACxG;AAAA,IACF;AAEA,QAAI,SAAS,yBAAwB,qBAAqB;AACxD,WAAK,OAAO;AAAA,QACV,4CAA4C,MAAM;AAAA,MACpD;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,oBAAoB,UAAkB,QAA0B;AACtE,QAAI,SAAS,WAAW,eAAe,KAAK,MAAM,QAAQ,MAAM,KAAK,OAAO,WAAW,KAAK,UAAU,OAAO,CAAC,GAAG;AAC/G,aAAO,KAAK,MAAM,OAAO,CAAC,EAAE,IAAI;AAAA,IAClC;AAEA,QAAI,OAAO,WAAW,UAAU;AAC9B,UAAI;AACF,eAAO,KAAK,MAAM,MAAM;AAAA,MAC1B,QAAQ;AACN,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,oBACN,SAGA,QAC8B;AAC9B,UAAM,WAAyC,CAAC;AAChD,UAAM,oBAA8B,CAAC;AAGrC,QAAI,QAAQ,gBAAgB,OAAW,mBAAkB,KAAK,aAAa;AAC3E,QAAI,QAAQ,SAAS,OAAW,mBAAkB,KAAK,MAAM;AAC7D,QAAI,QAAQ,SAAS,OAAW,mBAAkB,KAAK,MAAM;AAC7D,QAAI,QAAQ,oBAAoB,OAAW,mBAAkB,KAAK,iBAAiB;AACnF,QAAI,QAAQ,qBAAqB,OAAW,mBAAkB,KAAK,kBAAkB;AACrF,QAAI,QAAQ,kBAAkB,UAAa,QAAQ,cAAc,SAAS;AACxE,wBAAkB,KAAK,eAAe;AACxC,QAAI,QAAQ,SAAS,OAAW,mBAAkB,KAAK,MAAM;AAE7D,QAAI,kBAAkB,SAAS,GAAG;AAEhC,iBAAW,SAAS,mBAAmB;AACrC,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS;AAAA,UAST,SAAS,wCAAwC,KAAK;AAAA,QACxD,CAAC;AAAA,MACH;AAAA,IACF;AAGA,QAAI,KAAK,wBAAwB;AAC/B,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA,IACH;AAGA,SAAK,2BAA2B,QAAQ,CAAC,YAAY;AACnD,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AAAA,IACH,CAAC;AAID,QAAI,QAAQ,gBAAgB,SAAS,UAAU,CAAC,QAAQ,eAAe,QAAQ;AAC7E,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS;AAAA,QACT,SACE;AAAA,MACJ,CAAC;AAAA,IACH;AAGA,UAAM,gBAAgB,eAAe,MAAM;AAC3C,QAAI,eAAe;AACjB,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,0BACN,SAC6C;AAC7C,QAAI,CAAC,WAAW,OAAO,KAAK,OAAO,EAAE,WAAW,GAAG;AACjD,aAAO;AAAA,IACT;AAEA,UAAM,WAAW,OAAO,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,MAAM,MAAM,MAAM;AAC/D,YAAM,cAAc,OAAO;AAG3B,YAAM,aACJ,SAAS,eAAe,YAAY,QAAQ,QAAQ,OAAO,YAAY,QAAQ,YAAY,WAAW,YAAY,MAC9G,YAAY,IAAI,QAChB,WAAW,cACT,YAAY,QACZ;AAGR,YAAM,UAAU,OACd,MACA,UACmC;AACnC,aAAK,OAAO;AAAA,UACV,uCAAuC,IAAI,IAAI,KAAK,UAAU,EAAE,MAAM,MAAM,CAAC,CAAC;AAAA,QAChF;AACA,YAAI,CAAC,OAAO,SAAS;AACnB,iBAAO;AAAA,YACL,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,QAAQ,IAAI,2BAA2B,CAAC;AAAA,UAC1E;AAAA,QACF;AAEA,YAAI;AACF,gBAAM,SAAS,MAAM,OAAO,QAAQ,MAAM;AAAA,YACxC,YAAa,MAA8C,QAAQ,sBAAsB,KAAe;AAAA,YACxG,UAAU,CAAC;AAAA;AAAA,UACb,CAAC;AACD,iBAAO;AAAA,YACL,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,KAAK,UAAU,MAAM,EAAE,CAAC;AAAA,UAC1D;AAAA,QACF,SAAS,OAAO;AACd,gBAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAC1E,iBAAO;AAAA,YACL,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,UAAU,YAAY,GAAG,CAAC;AAAA,UAC5D;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,QACL;AAAA,QACA,OAAO,eAAe;AAAA,QACtB;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAGD,UAAM,YAAY,mBAAmB;AAAA,MACnC,MAAM;AAAA,MACN,OAAO;AAAA,IACT,CAAC;AAED,WAAO,EAAE,UAAU,UAAU;AAAA,EAC/B;AAAA,EAEQ,mBACN,iBACA,gBACA,iBACA,YACA,iBACS;AACT,UAAM,qBAAqB;AAAA,MACzB,GAAG,KAAK,SAAS;AAAA,MACjB,GAAG,KAAK,0BAA0B,KAAK,SAAS,UAAU;AAAA,IAC5D;AAEA,UAAM,OAAmD;AAAA,MACvD,OAAO,KAAK,SAAS;AAAA,MACrB;AAAA,MACA,QAAQ,mBAAmB,KAAK,SAAS,UAAU,KAAK;AAAA,MACxD,4BAA4B,KAAK,SAAS;AAAA,MAC1C,UAAU,KAAK,SAAS;AAAA,MACxB,mBAAmB,KAAK,SAAS;AAAA,MACjC,KAAK,KAAK,SAAS;AAAA,MACnB,YAAY,KAAK,SAAS;AAAA,MAC1B,gBAAgB,KAAK,SAAS;AAAA,MAC9B,gBAAgB,KAAK,SAAS;AAAA,MAC9B,0BAA0B,KAAK,SAAS;AAAA,MACxC,UAAU,KAAK,SAAS;AAAA,MACxB,cAAc,KAAK,SAAS;AAAA,MAC5B,iBAAiB,KAAK,SAAS;AAAA,MAC/B,OAAO,KAAK,SAAS;AAAA,MACrB,iCAAiC,KAAK,SAAS;AAAA,MAC/C,yBAAyB,KAAK,SAAS;AAAA,MACvC,cAAc,KAAK,SAAS;AAAA,MAC5B,SAAS,KAAK,SAAS;AAAA,MACvB,iBAAiB,KAAK,SAAS;AAAA,MAC/B,SAAS,KAAK,SAAS;AAAA,MACvB,OAAO,KAAK,SAAS;AAAA,MACrB,YAAY,OAAO,KAAK,kBAAkB,EAAE,SAAS,IAAI,qBAAqB;AAAA,MAC9E,YAAY,KAAK,SAAS;AAAA,IAC5B;AAEA,QAAI,KAAK,SAAS,iBAAiB,QAAW;AAC5C,WAAK,eAAe,KAAK,SAAS;AAAA,IACpC,WAAW,KAAK,SAAS,uBAAuB,QAAW;AAEzD,WAAK,OAAO;AAAA,QACV;AAAA,MACF;AACA,WAAK,eAAe,KAAK,SAAS;AAAA,IACpC,WAAW,KAAK,SAAS,uBAAuB,QAAW;AAEzD,WAAK,OAAO;AAAA,QACV;AAAA,MACF;AACA,WAAK,eAAe;AAAA,QAClB,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,QAAQ,KAAK,SAAS;AAAA,MACxB;AAAA,IACF;AACA,QAAI,KAAK,SAAS,mBAAmB,QAAW;AAC9C,WAAK,iBAAiB,KAAK,SAAS;AAAA,IACtC;AACA,QAAI,KAAK,SAAS,0BAA0B,QAAW;AACrD,WAAK,wBAAwB,KAAK,SAAS;AAAA,IAC7C;AACA,QAAI,KAAK,SAAS,WAAW,QAAW;AACtC,WAAK,SAAS,KAAK,SAAS;AAAA,IAC9B;AACA,QAAI,KAAK,SAAS,2BAA2B,QAAW;AACtD,WAAK,yBAAyB,KAAK,SAAS;AAAA,IAC9C;AACA,QAAI,KAAK,SAAS,kBAAkB,QAAW;AAC7C,WAAK,gBAAgB,KAAK,SAAS;AAAA,IACrC;AACA,QAAI,KAAK,SAAS,gBAAgB,QAAW;AAC3C,WAAK,cAAc,KAAK,SAAS;AAAA,IACnC;AACA,QAAI,KAAK,SAAS,oBAAoB,QAAW;AAC/C,WAAK,kBAAkB,KAAK,SAAS;AAAA,IACvC;AACA,QAAI,KAAK,SAAS,cAAc,QAAW;AACzC,WAAK,YAAY,KAAK,SAAS;AAAA,IACjC;AAEA,QAAI,KAAK,SAAS,OAAO;AACvB,WAAK,QAAQ,KAAK,SAAS;AAAA,IAC7B;AAEA,UAAM,eAAe,aAChB,aACD;AACJ,UAAM,SACJ,gBAAgB,OAAO,aAAa,QAAQ,YAAY,aAAa,QAAQ,OACxE,aAAa,MACd;AACN,UAAM,YACJ,gBAAgB,OAAO,aAAa,WAAW,aAC1C,aAAa,SACd;AACN,QAAI,cAAc;AAChB,YAAM,OAAO,EAAE,GAAG,aAAa;AAC/B,aAAO,KAAK;AACZ,aAAO,KAAK;AACZ,aAAO,OAAO,MAAM,IAAI;AAAA,IAC1B;AAGA,UAAM,qBAAqB,aAAa,KAAK,SAAS;AACtD,QAAI,mBAAmB,oBAAoB;AACzC,WAAK,SAAS,CAAC,SAAiB;AAC9B,YAAI,gBAAiB,iBAAgB,IAAI;AACzC,YAAI,mBAAoB,oBAAmB,IAAI;AAAA,MACjD;AAAA,IACF;AAEA,QAAI,KAAK,SAAS,QAAQ,UAAa,WAAW,QAAW;AAC3D,WAAK,MAAM,EAAE,GAAG,QAAQ,KAAK,GAAG,KAAK,SAAS,KAAK,GAAG,OAAO;AAAA,IAC/D;AAGA,QAAI,gBAAgB,SAAS,UAAU,eAAe,QAAQ;AAC5D,WAAK,eAAe;AAAA,QAClB,MAAM;AAAA,QACN,QAAQ,eAAe;AAAA,MACzB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,sBACN,OACA,gBACA,iBACgC;AAEhC,QAAI,aAAa,KAAK,GAAG;AAEvB,YAAM;AAAA,IACR;AAGA,UAAM,qBAAqB,CAAC,QAA8C;AACxE,aAAO,OAAO,QAAQ,YAAY,QAAQ,QAAQ,aAAa;AAAA,IACjE;AAEA,UAAM,kBAAkB,CACtB,QACiE;AACjE,aAAO,OAAO,QAAQ,YAAY,QAAQ;AAAA,IAC5C;AAGA,UAAM,oBAAoB;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,eACJ,mBAAmB,KAAK,KAAK,MAAM,UAAU,MAAM,QAAQ,YAAY,IAAI;AAE7E,UAAM,WACJ,gBAAgB,KAAK,KAAK,OAAO,MAAM,aAAa,WAAW,MAAM,WAAW;AAElF,UAAM,cACJ,kBAAkB,KAAK,CAAC,YAAY,aAAa,SAAS,OAAO,CAAC,KAAK,aAAa;AAEtF,QAAI,aAAa;AACf,aAAO,0BAA0B;AAAA,QAC/B,SACE,mBAAmB,KAAK,KAAK,MAAM,UAC/B,MAAM,UACN;AAAA,MACR,CAAC;AAAA,IACH;AAGA,UAAM,YAAY,gBAAgB,KAAK,KAAK,OAAO,MAAM,SAAS,WAAW,MAAM,OAAO;AAE1F,QAAI,cAAc,eAAe,aAAa,SAAS,SAAS,GAAG;AACjE,aAAO,mBAAmB;AAAA,QACxB,SAAS,mBAAmB,KAAK,KAAK,MAAM,UAAU,MAAM,UAAU;AAAA,QACtE,eAAe,eAAe,UAAU,GAAG,GAAG;AAAA;AAAA;AAAA,MAGhD,CAAC;AAAA,IACH;AAGA,UAAM,cACJ,cAAc,YACd,cAAc,kBACd,cAAc,eACd,cAAc;AAGhB,UAAM,kBACJ,gBAAgB,KAAK,KAAK,OAAO,MAAM,WAAW,WAAW,MAAM,SAAS;AAC9E,UAAM,SAAS,mBAAmB,mBAAmB;AAErD,WAAO,mBAAmB;AAAA,MACxB,SAAS,mBAAmB,KAAK,KAAK,MAAM,UAAU,MAAM,UAAU;AAAA,MACtE,MAAM,aAAa;AAAA,MACnB;AAAA,MACA;AAAA,MACA,eAAe,eAAe,UAAU,GAAG,GAAG;AAAA,MAC9C;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,aAAa,WAAyB;AAC5C,SAAK,YAAY;AACjB,UAAM,UAAU,kBAAkB,SAAS;AAC3C,QAAI,SAAS;AACX,WAAK,OAAO,KAAK,wBAAwB,OAAO,EAAE;AAAA,IACpD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,kBAAkB,MAAsB;AAC9C,WAAO,KAAK,WAAW,eAAe,IAClC,KAAK,MAAM,gBAAgB,MAAM,IACjC;AAAA,EACN;AAAA,EAEA,MAAM,WACJ,SAC6D;AAC7D,SAAK,OAAO,MAAM,yDAAyD,KAAK,OAAO,EAAE;AACzF,SAAK,OAAO,MAAM,kCAAkC,QAAQ,gBAAgB,QAAQ,MAAM,EAAE;AAE5F,UAAM,aAAa,KAAK,uBAAuB;AAC/C,UAAM,kBAAkB,KAAK,mBAAmB,UAAU;AAC1D,UAAM;AAAA,MACJ;AAAA,MACA,UAAU;AAAA,MACV;AAAA,MACA;AAAA,IACF,IAAI,4BAA4B,QAAQ,QAAQ,eAAe;AAE/D,SAAK,OAAO;AAAA,MACV,2BAA2B,QAAQ,OAAO,MAAM,6BAA6B,aAAa;AAAA,IAC5F;AAEA,UAAM,kBAAkB,IAAI,gBAAgB;AAC5C,QAAI;AACJ,QAAI,QAAQ,aAAa,SAAS;AAEhC,sBAAgB,MAAM,QAAQ,YAAY,MAAM;AAAA,IAClD,WAAW,QAAQ,aAAa;AAC9B,sBAAgB,MAAM,gBAAgB,MAAM,QAAQ,aAAa,MAAM;AACvE,cAAQ,YAAY,iBAAiB,SAAS,eAAe,EAAE,MAAM,KAAK,CAAC;AAAA,IAC7E;AAGA,QAAI,kBAAkB;AACtB,UAAM,kBAAkB,CAAC,SAAiB;AACxC,yBAAmB;AAAA,IACrB;AAEA,UAAM,eAAe,KAAK;AAAA,MACxB;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,QAAI,OAAO;AACX,QAAI;AACJ,QAAI,QAA8B,EAAE,aAAa,GAAG,cAAc,GAAG,aAAa,EAAE;AACpF,QAAI,eAA4C;AAChD,QAAI,eAAe;AACnB,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,UAAM,WAAyC,KAAK;AAAA,MAClD;AAAA,MACA;AAAA,IACF;AAGA,QAAI,iBAAiB;AACnB,sBAAgB,QAAQ,CAAC,YAAY;AACnC,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS;AAAA,QACX,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAEA,UAAM,cAAc,KAAK,SAAS,kBAAkB;AACpD,UAAM,sBAAsB,YAAY,cAAc,KAAK,SAAS;AACpE,UAAM,oCACJ,YAAY,4BAA4B,KAAK,SAAS;AACxD,UAAM,mBACJ,gBAAgB,YAAa,gBAAgB,UAAU,CAAC,CAAC;AAE3D,QAAI,CAAC,oBAAoB,eAAe;AACtC,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAEA,QAAI,OAAO,MAAM;AAAA,IAAC;AAClB,UAAM,oBAAoB,IAAI,QAAQ,CAAC,YAAY;AACjD,aAAO,MAAM,QAAQ,MAAS;AAAA,IAChC,CAAC;AACD,QAAI;AACF,UAAI,uBAAuB,mCAAmC;AAC5D,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAGA,YAAM,YAAY,mBACd;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,IACA;AAEJ,WAAK,OAAO;AAAA,QACV,sDAAsD,gBAAgB,cAAc,mBAAmB,KAAK;AAAA,MAC9G;AAEA,YAAM,WAAW,MAAM;AAAA,QACrB,QAAQ;AAAA,QACR,SAAS;AAAA,MACX,CAAC;AAED,uBAAiB,WAAW,UAAU;AACpC,aAAK,OAAO,MAAM,wCAAwC,QAAQ,IAAI,EAAE;AACxE,YAAI,QAAQ,SAAS,aAAa;AAChC,kBAAQ,QAAQ,QAAQ,QACrB,IAAI,CAAC,MAAwC,EAAE,SAAS,SAAS,EAAE,OAAO,EAAG,EAC7E,KAAK,EAAE;AAAA,QACZ,WAAW,QAAQ,SAAS,UAAU;AACpC,eAAK;AACL,eAAK,aAAa,QAAQ,UAAU;AACpC,oBAAU,QAAQ;AAClB,uBAAa,QAAQ;AAIrB,cAAK,QAAQ,YAAuB,uCAAuC;AACzE,kBAAM,IAAI;AAAA,cACR;AAAA,YACF;AAAA,UACF;AAGA,cAAI,uBAAuB,WAAW,QAAQ,sBAAsB,QAAW;AAC7E,+BAAmB,QAAQ;AAC3B,iBAAK,OAAO,MAAM,mDAAmD;AAAA,UACvE;AAEA,eAAK,OAAO;AAAA,YACV,8CAA8C,QAAQ,UAAU,YAAY,SAAS,QAAQ,CAAC,KAAK,KAAK,eAAe,cAAc,KAAK;AAAA,UAC5I;AAEA,cAAI,WAAW,SAAS;AACtB,uBAAW,QAAQ;AACnB,oBAAQ;AAAA,cACN,cACG,QAAQ,MAAM,+BAA+B,MAC7C,QAAQ,MAAM,2BAA2B,MACzC,QAAQ,MAAM,gBAAgB;AAAA,cACjC,cAAc,QAAQ,MAAM,iBAAiB;AAAA,cAC7C,cACG,QAAQ,MAAM,+BAA+B,MAC7C,QAAQ,MAAM,2BAA2B,MACzC,QAAQ,MAAM,gBAAgB,MAC9B,QAAQ,MAAM,iBAAiB;AAAA,YACpC;AAEA,iBAAK,OAAO;AAAA,cACV,sCAAsC,MAAM,WAAW,aAAa,MAAM,YAAY,YAAY,MAAM,WAAW;AAAA,YACrH;AAAA,UACF;AAEA,yBAAe,0BAA0B,QAAQ,OAAO;AACxD,eAAK,OAAO,MAAM,gCAAgC,YAAY,EAAE;AAAA,QAClE,WAAW,QAAQ,SAAS,YAAY,QAAQ,YAAY,QAAQ;AAClE,eAAK,aAAa,QAAQ,UAAU;AACpC,eAAK,OAAO,KAAK,sCAAsC,QAAQ,UAAU,EAAE;AAAA,QAC7E;AAAA,MACF;AAAA,IACF,SAAS,OAAgB;AACvB,WAAK;AACL,WAAK,OAAO;AAAA,QACV,0CAA0C,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,MAClG;AAGA,UAAI,aAAa,KAAK,GAAG;AACvB,aAAK,OAAO,MAAM,uCAAuC;AACzD,cAAM,QAAQ,aAAa,UAAU,QAAQ,YAAY,SAAS;AAAA,MACpE;AAEA,UAAI,4BAA4B,OAAO,IAAI,GAAG;AAC5C,aAAK,OAAO;AAAA,UACV,wDAAwD,KAAK,MAAM;AAAA,QACrE;AACA,uBAAe;AACf,uBAAe;AACf,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS;AAAA,QACX,CAAC;AAAA,MACH,OAAO;AAEL,cAAM,KAAK,sBAAsB,OAAO,gBAAgB,eAAe;AAAA,MACzE;AAAA,IACF,UAAE;AACA,UAAI,QAAQ,eAAe,eAAe;AACxC,gBAAQ,YAAY,oBAAoB,SAAS,aAAa;AAAA,MAChE;AAAA,IACF;AAIA,UAAM,YAAY,qBAAqB,SAAY,KAAK,UAAU,gBAAgB,IAAI;AAEtF,WAAO;AAAA,MACL,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,UAAU,CAAC;AAAA,MAC3C;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU;AAAA,QACR,IAAI,WAAW;AAAA,QACf,WAAW,oBAAI,KAAK;AAAA,QACpB,SAAS,KAAK;AAAA,MAChB;AAAA,MACA,SAAS;AAAA,QACP,MAAM;AAAA,MACR;AAAA,MACA,kBAAkB;AAAA,QAChB,eAAe;AAAA,UACb,GAAI,KAAK,cAAc,UAAa,EAAE,WAAW,KAAK,UAAU;AAAA,UAChE,GAAI,YAAY,UAAa,EAAE,QAAQ;AAAA,UACvC,GAAI,eAAe,UAAa,EAAE,WAAW;AAAA,UAC7C,GAAI,aAAa,UAAa,EAAE,SAAgC;AAAA,UAChE,GAAI,gBAAgB,EAAE,WAAW,KAAK;AAAA,QACxC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,SACJ,SAC2D;AAC3D,SAAK,OAAO,MAAM,uDAAuD,KAAK,OAAO,EAAE;AACvF,SAAK,OAAO,MAAM,kCAAkC,QAAQ,gBAAgB,QAAQ,MAAM,EAAE;AAE5F,UAAM,aAAa,KAAK,uBAAuB;AAC/C,UAAM,kBAAkB,KAAK,mBAAmB,UAAU;AAC1D,SAAK,OAAO,MAAM,yBAAyB,KAAK,UAAU,QAAQ,MAAM,CAAC,EAAE;AAC3E,UAAM;AAAA,MACJ;AAAA,MACA,UAAU;AAAA,MACV;AAAA,MACA;AAAA,IACF,IAAI,4BAA4B,QAAQ,QAAQ,eAAe;AAE/D,SAAK,OAAO;AAAA,MACV,2BAA2B,QAAQ,OAAO,MAAM,2CAA2C,aAAa;AAAA,IAC1G;AAEA,UAAM,kBAAkB,IAAI,gBAAgB;AAC5C,QAAI;AACJ,QAAI,QAAQ,aAAa,SAAS;AAEhC,sBAAgB,MAAM,QAAQ,YAAY,MAAM;AAAA,IAClD,WAAW,QAAQ,aAAa;AAC9B,sBAAgB,MAAM,gBAAgB,MAAM,QAAQ,aAAa,MAAM;AACvE,cAAQ,YAAY,iBAAiB,SAAS,eAAe,EAAE,MAAM,KAAK,CAAC;AAAA,IAC7E;AAGA,QAAI,kBAAkB;AACtB,UAAM,kBAAkB,CAAC,SAAiB;AACxC,yBAAmB;AAAA,IACrB;AAEA,UAAM,eAAe,KAAK;AAAA,MACxB;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAIA,QAAI,aAAa,2BAA2B,QAAW;AACrD,mBAAa,yBAAyB;AAAA,IACxC;AAEA,UAAM,WAAyC,KAAK;AAAA,MAClD;AAAA,MACA;AAAA,IACF;AAGA,QAAI,iBAAiB;AACnB,sBAAgB,QAAQ,CAAC,YAAY;AACnC,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS;AAAA,QACX,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAEA,UAAM,cAAc,KAAK,SAAS,kBAAkB;AACpD,UAAM,sBAAsB,YAAY,cAAc,KAAK,SAAS;AACpE,UAAM,oCACJ,YAAY,4BAA4B,KAAK,SAAS;AACxD,UAAM,mBACJ,gBAAgB,YAAa,gBAAgB,UAAU,CAAC,CAAC;AAE3D,QAAI,CAAC,oBAAoB,eAAe;AACtC,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAEA,UAAM,SAAS,IAAI,eAAmC;AAAA,MACpD,OAAO,OAAO,eAAe;AAC3B,YAAI,OAAO,MAAM;AAAA,QAAC;AAClB,cAAM,oBAAoB,IAAI,QAAQ,CAAC,YAAY;AACjD,iBAAO,MAAM,QAAQ,MAAS;AAAA,QAChC,CAAC;AACD,cAAM,aAAa,oBAAI,IAA6B;AACpD,cAAM,iBAA+C,CAAC;AAEtD,cAAM,iBAAiB,CAAC,QAAgB,UAA2B;AACjE,cAAI,CAAC,MAAM,eAAe,MAAM,cAAc;AAC5C,uBAAW,QAAQ;AAAA,cACjB,MAAM;AAAA,cACN,IAAI;AAAA,YACN,CAAC;AACD,kBAAM,cAAc;AAAA,UACtB;AAAA,QACF;AAEA,cAAM,eAAe,CAAC,QAAgB,UAA2B;AAC/D,cAAI,MAAM,aAAa;AACrB;AAAA,UACF;AAEA,yBAAe,QAAQ,KAAK;AAE5B,gBAAM,WAAW,KAAK,kBAAkB,MAAM,IAAI;AAElD,qBAAW,QAAQ;AAAA,YACjB,MAAM;AAAA,YACN,YAAY;AAAA,YACZ;AAAA,YACA,OAAO,MAAM,uBAAuB;AAAA,YACpC,kBAAkB;AAAA,YAClB,SAAS;AAAA;AAAA,YACT,kBAAkB;AAAA,cAChB,eAAe;AAAA;AAAA;AAAA;AAAA,gBAIb,UAAU,MAAM,uBAAuB;AAAA,cACzC;AAAA,YACF;AAAA,UACF,CAAQ;AACR,gBAAM,cAAc;AAAA,QACtB;AAEA,cAAM,oBAAoB,MAAM;AAC9B,qBAAW,CAAC,QAAQ,KAAK,KAAK,YAAY;AACxC,yBAAa,QAAQ,KAAK;AAAA,UAC5B;AACA,qBAAW,MAAM;AAAA,QACnB;AAEA,YAAI,QAA8B,EAAE,aAAa,GAAG,cAAc,GAAG,aAAa,EAAE;AACpF,YAAI,sBAA2C;AAC/C,YAAI,kBAAkB;AACtB,YAAI;AACJ,YAAI,qBAAqB;AACzB,YAAI,0BAA0B;AAE9B,YAAI;AAEF,qBAAW,QAAQ,EAAE,MAAM,gBAAgB,SAAS,CAAC;AAErD,cAAI,uBAAuB,mCAAmC;AAC5D,kBAAM,IAAI;AAAA,cACR;AAAA,YACF;AAAA,UACF;AAGA,gBAAM,YAAY,mBACd;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,IACA;AAEJ,eAAK,OAAO;AAAA,YACV,4DAA4D,gBAAgB,cAAc,mBAAmB,KAAK;AAAA,UACpH;AAEA,gBAAM,WAAW,MAAM;AAAA,YACrB,QAAQ;AAAA,YACR,SAAS;AAAA,UACX,CAAC;AAED,2BAAiB,WAAW,UAAU;AACpC,iBAAK,OAAO,MAAM,+CAA+C,QAAQ,IAAI,EAAE;AAG/E,gBAAI,QAAQ,SAAS,gBAAgB;AACnC,oBAAM,cAAc;AACpB,oBAAM,QAAQ,YAAY;AAC1B,mBAAK,OAAO,MAAM,+BAA+B,MAAM,IAAI,EAAE;AAG7D,kBACE,MAAM,SAAS,yBACf,MAAM,MAAM,SAAS,gBACrB,UAAU,MAAM,SAChB,MAAM,MAAM,MACZ;AACA,sBAAM,YAAY,MAAM,MAAM;AAC9B,0CAA0B;AAG1B,oBAAI,QAAQ,gBAAgB,SAAS,QAAQ;AAC3C,qCAAmB;AACnB,wCAAsB,UAAU;AAChC;AAAA,gBACF;AAGA,oBAAI,CAAC,YAAY;AACf,+BAAa,WAAW;AACxB,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,IAAI;AAAA,kBACN,CAAC;AAAA,gBACH;AAEA,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,kBACJ,OAAO;AAAA,gBACT,CAAC;AACD,mCAAmB;AACnB,sCAAsB,UAAU;AAAA,cAClC;AAGA,kBACE,MAAM,SAAS,yBACf,MAAM,MAAM,SAAS,sBACrB,kBAAkB,MAAM,SACxB,MAAM,MAAM,cACZ;AACA,sBAAM,YAAY,MAAM,MAAM;AAC9B,0CAA0B;AAG1B,oBAAI,QAAQ,gBAAgB,SAAS,QAAQ;AAE3C,sBAAI,CAAC,YAAY;AACf,iCAAa,WAAW;AACxB,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAI;AAAA,oBACN,CAAC;AAAA,kBACH;AAEA,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,IAAI;AAAA,oBACJ,OAAO;AAAA,kBACT,CAAC;AACD,qCAAmB;AACnB,wCAAsB,UAAU;AAAA,gBAClC;AAAA,cAEF;AAIA;AAAA,YACF;AAEA,gBAAI,QAAQ,SAAS,aAAa;AAChC,kBAAI,CAAC,QAAQ,SAAS,SAAS;AAC7B,qBAAK,OAAO;AAAA,kBACV,8FAA8F,QAAQ,IAAI;AAAA,gBAC5G;AACA;AAAA,cACF;AAEA,kBAAI,WAAW,QAAQ,SAAS;AAC9B,qBAAK,OAAO;AAAA,kBACV,0CAA0C,KAAK,UAAU,QAAQ,QAAQ,KAAK,CAAC;AAAA,gBACjF;AACA,sCAAsB,QAAQ,QAAQ;AAAA,cACxC;AAEA,oBAAM,UAAU,QAAQ,QAAQ;AAEhC,yBAAWC,SAAQ,KAAK,gBAAgB,OAAO,GAAG;AAChD,sBAAM,SAASA,MAAK;AACpB,oBAAI,QAAQ,WAAW,IAAI,MAAM;AACjC,oBAAI,CAAC,OAAO;AACV,0BAAQ;AAAA,oBACN,MAAMA,MAAK;AAAA,oBACX,cAAc;AAAA,oBACd,aAAa;AAAA,oBACb,aAAa;AAAA,kBACf;AACA,6BAAW,IAAI,QAAQ,KAAK;AAC5B,uBAAK,OAAO;AAAA,oBACV,+CAA+CA,MAAK,IAAI,SAAS,MAAM;AAAA,kBACzE;AAAA,gBACF;AAEA,sBAAM,OAAOA,MAAK;AAElB,oBAAI,CAAC,MAAM,cAAc;AACvB,uBAAK,OAAO;AAAA,oBACV,4CAA4CA,MAAK,IAAI,SAAS,MAAM;AAAA,kBACtE;AACA,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,IAAI;AAAA,oBACJ,UAAU,KAAK,kBAAkBA,MAAK,IAAI;AAAA,oBAC1C,kBAAkB;AAAA,oBAClB,SAAS;AAAA;AAAA,kBACX,CAAQ;AACR,wBAAM,eAAe;AAAA,gBACvB;AAEA,sBAAM,kBAAkB,KAAK,mBAAmBA,MAAK,KAAK;AAC1D,oBAAI,iBAAiB;AACnB,sBAAI,eAAe;AAGnB,sBAAI,MAAM,wBAAwB,QAAW;AAC3C,wBAAI,gBAAgB,UAAU,yBAAwB,qBAAqB;AACzE,qCAAe;AAAA,oBACjB;AAAA,kBACF,WACE,gBAAgB,UAAU,yBAAwB,uBAClD,MAAM,oBAAoB,UACxB,yBAAwB,uBAC1B,gBAAgB,WAAW,MAAM,mBAAmB,GACpD;AACA,mCAAe,gBAAgB,MAAM,MAAM,oBAAoB,MAAM;AAAA,kBACvE,WAAW,oBAAoB,MAAM,qBAAqB;AAExD,mCAAe;AAAA,kBACjB;AAEA,sBAAI,cAAc;AAChB,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAI;AAAA,sBACJ,OAAO;AAAA,oBACT,CAAC;AAAA,kBACH;AACA,wBAAM,sBAAsB;AAAA,gBAC9B;AAAA,cACF;AAEA,oBAAM,OAAO,QACV,IAAI,CAAC,MAAwC,EAAE,SAAS,SAAS,EAAE,OAAO,EAAG,EAC7E,KAAK,EAAE;AAEV,kBAAI,MAAM;AAIR,oBAAI,yBAAyB;AAE3B,wBAAM,eAAe;AACrB,wBAAM,YAAY,KAAK,SAAS,eAAe,KAAK,MAAM,YAAY,IAAI;AAG1E,oCAAkB;AAIlB,sBAAI,QAAQ,gBAAgB,SAAS,UAAU,WAAW;AAExD,wBAAI,CAAC,YAAY;AACf,mCAAa,WAAW;AACxB,iCAAW,QAAQ;AAAA,wBACjB,MAAM;AAAA,wBACN,IAAI;AAAA,sBACN,CAAC;AAAA,oBACH;AAEA,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAI;AAAA,sBACJ,OAAO;AAAA,oBACT,CAAC;AAAA,kBACH;AAGA,uCAAqB,KAAK;AAAA,gBAC5B,OAAO;AAEL,qCAAmB;AAInB,sBAAI,QAAQ,gBAAgB,SAAS,QAAQ;AAE3C,wBAAI,CAAC,YAAY;AACf,mCAAa,WAAW;AACxB,iCAAW,QAAQ;AAAA,wBACjB,MAAM;AAAA,wBACN,IAAI;AAAA,sBACN,CAAC;AAAA,oBACH;AAEA,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAI;AAAA,sBACJ,OAAO;AAAA,oBACT,CAAC;AAAA,kBACH;AAAA,gBACF;AAAA,cACF;AAEA,kBAAI,YAAY;AACd,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AACD,6BAAa;AACb,kCAAkB;AAClB,qCAAqB;AAAA,cACvB;AAAA,YACF,WAAW,QAAQ,SAAS,QAAQ;AAClC,kBAAI,CAAC,QAAQ,SAAS,SAAS;AAC7B,qBAAK,OAAO;AAAA,kBACV,yFAAyF,QAAQ,IAAI;AAAA,gBACvG;AACA;AAAA,cACF;AAKA,kBAAI,YAAY;AACd,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBAEN,CAAC;AACD,6BAAa;AACb,kCAAkB;AAClB,qCAAqB;AACrB,qBAAK,OAAO,MAAM,sEAAsE;AAAA,cAC1F;AAEA,mBAAK,OAAO,MAAM,wCAAwC,KAAK,UAAU,QAAQ,OAAO,CAAC,EAAE;AAE3F,kBAAI,WAAW,QAAQ,SAAS;AAC9B,qBAAK,OAAO,MAAM,qCAAqC,KAAK,UAAU,QAAQ,QAAQ,KAAK,CAAC,EAAE;AAC9F,sCAAsB,QAAQ,QAAQ;AAAA,cACxC;AAEA,oBAAM,UAAU,QAAQ,QAAQ;AAChC,yBAAW,UAAU,KAAK,mBAAmB,OAAO,GAAG;AACrD,oBAAI,QAAQ,WAAW,IAAI,OAAO,EAAE;AACpC,sBAAM,cACJ,OAAO,QAAQ,OAAO,QAAQ,yBAAwB;AACxD,sBAAM,WAAW,KAAK,kBAAkB,WAAW;AAEnD,qBAAK,OAAO;AAAA,kBACV,8CAA8C,QAAQ,SAAS,OAAO,EAAE;AAAA,gBAC1E;AAEA,oBAAI,CAAC,OAAO;AACV,uBAAK,OAAO;AAAA,oBACV,2DAA2D,OAAO,EAAE;AAAA,kBACtE;AACA,0BAAQ;AAAA,oBACN,MAAM;AAAA,oBACN,cAAc;AAAA,oBACd,aAAa;AAAA,oBACb,aAAa;AAAA,kBACf;AACA,6BAAW,IAAI,OAAO,IAAI,KAAK;AAE/B,sBAAI,CAAC,MAAM,cAAc;AACvB,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAI,OAAO;AAAA,sBACX;AAAA,sBACA,kBAAkB;AAAA,sBAClB,SAAS;AAAA;AAAA,oBACX,CAAQ;AACR,0BAAM,eAAe;AAAA,kBACvB;AACA,sBAAI,CAAC,MAAM,aAAa;AACtB,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAI,OAAO;AAAA,oBACb,CAAC;AACD,0BAAM,cAAc;AAAA,kBACtB;AAAA,gBACF;AACA,sBAAM,OAAO;AACb,sBAAM,mBAAmB,KAAK,oBAAoB,aAAa,OAAO,MAAM;AAC5E,sBAAM,YACJ,OAAO,OAAO,WAAW,WACrB,OAAO,UACN,MAAM;AACL,sBAAI;AACF,2BAAO,KAAK,UAAU,OAAO,MAAM;AAAA,kBACrC,QAAQ;AACN,2BAAO,OAAO,OAAO,MAAM;AAAA,kBAC7B;AAAA,gBACF,GAAG;AAET,6BAAa,OAAO,IAAI,KAAK;AAE7B,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,YAAY,OAAO;AAAA,kBACnB;AAAA,kBACA,QAAQ;AAAA,kBACR,SAAS,OAAO;AAAA,kBAChB,kBAAkB;AAAA,kBAClB,SAAS;AAAA;AAAA,kBACT,kBAAkB;AAAA,oBAChB,eAAe;AAAA;AAAA;AAAA;AAAA,sBAIb;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF,CAAQ;AAAA,cACV;AAEA,yBAAW,SAAS,KAAK,kBAAkB,OAAO,GAAG;AACnD,oBAAI,QAAQ,WAAW,IAAI,MAAM,EAAE;AACnC,sBAAM,cACJ,MAAM,QAAQ,OAAO,QAAQ,yBAAwB;AACvD,sBAAM,WAAW,KAAK,kBAAkB,WAAW;AAEnD,qBAAK,OAAO;AAAA,kBACV,6CAA6C,QAAQ,SAAS,MAAM,EAAE;AAAA,gBACxE;AAEA,oBAAI,CAAC,OAAO;AACV,uBAAK,OAAO;AAAA,oBACV,0DAA0D,MAAM,EAAE;AAAA,kBACpE;AACA,0BAAQ;AAAA,oBACN,MAAM;AAAA,oBACN,cAAc;AAAA,oBACd,aAAa;AAAA,oBACb,aAAa;AAAA,kBACf;AACA,6BAAW,IAAI,MAAM,IAAI,KAAK;AAAA,gBAChC;AAGA,6BAAa,MAAM,IAAI,KAAK;AAE5B,sBAAM,WACJ,OAAO,MAAM,UAAU,WACnB,MAAM,QACN,OAAO,MAAM,UAAU,YAAY,MAAM,UAAU,QAChD,MAAM;AACL,sBAAI;AACF,2BAAO,KAAK,UAAU,MAAM,KAAK;AAAA,kBACnC,QAAQ;AACN,2BAAO,OAAO,MAAM,KAAK;AAAA,kBAC3B;AAAA,gBACF,GAAG,IACH,OAAO,MAAM,KAAK;AAE1B,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,YAAY,MAAM;AAAA,kBAClB;AAAA,kBACA,OAAO;AAAA,kBACP,kBAAkB;AAAA,kBAClB,SAAS;AAAA;AAAA,kBACT,kBAAkB;AAAA,oBAChB,eAAe;AAAA,sBACb;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF,CAAQ;AAAA,cACV;AAAA,YACF,WAAW,QAAQ,SAAS,UAAU;AACpC,mBAAK;AAIL,kBAAK,QAAQ,YAAuB,uCAAuC;AACzE,sBAAM,IAAI;AAAA,kBACR;AAAA,gBACF;AAAA,cACF;AAEA,mBAAK,OAAO;AAAA,gBACV,6CAA6C,QAAQ,UAAU,YAAY,QAAQ,gBAAgB,QAAQ,CAAC,KAAK,KAAK,eAAe,QAAQ,eAAe,KAAK;AAAA,cACnK;AAEA,mBAAK,OAAO,MAAM,6BAA6B,KAAK,UAAU,QAAQ,UAAU,CAAC,EAAE;AAEnF,kBAAI;AACJ,kBAAI,WAAW,SAAS;AACtB,2BAAW,QAAQ;AACnB,wBAAQ;AAAA,kBACN,cACG,QAAQ,MAAM,+BAA+B,MAC7C,QAAQ,MAAM,2BAA2B,MACzC,QAAQ,MAAM,gBAAgB;AAAA,kBACjC,cAAc,QAAQ,MAAM,iBAAiB;AAAA,kBAC7C,cACG,QAAQ,MAAM,+BAA+B,MAC7C,QAAQ,MAAM,2BAA2B,MACzC,QAAQ,MAAM,gBAAgB,MAC9B,QAAQ,MAAM,iBAAiB;AAAA,gBACpC;AAEA,qBAAK,OAAO;AAAA,kBACV,6CAA6C,MAAM,WAAW,aAAa,MAAM,YAAY,YAAY,MAAM,WAAW;AAAA,gBAC5H;AAAA,cACF;AAEA,oBAAM,eAA4C;AAAA,gBAChD,QAAQ;AAAA,cACV;AAEA,mBAAK,OAAO,MAAM,uCAAuC,YAAY,EAAE;AAGvE,mBAAK,aAAa,QAAQ,UAAU;AAGpC,oBAAM,mBACJ,uBAAuB,UAAU,QAAQ,oBAAoB;AAG/D,oBAAM,sBACJ,cAAc,QAAQ,gBAAgB,SAAS,UAAU;AAE3D,kBAAI,uBAAuB,YAAY;AAErC,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AAAA,cACH,WAAW,qBAAqB,QAAW;AAEzC,sBAAM,aAAa,WAAW;AAC9B,sBAAM,WAAW,KAAK,UAAU,gBAAgB;AAChD,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AACD,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,kBACJ,OAAO;AAAA,gBACT,CAAC;AACD,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AAAA,cACH,WAAW,YAAY;AAErB,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AAAA,cACH,WAAW,iBAAiB;AAI1B,sBAAM,iBAAiB,WAAW;AAClC,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AACD,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,kBACJ,OAAO;AAAA,gBACT,CAAC;AACD,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AAAA,cACH;AAEA,gCAAkB;AAGlB,oBAAM,eAAe,KAAK,6BAA6B,cAAc;AAErE,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN;AAAA,gBACA;AAAA,gBACA,kBAAkB;AAAA,kBAChB,eAAe;AAAA,oBACb,WAAW,QAAQ;AAAA,oBACnB,GAAI,QAAQ,mBAAmB,UAAa;AAAA,sBAC1C,SAAS,QAAQ;AAAA,oBACnB;AAAA,oBACA,GAAI,QAAQ,gBAAgB,UAAa,EAAE,YAAY,QAAQ,YAAY;AAAA,oBAC3E,GAAI,aAAa,UAAa,EAAE,SAAgC;AAAA,oBAChE,GAAI,wBAAwB,UAAa,EAAE,oBAAsD;AAAA;AAAA;AAAA;AAAA,oBAIjG,GAAI,eAAe,SAAS,KAAK;AAAA,sBAC/B,UAAU;AAAA,oBACZ;AAAA,kBACF;AAAA,gBACF;AAAA,cACF,CAAC;AAAA,YACH,WAAW,QAAQ,SAAS,YAAY,QAAQ,YAAY,QAAQ;AAElE,mBAAK,aAAa,QAAQ,UAAU;AAEpC,mBAAK,OAAO,KAAK,6CAA6C,QAAQ,UAAU,EAAE;AAGlF,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,IAAI,QAAQ;AAAA,gBACZ,WAAW,oBAAI,KAAK;AAAA,gBACpB,SAAS,KAAK;AAAA,cAChB,CAAC;AAAA,YACH;AAAA,UACF;AAEA,4BAAkB;AAClB,eAAK,OAAO,MAAM,gDAAgD;AAClE,qBAAW,MAAM;AAAA,QACnB,SAAS,OAAgB;AACvB,eAAK;AAEL,eAAK,OAAO;AAAA,YACV,wCAAwC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,UAChG;AAEA,cAAI,4BAA4B,OAAO,eAAe,GAAG;AACvD,iBAAK,OAAO;AAAA,cACV,+DAA+D,gBAAgB,MAAM;AAAA,YACvF;AACA,kBAAM,oBAAgD;AAAA,cACpD,MAAM;AAAA,cACN,SAAS;AAAA,YACX;AACA,2BAAe,KAAK,iBAAiB;AAErC,gBAAI,YAAY;AACd,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,IAAI;AAAA,cACN,CAAC;AAAA,YACH,WAAW,iBAAiB;AAC1B,oBAAM,iBAAiB,WAAW;AAClC,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,IAAI;AAAA,cACN,CAAC;AACD,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,IAAI;AAAA,gBACJ,OAAO;AAAA,cACT,CAAC;AACD,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,IAAI;AAAA,cACN,CAAC;AAAA,YACH;AAEA,8BAAkB;AAElB,kBAAM,eAAe,KAAK,6BAA6B,cAAc;AAErE,uBAAW,QAAQ;AAAA,cACjB,MAAM;AAAA,cACN,cAAc;AAAA,cACd;AAAA,cACA,kBAAkB;AAAA,gBAChB,eAAe;AAAA,kBACb,GAAI,KAAK,cAAc,UAAa,EAAE,WAAW,KAAK,UAAU;AAAA,kBAChE,WAAW;AAAA,kBACX,GAAI,eAAe,SAAS,KAAK;AAAA,oBAC/B,UAAU;AAAA,kBACZ;AAAA,gBACF;AAAA,cACF;AAAA,YACF,CAAC;AAED,uBAAW,MAAM;AACjB;AAAA,UACF;AAEA,4BAAkB;AAClB,cAAI;AAGJ,cAAI,aAAa,KAAK,GAAG;AACvB,0BAAc,QAAQ,aAAa,UAAU,QAAQ,YAAY,SAAS;AAAA,UAC5E,OAAO;AAEL,0BAAc,KAAK,sBAAsB,OAAO,gBAAgB,eAAe;AAAA,UACjF;AAGA,qBAAW,QAAQ;AAAA,YACjB,MAAM;AAAA,YACN,OAAO;AAAA,UACT,CAAC;AAED,qBAAW,MAAM;AAAA,QACnB,UAAE;AACA,cAAI,QAAQ,eAAe,eAAe;AACxC,oBAAQ,YAAY,oBAAoB,SAAS,aAAa;AAAA,UAChE;AAAA,QACF;AAAA,MACF;AAAA,MACA,QAAQ,MAAM;AACZ,YAAI,QAAQ,eAAe,eAAe;AACxC,kBAAQ,YAAY,oBAAoB,SAAS,aAAa;AAAA,QAChE;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO;AAAA,MACL;AAAA,MACA,SAAS;AAAA,QACP,MAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,6BAA6B,UAAmD;AACtF,UAAM,SAAS,SAAS,IAAI,CAAC,MAAM;AACjC,YAAM,OAA+B,EAAE,MAAM,EAAE,KAAK;AACpD,UAAI,aAAa,GAAG;AAClB,cAAM,IAAK,EAA4B;AACvC,YAAI,MAAM,OAAW,MAAK,UAAU,OAAO,CAAC;AAAA,MAC9C;AACA,UAAI,EAAE,SAAS,uBAAuB;AACpC,cAAM,UAAW,EAA2B;AAC5C,YAAI,YAAY,OAAW,MAAK,UAAU,OAAO,OAAO;AACxD,YAAI,aAAa,GAAG;AAClB,gBAAM,IAAK,EAA4B;AACvC,cAAI,MAAM,OAAW,MAAK,UAAU,OAAO,CAAC;AAAA,QAC9C;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC;AACD,WAAO;AAAA,EACT;AACF;;;ADn0DO,SAAS,iBAAiB,UAAsC,CAAC,GAAuB;AAE7F,QAAM,SAAS,UAAU,QAAQ,iBAAiB,MAAM;AAGxD,MAAI,QAAQ,iBAAiB;AAC3B,UAAM,aAAa,iBAAiB,QAAQ,eAAe;AAC3D,QAAI,CAAC,WAAW,OAAO;AACrB,YAAM,IAAI,MAAM,6BAA6B,WAAW,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,IAC7E;AACA,QAAI,WAAW,SAAS,SAAS,GAAG;AAClC,iBAAW,SAAS,QAAQ,CAAC,YAAY,OAAO,KAAK,yBAAyB,OAAO,EAAE,CAAC;AAAA,IAC1F;AAAA,EACF;AAEA,QAAM,cAAc,CAClB,SACA,WAA+B,CAAC,MACZ;AACpB,UAAM,iBAAiB;AAAA,MACrB,GAAG,QAAQ;AAAA,MACX,GAAG;AAAA,IACL;AAGA,UAAM,aAAa,iBAAiB,cAAc;AAClD,QAAI,CAAC,WAAW,OAAO;AACrB,YAAM,IAAI,MAAM,qBAAqB,WAAW,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,IACrE;AAEA,WAAO,IAAI,wBAAwB;AAAA,MACjC,IAAI;AAAA,MACJ,UAAU;AAAA,MACV,4BAA4B,WAAW;AAAA,IACzC,CAAC;AAAA,EACH;AAEA,QAAM,WAAW,SAAU,SAA4B,UAA+B;AACpF,QAAI,YAAY;AACd,YAAM,IAAI,MAAM,uEAAuE;AAAA,IACzF;AAEA,WAAO,YAAY,SAAS,QAAQ;AAAA,EACtC;AAEA,WAAS,gBAAgB;AACzB,WAAS,OAAO;AAGhB,WAAS,qBAAqB,CAAC,YAAoB;AACjD,UAAM,IAAIC,kBAAiB;AAAA,MACzB;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAAA,EACH;AAEA,WAAS,aAAa,CAAC,YAAoB;AACzC,UAAM,IAAIA,kBAAiB;AAAA,MACzB;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAiBO,IAAM,aAAa,iBAAiB;;;AOvI3C,SAAS,sBAAAC,qBAAoB,QAAAC,aAAY;;;AC1CzC,SAAS,sBAAAC,qBAAoB,QAAAC,aAAY;AAEzC,OAAiD;AAyF1C,SAAS,sBASd,QAA0F;AAC1F,QAAM,OAAO,OAAO,QAAQ,OAAO,KAAK,EAAE;AAAA,IAAI,CAAC,CAAC,MAAM,GAAG,MACvDA;AAAA,MACE;AAAA,MACA,IAAI;AAAA,MACJ,IAAI,YAAY;AAAA,MAChB,CAAC,MAA+B,UAAmB,IAAI,QAAQ,MAAM,KAAK;AAAA,IAC5E;AAAA,EACF;AACA,SAAOD,oBAAmB,EAAE,MAAM,OAAO,MAAM,SAAS,OAAO,SAAS,OAAO,KAAK,CAAC;AACvF;","names":["NoSuchModelError","tool","tool","content","tool","NoSuchModelError","createSdkMcpServer","tool","createSdkMcpServer","tool"]}
\ No newline at end of file
